{"/home/travis/build/npmtest/node-npmtest-kbpgp/test.js":"/* istanbul instrument in package npmtest_kbpgp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kbpgp/lib.npmtest_kbpgp.js":"/* istanbul instrument in package npmtest_kbpgp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_kbpgp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_kbpgp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-kbpgp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-kbpgp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_kbpgp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_kbpgp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_kbpgp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_kbpgp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_kbpgp.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_kbpgp.__dirname + '/lib.npmtest_kbpgp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/main.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var k, m, mods, util, v, _i, _len;\n\n  mods = [require(\"./openpgp/keymanager\"), require(\"./basex\"), require(\"./openpgp/burner\"), require(\"./openpgp/hilev\"), require(\"./keyfetch\"), require(\"./keyring\"), require('./errors')];\n\n  for (_i = 0, _len = mods.length; _i < _len; _i++) {\n    m = mods[_i];\n    for (k in m) {\n      v = m[k];\n      exports[k] = v;\n    }\n  }\n\n  exports.util = util = require('./util');\n\n  exports.ASP = util.ASP;\n\n  exports.rand = require('./rand');\n\n  exports[\"const\"] = require('./const');\n\n  exports.processor = require('./openpgp/processor');\n\n  exports.armor = require('./openpgp/armor');\n\n  exports.keyring = require('./keyring');\n\n  exports.parser = require('./openpgp/parser');\n\n  exports.Buffer = Buffer;\n\n  exports.triplesec = require('triplesec');\n\n  exports.hash = require('./hash');\n\n  exports.ecc = require('./ecc/main');\n\n  exports.nacl = require('./nacl/main');\n\n  exports.kb = require('./keybase/hilev');\n\n  exports.ukm = require('./ukm');\n\n  exports.asym = require('./asymmetric');\n\n  exports.bn = require('./bn');\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/keymanager.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, C, ECDSA, Encryptor, Engine, K, KeyBlock, KeyFetched, KeyFetcher, KeyManager, KeyManagerInterface, Lifespan, Message, P3SKB, PgpEngine, Primary, RSA, SHA256, SignatureEngine, Subkey, assert_no_nulls, athrow, bufeq_secure, bufferify, decode, encode, errors, format_pgp_fingerprint_2, iced, katch, lifespan_from_keywrapper_and_time, make_esc, opkts, ops_to_keyflags, parse, read_base64, unix_time, unseal, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3, _ref4,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __slice = [].slice;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  RSA = require('../rsa').RSA;\n\n  ECDSA = require('../ecc/ecdsa').ECDSA;\n\n  SHA256 = require('../hash').SHA256;\n\n  K = require('../const').kb;\n\n  C = require('../const').openpgp;\n\n  make_esc = require('iced-error').make_esc;\n\n  errors = require('../errors').errors;\n\n  _ref = require('../util'), format_pgp_fingerprint_2 = _ref.format_pgp_fingerprint_2, athrow = _ref.athrow, assert_no_nulls = _ref.assert_no_nulls, ASP = _ref.ASP, katch = _ref.katch, bufeq_secure = _ref.bufeq_secure, unix_time = _ref.unix_time, bufferify = _ref.bufferify;\n\n  ops_to_keyflags = require('./util').ops_to_keyflags;\n\n  _ref1 = require('../keywrapper'), Lifespan = _ref1.Lifespan, Subkey = _ref1.Subkey, Primary = _ref1.Primary;\n\n  _ref2 = require('./armor'), Message = _ref2.Message, encode = _ref2.encode, decode = _ref2.decode;\n\n  parse = require('./parser').parse;\n\n  KeyBlock = require('./processor').KeyBlock;\n\n  opkts = require('./packet/all');\n\n  _ref3 = require('../keybase/encode'), read_base64 = _ref3.read_base64, unseal = _ref3.unseal;\n\n  P3SKB = require('../keybase/packet/p3skb').P3SKB;\n\n  _ref4 = require('../keyfetch'), KeyFetcher = _ref4.KeyFetcher, KeyFetched = _ref4.KeyFetched;\n\n  SignatureEngine = require('./sigeng').SignatureEngine;\n\n  Encryptor = require('triplesec').Encryptor;\n\n  KeyManagerInterface = require('../kmi').KeyManagerInterface;\n\n  Engine = (function() {\n    function Engine(_arg) {\n      var k, _i, _len, _ref5;\n      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.key_manager = _arg.key_manager;\n      this.packets = [];\n      this.messages = [];\n      this._allocate_key_packets();\n      _ref5 = this.subkeys;\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        k.primary = this.primary;\n      }\n      this._index_keys();\n      true;\n    }\n\n    Engine.prototype._index_keys = function() {\n      var k, _i, _len, _ref5, _results;\n      this._index = {};\n      _ref5 = this._all_keys();\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        _results.push(this._index[this.ekid(k)] = k);\n      }\n      return _results;\n    };\n\n    Engine.prototype.ekid = function(k) {\n      return this.key(k).ekid();\n    };\n\n    Engine.prototype._allocate_key_packets = function() {\n      var key, _i, _len, _ref5, _results;\n      this._v_allocate_key_packet(this.primary, {\n        subkey: false\n      });\n      _ref5 = this.subkeys;\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        key = _ref5[_i];\n        _results.push(this._v_allocate_key_packet(key, {\n          subkey: true\n        }));\n      }\n      return _results;\n    };\n\n    Engine.prototype._all_keys = function() {\n      return [this.primary].concat(this.subkeys);\n    };\n\n    Engine.prototype.self_sign_primary = function(args, cb) {\n      return this._v_self_sign_primary(args, cb);\n    };\n\n    Engine.prototype.get_all_key_materials = function() {\n      var k;\n      return [[this.key(this.primary), true]].concat((function() {\n        var _i, _len, _ref5, _results;\n        _ref5 = this.subkeys;\n        _results = [];\n        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n          k = _ref5[_i];\n          _results.push([this.key(k), false]);\n        }\n        return _results;\n      }).call(this));\n    };\n\n    Engine.prototype.sign_subkeys = function(_arg, cb) {\n      var asp, err, subkey, time, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      time = _arg.time, asp = _arg.asp;\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref5, _results, _while;\n          _ref5 = _this.subkeys;\n          _len = _ref5.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              subkey = _ref5[_i];\n              if (err == null) {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                    funcname: \"Engine.sign_subkeys\"\n                  });\n                  _this._v_sign_subkey({\n                    asp: asp,\n                    time: time,\n                    subkey: subkey\n                  }, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return err = arguments[0];\n                      };\n                    })(),\n                    lineno: 75\n                  }));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              } else {\n                return _continue();\n              }\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Engine.prototype.get_subkey_materials = function() {\n      var k, _i, _len, _ref5, _results;\n      _ref5 = this.subkeys;\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        _results.push(this.key(k));\n      }\n      return _results;\n    };\n\n    Engine.prototype.is_locked = function() {\n      var i, k, _i, _len, _ref5;\n      _ref5 = this._all_keys();\n      for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {\n        k = _ref5[i];\n        if (this.key(k).is_locked()) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    Engine.prototype.has_private = function() {\n      var k, _i, _len, _ref5;\n      _ref5 = this._all_keys();\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        if (this.key(k).has_private()) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    Engine.prototype.sign = function(_arg, cb) {\n      var asp, err, time, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, time = _arg.time;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"Engine.sign\"\n          });\n          _this.self_sign_primary({\n            asp: asp,\n            time: time\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 99\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (typeof err === \"undefined\" || err === null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"Engine.sign\"\n                });\n                _this.sign_subkeys({\n                  asp: asp,\n                  time: time\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 100\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Engine.prototype.check_eq = function(eng2) {\n      var err, i, key, _i, _len, _ref5;\n      err = null;\n      if (!this.primary.key.eq(eng2.primary.key)) {\n        err = new Error(\"Primary keys don't match\");\n      } else if (this.subkeys.length !== eng2.subkeys.length) {\n        err = new Error(\"different # of subkeys\");\n      } else {\n        _ref5 = this.subkeys;\n        for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {\n          key = _ref5[i];\n          if (this.err == null) {\n            if (!key.key.eq(eng2.subkeys[i].key)) {\n              err = new Error(\"subkey \" + i + \" doesn't match\");\n            }\n          }\n        }\n      }\n      return err;\n    };\n\n    Engine.prototype.merge_private = function(eng2) {\n      var err, i, k, _i, _len, _ref5;\n      err = this._merge_private_primary(eng2);\n      if (err == null) {\n        _ref5 = eng2.subkeys;\n        for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {\n          k = _ref5[i];\n          if ((err = this._merge_private_subkey(k, i)) != null) {\n            break;\n          }\n        }\n      }\n      return err;\n    };\n\n    Engine.prototype._merge_private_primary = function(eng2) {\n      var err;\n      err = !this.key(eng2.primary).has_secret_key_material() ? null : this._merge_1_private(this.primary, eng2.primary) ? null : new Error(\"primary public key doesn't match private key\");\n      return err;\n    };\n\n    Engine.prototype._merge_private_subkey = function(k2, i) {\n      var ekid, err, k;\n      err = !this.key(k2).has_secret_key_material() ? null : (ekid = this.ekid(k2)) == null ? new Error(\"Subkey \" + i + \" is malformed\") : (k = this._index[ekid]) == null ? new Error(\"Subkey \" + i + \" wasn't found in public key\") : this._merge_1_private(k, k2) ? null : new Error(\"subkey \" + i + \" can't be merged\");\n      return err;\n    };\n\n    Engine.prototype.unlock_keys = function(_arg, cb) {\n      var asp, esc, i, passphrase, subkey, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, passphrase = _arg.passphrase, tsenc = _arg.tsenc;\n      esc = make_esc(cb, \"Engine::unlock_keys\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"Engine.unlock_keys\"\n          });\n          _this.key(_this.primary).unlock({\n            asp: asp,\n            tsenc: tsenc,\n            passphrase: passphrase\n          }, esc(__iced_deferrals.defer({\n            lineno: 148\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _i, _len, _ref5, _results, _while;\n            _ref5 = _this.subkeys;\n            _len = _ref5.length;\n            i = 0;\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = __iced_k;\n              _continue = function() {\n                return iced.trampoline(function() {\n                  ++i;\n                  return _while(__iced_k);\n                });\n              };\n              _next = _continue;\n              if (!(i < _len)) {\n                return _break();\n              } else {\n                subkey = _ref5[i];\n                if (_this.key(subkey).has_private()) {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                      funcname: \"Engine.unlock_keys\"\n                    });\n                    _this.key(subkey).unlock({\n                      asp: asp,\n                      tsenc: tsenc,\n                      passphrase: passphrase\n                    }, esc(__iced_deferrals.defer({\n                      lineno: 150\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(_next);\n                } else {\n                  return _continue();\n                }\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            return cb(null);\n          });\n        };\n      })(this));\n    };\n\n    Engine.prototype.export_keys_to_keyring = function(km) {\n      var k, x;\n      x = (function(_this) {\n        return function(key_wrapper, is_primary) {\n          return {\n            km: km,\n            is_primary: is_primary,\n            key_wrapper: key_wrapper,\n            key_material: _this.key(key_wrapper),\n            key: _this.key(key_wrapper).key\n          };\n        };\n      })(this);\n      return [x(this.primary, true)].concat((function() {\n        var _i, _len, _ref5, _results;\n        _ref5 = this.subkeys;\n        _results = [];\n        for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n          k = _ref5[_i];\n          _results.push(x(k, false));\n        }\n        return _results;\n      }).call(this));\n    };\n\n    Engine.prototype._merge_1_private = function(k1, k2) {\n      if (bufeq_secure(this.ekid(k1), this.ekid(k2))) {\n        this.key(k1).merge_private(this.key(k2));\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    Engine.prototype.merge_subkey_omitting_revokes = function(k) {\n      var ekid, kw;\n      ekid = k.ekid();\n      if ((kw = this._index[ekid]) != null) {\n        return kw.overwrite_with_omitting_revokes(k);\n      } else {\n        this._index[ekid] = k;\n        return this.subkeys.push(k);\n      }\n    };\n\n    Engine.prototype.merge_public_omitting_revokes = function(pgpeng2) {\n      this.primary.overwrite_with_omitting_revokes(pgpeng2.primary);\n      return this.merge_all_subkeys_omitting_revokes(pgpeng2);\n    };\n\n    Engine.prototype.merge_all_subkeys_omitting_revokes = function(pgpeng2) {\n      var subkey, _i, _len, _ref5, _results;\n      _ref5 = pgpeng2.subkeys;\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        subkey = _ref5[_i];\n        _results.push(this.merge_subkey_omitting_revokes(subkey));\n      }\n      return _results;\n    };\n\n    Engine.prototype.check_not_expired = function(_arg) {\n      var err, now, subkey_material;\n      subkey_material = _arg.subkey_material, now = _arg.now;\n      now || (now = unix_time());\n      err = this.key(this.primary).check_not_expired({\n        now: now\n      });\n      if (err == null) {\n        err = subkey_material.check_not_expired({\n          now: now\n        });\n      }\n      return err;\n    };\n\n    return Engine;\n\n  })();\n\n  lifespan_from_keywrapper_and_time = function(_arg) {\n    var key_wrapper, ret, time;\n    key_wrapper = _arg.key_wrapper, time = _arg.time;\n    ret = key_wrapper.lifespan;\n    if (time != null) {\n      ret = ret.copy();\n      ret.generated = time;\n    }\n    return ret;\n  };\n\n  PgpEngine = (function(_super) {\n    __extends(PgpEngine, _super);\n\n    function PgpEngine(_arg) {\n      var key_manager, primary, subkeys, userids;\n      primary = _arg.primary, subkeys = _arg.subkeys, userids = _arg.userids, this.user_attributes = _arg.user_attributes, key_manager = _arg.key_manager;\n      PgpEngine.__super__.constructor.call(this, {\n        primary: primary,\n        subkeys: subkeys,\n        userids: userids,\n        key_manager: key_manager\n      });\n    }\n\n    PgpEngine.prototype.key = function(k) {\n      return k._pgp;\n    };\n\n    PgpEngine.prototype._v_allocate_key_packet = function(key, opts) {\n      if (key._pgp == null) {\n        return key._pgp = new opkts.KeyMaterial({\n          key: key.key,\n          timestamp: key.lifespan.generated,\n          flags: key.flags,\n          opts: opts\n        });\n      }\n    };\n\n    PgpEngine.prototype._v_self_sign_primary = function(_arg, cb) {\n      var asp, err, lifespan, raw_payload, sigs, time, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      time = _arg.time, asp = _arg.asp, raw_payload = _arg.raw_payload;\n      lifespan = lifespan_from_keywrapper_and_time({\n        key_wrapper: this.primary,\n        time: time\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"PgpEngine._v_self_sign_primary\"\n          });\n          _this.key(_this.primary).self_sign_key({\n            lifespan: lifespan,\n            userids: _this.userids,\n            raw_payload: raw_payload\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return sigs = arguments[1];\n              };\n            })(),\n            lineno: 240\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sigs);\n        };\n      })(this));\n    };\n\n    PgpEngine.prototype._v_sign_subkey = function(_arg, cb) {\n      var asp, err, lifespan, subkey, time, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, subkey = _arg.subkey, time = _arg.time;\n      lifespan = lifespan_from_keywrapper_and_time({\n        key_wrapper: subkey,\n        time: time\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"PgpEngine._v_sign_subkey\"\n          });\n          _this.key(_this.primary).sign_subkey({\n            subkey: _this.key(subkey),\n            lifespan: lifespan\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 247\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    PgpEngine.prototype.clear_psc = function() {\n      var s, u, _i, _j, _len, _len1, _ref5, _ref6, _results;\n      this.key(this.primary).clear_psc();\n      _ref5 = this.userids;\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        u = _ref5[_i];\n        u.clear_psc();\n      }\n      _ref6 = this.subkeys;\n      _results = [];\n      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {\n        s = _ref6[_j];\n        _results.push(this.key(s).clear_psc());\n      }\n      return _results;\n    };\n\n    PgpEngine.prototype.set_passphrase = function(pp) {\n      var k, _i, _len, _ref5, _results;\n      this.primary.passphrase = pp;\n      _ref5 = this.subkeys;\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        _results.push(k.passphrase = pp);\n      }\n      return _results;\n    };\n\n    PgpEngine.prototype._export_keys_to_binary = function(opts) {\n      var packets, subkey, userid, _i, _j, _len, _len1, _ref5, _ref6;\n      packets = [this.key(this.primary).export_framed(opts)];\n      _ref5 = this.userids;\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        userid = _ref5[_i];\n        packets.push(userid.write(), userid.get_framed_signature_output());\n      }\n      opts.subkey = true;\n      _ref6 = this.subkeys;\n      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {\n        subkey = _ref6[_j];\n        packets.push(this.key(subkey).export_framed(opts), this.key(subkey).get_subkey_binding_signature_output());\n      }\n      assert_no_nulls(packets);\n      return Buffer.concat(packets);\n    };\n\n    PgpEngine.prototype.export_keys = function(opts) {\n      var msg, mt, type;\n      mt = C.message_types;\n      type = opts[\"private\"] ? mt.private_key : mt.public_key;\n      msg = this._export_keys_to_binary(opts);\n      return encode(type, msg);\n    };\n\n    PgpEngine.prototype.export_to_p3skb = function() {\n      var priv_clear, pub;\n      pub = this._export_keys_to_binary({\n        \"private\": false\n      });\n      priv_clear = this._export_keys_to_binary({\n        \"private\": true\n      });\n      return new P3SKB({\n        pub: pub,\n        priv_clear: priv_clear\n      });\n    };\n\n    PgpEngine.prototype.find_key = function(key_id) {\n      var k, _i, _len, _ref5;\n      _ref5 = this._all_keys();\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        if (bufeq_secure(this.key(k).get_key_id(), key_id)) {\n          return k;\n        }\n      }\n      return null;\n    };\n\n    PgpEngine.prototype.find_key_material = function(key_id) {\n      var key;\n      key = this.find_key(key_id);\n      if (key != null) {\n        return this.key(key);\n      } else {\n        return null;\n      }\n    };\n\n    PgpEngine.prototype.get_key_id = function() {\n      return this.key(this.primary).get_key_id();\n    };\n\n    PgpEngine.prototype.get_short_key_id = function() {\n      return this.key(this.primary).get_short_key_id();\n    };\n\n    PgpEngine.prototype.get_fingerprint = function() {\n      return this.key(this.primary).get_fingerprint();\n    };\n\n    PgpEngine.prototype.get_ekid = function() {\n      return this.key(this.primary).ekid();\n    };\n\n    PgpEngine.prototype.get_all_key_ids = function() {\n      var k, _i, _len, _ref5, _results;\n      _ref5 = this._all_keys();\n      _results = [];\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        _results.push(this.key(k).get_key_id());\n      }\n      return _results;\n    };\n\n    PgpEngine.prototype.validity_check = function(cb) {\n      var err, k, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref5, _results, _while;\n          _ref5 = _this._all_keys();\n          _len = _ref5.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              k = _ref5[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"PgpEngine.validity_check\"\n                });\n                _this.key(k).validity_check(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 323\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  if (err != null) {\n                    (function(__iced_k) {\n_break()\n                    })(__iced_k);\n                  } else {\n                    return __iced_k();\n                  }\n                })(_next);\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    PgpEngine.prototype.find_best_key = function(flags, need_priv) {\n      var best, check, k, _i, _len, _ref5;\n      if (need_priv == null) {\n        need_priv = false;\n      }\n      best = null;\n      check = (function(_this) {\n        return function(k) {\n          var km, ok1, ok2, ok3;\n          km = _this.key(k);\n          ok1 = km.fulfills_flags(flags) || ((k.flags & flags) === flags);\n          ok2 = !need_priv || km.has_private();\n          ok3 = !km.is_revoked();\n          return ok1 && ok2 && ok3;\n        };\n      })(this);\n      _ref5 = this.subkeys;\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        k = _ref5[_i];\n        if (check(k)) {\n          if (best == null) {\n            best = k;\n          } else if (this.key(k).is_preferable_to(this.key(best))) {\n            best = k;\n          }\n        }\n      }\n      if ((best == null) && check(this.primary)) {\n        best = this.primary;\n      }\n      return (best != null ? this.key(best) : null);\n    };\n\n    PgpEngine.prototype.fetch = function(key_ids, op_mask, cb) {\n      var err, flags, i, key, kid, ret, ret_i, _i, _len;\n      flags = ops_to_keyflags(op_mask);\n      err = key = ret = null;\n      key = null;\n      ret_i = null;\n      for (i = _i = 0, _len = key_ids.length; _i < _len; i = ++_i) {\n        kid = key_ids[i];\n        if (!(key == null)) {\n          continue;\n        }\n        key = this.find_key(kid);\n        if (key != null) {\n          ret_i = i;\n        }\n      }\n      if (key == null) {\n        err = new Error(\"No keys match the given key IDs\");\n      } else if (this.key(key).is_revoked()) {\n        err = new errors.RevokedKeyError;\n        err.km = this;\n      } else if (!this.key(key).fulfills_flags(flags)) {\n        err = new Error(\"We don't have a key for the requested PGP ops (flags = \" + flags + \")\");\n      } else {\n        ret = this.key(key);\n      }\n      return cb(err, this.key_manager, ret_i);\n    };\n\n    return PgpEngine;\n\n  })(Engine);\n\n  KeyManager = (function(_super) {\n    __extends(KeyManager, _super);\n\n    function KeyManager(_arg) {\n      var signed;\n      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public, this.armored_pgp_private = _arg.armored_pgp_private, this.user_attributes = _arg.user_attributes, signed = _arg.signed;\n      this.pgp = new PgpEngine({\n        primary: this.primary,\n        subkeys: this.subkeys,\n        userids: this.userids,\n        user_attributes: this.user_attributes,\n        key_manager: this\n      });\n      this.engines = [this.pgp];\n      this._signed = signed != null ? signed : false;\n      this.p3skb = null;\n    }\n\n    KeyManager.generate = function(_arg, cb) {\n      var F, KEY_FLAGS_PRIMARY, KEY_FLAGS_STD, asp, bundle, curve_name, ecc, err, esc, expire_in, flags, gen, generated, i, nbits, nsubs, primary, primary_flags, s, sub_flags, subkey, subkeys, subkeys_out, u, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _len;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, userid = _arg.userid, userids = _arg.userids, primary = _arg.primary, subkeys = _arg.subkeys, ecc = _arg.ecc, sub_flags = _arg.sub_flags, nsubs = _arg.nsubs, primary_flags = _arg.primary_flags, nbits = _arg.nbits, expire_in = _arg.expire_in, generated = _arg.generated, curve_name = _arg.curve_name;\n      asp = ASP.make(asp);\n      F = C.key_flags;\n      KEY_FLAGS_STD = F.sign_data | F.encrypt_comm | F.encrypt_storage | F.auth;\n      KEY_FLAGS_PRIMARY = KEY_FLAGS_STD | F.certify_keys;\n      primary || (primary = {});\n      primary.flags || (primary.flags = primary_flags || KEY_FLAGS_PRIMARY);\n      primary.expire_in || (primary.expire_in = (expire_in != null ? expire_in.primary : void 0) || K.key_defaults.primary.expire_in);\n      primary.algo || (primary.algo = (ecc ? ECDSA : RSA));\n      primary.nbits || (primary.nbits = nbits || K.key_defaults.primary.nbits[primary.algo.klass_name]);\n      if (curve_name) {\n        primary.curve_name = curve_name;\n      }\n      if ((nsubs != null) && (sub_flags == null)) {\n        sub_flags = (function() {\n          var _i, _results;\n          _results = [];\n          for (i = _i = 0; 0 <= nsubs ? _i < nsubs : _i > nsubs; i = 0 <= nsubs ? ++_i : --_i) {\n            _results.push(KEY_FLAGS_STD);\n          }\n          return _results;\n        })();\n      }\n      subkeys || (subkeys = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = sub_flags.length; _i < _len; _i++) {\n          flags = sub_flags[_i];\n          _results.push({\n            flags: flags\n          });\n        }\n        return _results;\n      })());\n      for (_i = 0, _len = subkeys.length; _i < _len; _i++) {\n        subkey = subkeys[_i];\n        subkey.expire_in || (subkey.expire_in = (expire_in != null ? expire_in.subkey : void 0) || K.key_defaults.sub.expire_in);\n        subkey.flags || (subkey.flags = KEY_FLAGS_STD);\n        subkey.algo || (subkey.algo = primary.algo.subkey_algo(subkey.flags));\n        subkey.nbits || (subkey.nbits = nbits || K.key_defaults.sub.nbits[subkey.algo.klass_name]);\n      }\n      generated || (generated = unix_time());\n      esc = make_esc(cb, \"KeyManager::generate\");\n      if (userid != null) {\n        userids = [userid];\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((userids != null) && Array.isArray(userids)) {\n            return __iced_k(userids = (function() {\n              var _j, _len1, _results;\n              _results = [];\n              for (_j = 0, _len1 = userids.length; _j < _len1; _j++) {\n                u = userids[_j];\n                _results.push(new opkts.UserID(u));\n              }\n              return _results;\n            })());\n          } else {\n            err = new Error(\"Need either 'userid' or 'userids' specified as an array\");\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.generate\"\n              });\n              athrow(err, esc(__iced_deferrals.defer({\n                lineno: 459\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          gen = function(_arg1, cb) {\n            var err, key, klass, lifespan, my_generated, params, primary, section, wrapper, ___iced_passed_deferral1, __iced_deferrals, __iced_k;\n            __iced_k = __iced_k_noop;\n            ___iced_passed_deferral1 = iced.findDeferral(arguments);\n            klass = _arg1.klass, section = _arg1.section, params = _arg1.params, primary = _arg1.primary;\n            asp.section(section);\n            (function(_this) {\n              return (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral1,\n                  filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\"\n                });\n                params.algo.generate({\n                  asp: asp,\n                  nbits: params.nbits,\n                  curve_name: params.curve_name\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return key = arguments[1];\n                    };\n                  })(),\n                  lineno: 463\n                }));\n                __iced_deferrals._fulfill();\n              });\n            })(this)((function(_this) {\n              return function() {\n                if (typeof err === \"undefined\" || err === null) {\n                  my_generated = params.generated || generated;\n                  lifespan = new Lifespan({\n                    generated: my_generated,\n                    expire_in: params.expire_in\n                  });\n                  wrapper = new klass({\n                    key: key,\n                    lifespan: lifespan,\n                    flags: params.flags,\n                    primary: primary\n                  });\n                }\n                return cb(err, wrapper);\n              };\n            })(this));\n          };\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n              funcname: \"KeyManager.generate\"\n            });\n            gen({\n              klass: Primary,\n              section: \"primary\",\n              params: primary\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return primary = arguments[0];\n                };\n              })(),\n              lineno: 470\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            subkeys_out = [];\n            (function(__iced_k) {\n              var _j, _len1, _ref5, _results, _while;\n              _ref5 = subkeys;\n              _len1 = _ref5.length;\n              i = 0;\n              _while = function(__iced_k) {\n                var _break, _continue, _next;\n                _break = __iced_k;\n                _continue = function() {\n                  return iced.trampoline(function() {\n                    ++i;\n                    return _while(__iced_k);\n                  });\n                };\n                _next = _continue;\n                if (!(i < _len1)) {\n                  return _break();\n                } else {\n                  subkey = _ref5[i];\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                      funcname: \"KeyManager.generate\"\n                    });\n                    gen({\n                      klass: Subkey,\n                      section: \"subkey \" + (i + 1),\n                      params: subkey,\n                      primary: primary\n                    }, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return s = arguments[0];\n                        };\n                      })(),\n                      lineno: 473\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return _next(subkeys_out.push(s));\n                  });\n                }\n              };\n              _while(__iced_k);\n            })(function() {\n              bundle = new KeyManager({\n                primary: primary,\n                subkeys: subkeys_out,\n                userids: userids\n              });\n              return cb(null, bundle);\n            });\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.generate_rsa = function(_arg, cb) {\n      var F, asp, primary, subkeys, userid, userids;\n      asp = _arg.asp, userid = _arg.userid, userids = _arg.userids;\n      F = C.key_flags;\n      primary = {\n        flags: F.certify_keys,\n        nbits: 4096\n      };\n      subkeys = [\n        {\n          flags: F.encrypt_storage | F.encrypt_comm,\n          nbits: 2048\n        }, {\n          flags: F.sign_data | F.auth,\n          nbits: 2048\n        }\n      ];\n      return KeyManager.generate({\n        asp: asp,\n        userid: userid,\n        userids: userids,\n        primary: primary,\n        subkeys: subkeys\n      }, cb);\n    };\n\n    KeyManager.generate_ecc = function(_arg, cb) {\n      var F, asp, generated, primary, subkeys, userid, userids;\n      asp = _arg.asp, userid = _arg.userid, userids = _arg.userids, generated = _arg.generated;\n      F = C.key_flags;\n      primary = {\n        flags: F.certify_keys,\n        nbits: 384,\n        algo: ECDSA\n      };\n      subkeys = [\n        {\n          flags: F.encrypt_storage | F.encrypt_comm,\n          nbits: 256\n        }, {\n          flags: F.sign_data | F.auth,\n          nbits: 256\n        }\n      ];\n      return KeyManager.generate({\n        asp: asp,\n        userid: userid,\n        userids: userids,\n        primary: primary,\n        subkeys: subkeys,\n        generated: generated\n      }, cb);\n    };\n\n    KeyManager.prototype.set_enc = function(e) {\n      return this.tsenc = e;\n    };\n\n    KeyManager.import_from_armored_pgp = function(_arg, cb) {\n      var armored, asp, binary, err, msg, opts, packets, raw, ret, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5, _ref6;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      armored = _arg.armored, raw = _arg.raw, binary = _arg.binary, asp = _arg.asp, opts = _arg.opts;\n      msg = binary;\n      err = null;\n      if (msg == null) {\n        raw || (raw = armored);\n        asp = ASP.make(asp);\n        warnings = null;\n        ret = null;\n        _ref5 = decode(raw), err = _ref5[0], msg = _ref5[1];\n        if (err == null) {\n          if (!((_ref6 = msg.type) === C.message_types.public_key || _ref6 === C.message_types.private_key)) {\n            err = new Error(\"Wanted a public or private key; got: \" + msg.type);\n          }\n        }\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.import_from_armored_pgp\"\n              });\n              KeyManager.import_from_pgp_message({\n                msg: msg,\n                asp: asp,\n                opts: opts\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    ret = arguments[1];\n                    warnings = arguments[2];\n                    return packets = arguments[3];\n                  };\n                })(),\n                lineno: 551\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (!(err != null)) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"KeyManager.import_from_armored_pgp\"\n                });\n                ret.simple_unlock({}, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 557\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, ret, warnings, packets);\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.simple_unlock = function(opts, cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (_this.has_pgp_private() && !_this.is_pgp_locked()) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.simple_unlock\"\n              });\n              _this.unlock_pgp({}, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 569\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.import_from_p3skb = function(_arg, cb) {\n      var armored, asp, err, km, msg, p3skb, raw, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      raw = _arg.raw, armored = _arg.armored, asp = _arg.asp;\n      armored || (armored = raw);\n      asp = ASP.make(asp);\n      km = null;\n      warnings = null;\n      _ref5 = katch(function() {\n        return P3SKB.alloc(unseal(read_base64(armored)));\n      }), err = _ref5[0], p3skb = _ref5[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            msg = new Message({\n              body: p3skb.pub,\n              type: C.message_types.public_key\n            });\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.import_from_p3skb\"\n              });\n              KeyManager.import_from_pgp_message({\n                msg: msg,\n                asp: asp\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    km = arguments[1];\n                    return warnings = arguments[2];\n                  };\n                })(),\n                lineno: 584\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(km != null ? km.p3skb = p3skb : void 0);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, km, warnings);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.unlock_p3skb = function(_arg, cb) {\n      var asp, err, km, msg, passphrase, passphrase_generation, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, tsenc = _arg.tsenc, passphrase = _arg.passphrase, passphrase_generation = _arg.passphrase_generation;\n      asp = ASP.make(asp);\n      if ((tsenc == null) && (passphrase != null)) {\n        tsenc = new Encryptor({\n          key: bufferify(passphrase)\n        });\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.unlock_p3skb\"\n          });\n          _this.p3skb.unlock({\n            tsenc: tsenc,\n            asp: asp,\n            passphrase_generation: passphrase_generation\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 594\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              msg = new Message({\n                body: _this.p3skb.priv.data,\n                type: C.message_types.private_key\n              });\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"KeyManager.unlock_p3skb\"\n                });\n                KeyManager.import_from_pgp_message({\n                  msg: msg,\n                  asp: asp\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return km = arguments[1];\n                    };\n                  })(),\n                  lineno: 597\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            if (typeof err === \"undefined\" || err === null) {\n              err = _this.pgp.merge_private(km.pgp);\n            }\n            (function(__iced_k) {\n              if (err == null) {\n                passphrase = new Buffer([]);\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                    funcname: \"KeyManager.unlock_p3skb\"\n                  });\n                  _this.unlock_pgp({\n                    passphrase: passphrase\n                  }, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return err = arguments[0];\n                      };\n                    })(),\n                    lineno: 606\n                  }));\n                  __iced_deferrals._fulfill();\n                })(__iced_k);\n              } else {\n                return __iced_k();\n              }\n            })(function() {\n              return cb(err);\n            });\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.import_from_pgp_message = function(_arg, cb) {\n      var asp, bundle, err, k, kb, msg, opts, packets, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      msg = _arg.msg, asp = _arg.asp, opts = _arg.opts;\n      asp = ASP.make(asp);\n      bundle = null;\n      warnings = null;\n      if (typeof err === \"undefined\" || err === null) {\n        _ref5 = parse(msg.body), err = _ref5[0], packets = _ref5[1];\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            kb = new KeyBlock(packets, opts);\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.import_from_pgp_message\"\n              });\n              kb.process(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 621\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(warnings = kb.warnings);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            bundle = new KeyManager({\n              primary: KeyManager._wrap_pgp(Primary, kb.primary),\n              subkeys: (function() {\n                var _i, _len, _ref6, _results;\n                _ref6 = kb.subkeys;\n                _results = [];\n                for (_i = 0, _len = _ref6.length; _i < _len; _i++) {\n                  k = _ref6[_i];\n                  _results.push(KeyManager._wrap_pgp(Subkey, k));\n                }\n                return _results;\n              })(),\n              user_attributes: kb.user_attributes,\n              userids: kb.userids,\n              signed: true\n            });\n            if (bundle.has_pgp_private()) {\n              bundle.armored_pgp_private = msg.raw();\n            } else {\n              bundle.armored_pgp_public = msg.raw();\n            }\n          }\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                  funcname: \"KeyManager.import_from_pgp_message\"\n                });\n                bundle.check_pgp_validity(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 639\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, bundle, warnings, packets);\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.merge_pgp_private = function(_arg, cb) {\n      var armored, asp, b2, err, esc, raw, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      armored = _arg.armored, raw = _arg.raw, asp = _arg.asp;\n      asp = ASP.make(asp);\n      esc = make_esc(cb, \"merge_pgp_private\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.merge_pgp_private\"\n          });\n          KeyManager.import_from_armored_pgp({\n            armored: armored,\n            raw: raw,\n            asp: asp\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return b2 = arguments[0];\n              };\n            })(),\n            lineno: 650\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          err = _this.pgp.merge_private(b2.pgp);\n          (function(__iced_k) {\n            if (err != null) {\n              return __iced_k();\n            } else {\n              (function(__iced_k) {\n                if (!_this.has_pgp_private()) {\n                  return __iced_k(err = new Error(\"no private key material found after merge\"));\n                } else {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                      funcname: \"KeyManager.merge_pgp_private\"\n                    });\n                    _this.simple_unlock({}, esc(__iced_deferrals.defer({\n                      lineno: 657\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(__iced_k);\n                }\n              })(__iced_k);\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.check_pgp_public_eq = function(km2) {\n      return this.pgp.check_eq(km2.pgp);\n    };\n\n    KeyManager.prototype.unlock_pgp = function(_arg, cb) {\n      var err, passphrase, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      passphrase = _arg.passphrase;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.unlock_pgp\"\n          });\n          _this.pgp.unlock_keys({\n            passphrase: passphrase\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 670\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.is_pgp_locked = function() {\n      return this.pgp.is_locked();\n    };\n\n    KeyManager.prototype.is_keybase_locked = function() {\n      return this.keybase.is_locked();\n    };\n\n    KeyManager.prototype.has_pgp_private = function() {\n      return this.pgp.has_private();\n    };\n\n    KeyManager.prototype.has_p3skb_private = function() {\n      var _ref5;\n      return (_ref5 = this.p3skb) != null ? _ref5.has_private() : void 0;\n    };\n\n    KeyManager.prototype.has_keybase_private = function() {\n      return this.keybase.has_private();\n    };\n\n    KeyManager.prototype.is_p3skb_locked = function() {\n      var _ref5;\n      return (_ref5 = this.p3skb) != null ? _ref5.is_locked() : void 0;\n    };\n\n    KeyManager.prototype.unlock_keybase = function(_arg, cb) {\n      var asp, err, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      tsenc = _arg.tsenc, asp = _arg.asp;\n      asp = ASP.make(asp);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.unlock_keybase\"\n          });\n          _this.keybase.unlock_keys({\n            tsenc: tsenc,\n            asp: asp\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 688\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.export_private_to_server = function(_arg, cb) {\n      var asp, err, p3skb, passphrase_generation, ret, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      tsenc = _arg.tsenc, asp = _arg.asp, passphrase_generation = _arg.passphrase_generation;\n      asp = ASP.make(asp);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((err = _this._assert_signed()) == null) {\n            p3skb = _this.pgp.export_to_p3skb();\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.export_private_to_server\"\n              });\n              p3skb.lock({\n                tsenc: tsenc,\n                asp: asp,\n                passphrase_generation: passphrase_generation\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 701\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = p3skb.frame_packet_armored({\n              dohash: true\n            });\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.export_pgp_private_to_client = function(_arg, cb) {\n      var err, msg, passphrase, regen;\n      passphrase = _arg.passphrase, regen = _arg.regen;\n      err = null;\n      if (passphrase != null) {\n        passphrase = bufferify(passphrase);\n      }\n      if (regen || ((msg = this.armored_pgp_private) == null)) {\n        if ((err = this._assert_signed()) == null) {\n          this.armored_pgp_private = msg = this.pgp.export_keys({\n            \"private\": true,\n            passphrase: passphrase\n          });\n        }\n      }\n      return cb(err, msg);\n    };\n\n    KeyManager.prototype.export_pgp_private = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.export_pgp_private_to_client.apply(this, args);\n    };\n\n    KeyManager.prototype.export_pgp_public = function(_arg, cb) {\n      var err, msg, regen;\n      regen = _arg.regen;\n      err = null;\n      if (regen || ((msg = this.armored_pgp_public) == null)) {\n        if ((err = this._assert_signed()) == null) {\n          this.armored_pgp_public = msg = this.pgp.export_keys({\n            \"private\": false\n          });\n        }\n      }\n      return cb(err, msg);\n    };\n\n    KeyManager.prototype.export_public = function(_arg, cb) {\n      var asp, err, msg, regen, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      _ref5 = _arg != null ? _arg : {}, asp = _ref5.asp, regen = _ref5.regen;\n      if (cb == null) {\n        cb = null;\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.export_public\"\n          });\n          _this.export_pgp_public({\n            asp: asp,\n            regen: regen\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return msg = arguments[1];\n              };\n            })(),\n            lineno: 735\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, msg);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.export_private = function(_arg, cb) {\n      var asp, err, p3skb, passphrase, passphrase_generation, regen, res, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      passphrase = _arg.passphrase, p3skb = _arg.p3skb, asp = _arg.asp, regen = _arg.regen, passphrase_generation = _arg.passphrase_generation;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (p3skb) {\n            tsenc = new Encryptor({\n              key: bufferify(passphrase)\n            });\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.export_private\"\n              });\n              _this.export_private_to_server({\n                tsenc: tsenc,\n                asp: asp,\n                passphrase_generation: passphrase_generation\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return res = arguments[1];\n                  };\n                })(),\n                lineno: 743\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                funcname: \"KeyManager.export_private\"\n              });\n              _this.export_pgp_private_to_client({\n                passphrase: passphrase,\n                asp: asp,\n                regen: regen\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return res = arguments[1];\n                  };\n                })(),\n                lineno: 745\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, res);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.pgp_full_hash = function(opts, cb) {\n      var armored, esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"get_pgp_full_hash\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.pgp_full_hash\"\n          });\n          _this.export_pgp_public(opts, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return armored = arguments[0];\n              };\n            })(),\n            lineno: 752\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null, (new SHA256(new Buffer(armored.trim()))).toString(\"hex\"));\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.sign_pgp = function(_arg, cb) {\n      var asp, time;\n      asp = _arg.asp, time = _arg.time;\n      return this.pgp.sign({\n        asp: asp,\n        time: time\n      }, cb);\n    };\n\n    KeyManager.prototype.sign = function(_arg, cb) {\n      var asp, err, time, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, time = _arg.time;\n      asp = ASP.make(asp);\n      asp.section(\"sign\");\n      asp.progress({\n        what: \"sign PGP\",\n        total: 1,\n        i: 0\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n            funcname: \"KeyManager.sign\"\n          });\n          _this.sign_pgp({\n            asp: asp,\n            time: time\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 765\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          asp.progress({\n            what: \"sign PGP\",\n            total: 1,\n            i: 1\n          });\n          if (typeof err === \"undefined\" || err === null) {\n            _this._signed = true;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.get_userids = function() {\n      return this.userids;\n    };\n\n    KeyManager.prototype.get_userids_mark_primary = function() {\n      var do_insert, i, k, max, max_s, mymax, obj, pair, prev, primary_time, ret, s, tab, userid, _i, _len, _ref5;\n      max = null;\n      max_s = null;\n      tab = {};\n      mymax = function(a, b) {\n        if ((a == null) && (b == null)) {\n          return null;\n        } else if (a == null) {\n          return b;\n        } else if (b == null) {\n          return a;\n        } else if (a > b) {\n          return a;\n        } else {\n          return b;\n        }\n      };\n      _ref5 = this.userids;\n      for (i = _i = 0, _len = _ref5.length; _i < _len; i = ++_i) {\n        userid = _ref5[i];\n        if (!(userid != null)) {\n          continue;\n        }\n        s = userid.utf8();\n        pair = userid.time_primary_pair();\n        obj = {\n          userid: userid,\n          pair: pair,\n          i: i\n        };\n        do_insert = false;\n        if ((prev = tab[s]) != null) {\n          primary_time = mymax(prev.pair[1], pair[1]);\n          if (!(prev.pair[0] != null) || (pair[0] && prev.pair[0] < pair[0])) {\n            do_insert = true;\n          }\n        } else {\n          primary_time = pair[1];\n          do_insert = true;\n        }\n        if (do_insert) {\n          tab[s] = obj;\n        }\n        if ((primary_time != null) && ((max == null) || max < primary_time)) {\n          max_s = s;\n          max = primary_time;\n        }\n      }\n      if (max_s != null) {\n        tab[max_s].userid.primary = true;\n      }\n      ret = [];\n      for (k in tab) {\n        obj = tab[k];\n        obj.userid.most_recent_sig = obj.pair[0];\n        ret.push(obj.userid);\n      }\n      return ret;\n    };\n\n    KeyManager.prototype.fetch = function(key_ids, flags, cb) {\n      return this.pgp.fetch(key_ids, flags, cb);\n    };\n\n    KeyManager.prototype.find_pgp_key = function(key_id) {\n      return this.pgp.find_key(key_id);\n    };\n\n    KeyManager.prototype.find_pgp_key_material = function(key_id) {\n      return this.pgp.find_key_material(key_id);\n    };\n\n    KeyManager.prototype.find_best_pgp_key = function(flags, need_priv) {\n      return this.pgp.find_best_key(flags, need_priv);\n    };\n\n    KeyManager.prototype.find_signing_pgp_key = function() {\n      return this.find_best_pgp_key(C.key_flags.sign_data, true);\n    };\n\n    KeyManager.prototype.find_verifying_pgp_key = function() {\n      return this.find_best_pgp_key(C.key_flags.sign_data, false);\n    };\n\n    KeyManager.prototype.find_crypt_pgp_key = function(need_priv) {\n      if (need_priv == null) {\n        need_priv = false;\n      }\n      return this.find_best_pgp_key(C.key_flags.encrypt_comm, need_priv);\n    };\n\n    KeyManager.prototype.can_verify = function() {\n      return this.find_verifying_pgp_key() != null;\n    };\n\n    KeyManager.prototype.can_sign = function() {\n      return this.find_signing_pgp_key() != null;\n    };\n\n    KeyManager.prototype.can_encrypt = function() {\n      return this.find_crypt_pgp_key(false) != null;\n    };\n\n    KeyManager.prototype.can_decrypt = function() {\n      return this.find_crypt_pgp_key(true) != null;\n    };\n\n    KeyManager.prototype.get_primary_keypair = function() {\n      return this.primary.key;\n    };\n\n    KeyManager.prototype.get_all_pgp_key_materials = function() {\n      return this.pgp.get_all_key_materials();\n    };\n\n    KeyManager.prototype.export_pgp_keys_to_keyring = function() {\n      return this.pgp.export_keys_to_keyring(this);\n    };\n\n    KeyManager.prototype.get_pgp_key_id = function() {\n      return this.pgp.get_key_id();\n    };\n\n    KeyManager.prototype.get_pgp_short_key_id = function() {\n      return this.pgp.get_short_key_id();\n    };\n\n    KeyManager.prototype.get_pgp_fingerprint = function() {\n      return this.pgp.get_fingerprint();\n    };\n\n    KeyManager.prototype.get_pgp_fingerprint_str = function() {\n      var _ref5;\n      return (_ref5 = this.get_pgp_fingerprint()) != null ? _ref5.toString('hex') : void 0;\n    };\n\n    KeyManager.prototype.get_ekid = function() {\n      return this.pgp.get_ekid();\n    };\n\n    KeyManager.prototype.clear_pgp_internal_sigs = function() {\n      return this.pgp.clear_psc();\n    };\n\n    KeyManager.prototype.get_all_pgp_key_ids = function() {\n      return this.pgp.get_all_key_ids();\n    };\n\n    KeyManager.prototype.get_ekid_b64_str = function() {\n      var k;\n      if ((k = this.get_ekid()) != null) {\n        return base64u.encode(k);\n      } else {\n        return null;\n      }\n    };\n\n    KeyManager.prototype.get_fp2 = function() {\n      return this.get_pgp_fingerprint();\n    };\n\n    KeyManager.prototype.get_fp2_formatted = function(opts) {\n      var p;\n      if ((p = this.get_fp2()) != null) {\n        return format_pgp_fingerprint_2(p, opts);\n      } else {\n        return null;\n      }\n    };\n\n    KeyManager.prototype.get_type = function() {\n      return \"pgp\";\n    };\n\n    KeyManager.prototype.check_pgp_validity = function(cb) {\n      return this.pgp.validity_check(cb);\n    };\n\n    KeyManager.prototype.make_sig_eng = function() {\n      return new SignatureEngine({\n        km: this\n      });\n    };\n\n    KeyManager.prototype._apply_to_engines = function(_arg, cb) {\n      var args, e, err, meth, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      args = _arg.args, meth = _arg.meth;\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref5, _results, _while;\n          _ref5 = _this.engines;\n          _len = _ref5.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              e = _ref5[_i];\n              if (!err) {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/michal/kbpgp/src/openpgp/keymanager.iced\",\n                    funcname: \"KeyManager._apply_to_engines\"\n                  });\n                  meth.call(e, args, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return err = arguments[0];\n                      };\n                    })(),\n                    lineno: 902\n                  }));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              } else {\n                return _continue();\n              }\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype._assert_signed = function() {\n      if (this._signed) {\n        return null;\n      } else {\n        return new Error(\"need to sign before export\");\n      }\n    };\n\n    KeyManager._wrap_pgp = function(klass, kmp) {\n      var _ref5;\n      return new klass({\n        key: kmp.key,\n        lifespan: new Lifespan({\n          generated: kmp.timestamp,\n          expire_in: (_ref5 = kmp.get_expire_time()) != null ? _ref5.expire_in : void 0\n        }),\n        _pgp: kmp\n      });\n    };\n\n    KeyManager.prototype.merge_all_subkeys_omitting_revokes = function(km2) {\n      if ((this.pgp != null) && (km2.pgp != null)) {\n        return this.pgp.merge_all_subkeys_omitting_revokes(km2.pgp);\n      }\n    };\n\n    KeyManager.prototype.pgp_check_not_expired = function(_arg) {\n      var now, subkey_material;\n      subkey_material = _arg.subkey_material, now = _arg.now;\n      return this.pgp.check_not_expired({\n        subkey_material: subkey_material,\n        now: now\n      });\n    };\n\n    KeyManager.prototype.merge_public_omitting_revokes = function(km2) {\n      if ((this.pgp != null) && (km2.pgp != null)) {\n        return this.pgp.merge_public_omitting_revokes(km2.pgp);\n      }\n    };\n\n    KeyManager.prototype.merge_userids = function(km2) {\n      var candidate_userid, existing_userid, existing_utf8_strings, _i, _j, _len, _len1, _ref5, _ref6, _results;\n      if ((this.pgp == null) || (km2.pgp == null)) {\n        return;\n      }\n      existing_utf8_strings = {};\n      _ref5 = this.userids;\n      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n        existing_userid = _ref5[_i];\n        existing_utf8_strings[existing_userid.utf8()] = true;\n      }\n      _ref6 = km2.get_userids_mark_primary();\n      _results = [];\n      for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {\n        candidate_userid = _ref6[_j];\n        if (!(candidate_userid.utf8() in existing_utf8_strings)) {\n          _results.push(this.userids.push(candidate_userid));\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    KeyManager.prototype.merge_everything = function(km2) {\n      this.merge_public_omitting_revokes(km2);\n      return this.merge_userids(km2);\n    };\n\n    return KeyManager;\n\n  })(KeyManagerInterface);\n\n  exports.KeyManager = KeyManager;\n\n  exports.opkts = opkts;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/rsa.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, BaseKey, BaseKeyPair, BigInteger, C, K, MRF, Output, Pair, Priv, Pub, SHA512, SRF, bn, bufeq_secure, eme_pkcs1_decode, eme_pkcs1_encode, emsa_pkcs1_decode, emsa_pkcs1_encode, iced, konst, make_esc, naive_is_prime, nbi, nbits, nbv, random_prime, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3, _ref4,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  _ref = require('./primegen'), naive_is_prime = _ref.naive_is_prime, random_prime = _ref.random_prime;\n\n  bn = require('./bn');\n\n  nbits = bn.nbits, nbv = bn.nbv, nbi = bn.nbi, BigInteger = bn.BigInteger;\n\n  _ref1 = require('./util'), bufeq_secure = _ref1.bufeq_secure, ASP = _ref1.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  SHA512 = require('./hash').SHA512;\n\n  _ref2 = require('./pad'), eme_pkcs1_encode = _ref2.eme_pkcs1_encode, eme_pkcs1_decode = _ref2.eme_pkcs1_decode, emsa_pkcs1_decode = _ref2.emsa_pkcs1_decode, emsa_pkcs1_encode = _ref2.emsa_pkcs1_encode;\n\n  _ref3 = require('./rand'), SRF = _ref3.SRF, MRF = _ref3.MRF;\n\n  _ref4 = require('./basekeypair'), BaseKey = _ref4.BaseKey, BaseKeyPair = _ref4.BaseKeyPair;\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    function Priv(_arg) {\n      this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg.pub;\n    }\n\n    Priv.prototype.decrypt = function(c, cb) {\n      var x, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Priv.decrypt\"\n          });\n          _this.mod_pow_d_crt(c, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return x = arguments[0];\n              };\n            })(),\n            lineno: 22\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null, x);\n        };\n      })(this));\n    };\n\n    Priv.prototype.sign = function(m, cb) {\n      return this.mod_pow_d_crt(m, cb);\n    };\n\n    Priv.ORDER = ['d', 'p', 'q', 'u'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    Priv.prototype.n = function() {\n      return this.p.multiply(this.q);\n    };\n\n    Priv.prototype.phi = function() {\n      return this.p.subtract(BigInteger.ONE).multiply(this.q.subtract(BigInteger.ONE));\n    };\n\n    Priv.prototype.lambda = function() {\n      return this.phi.divide(this.p.subtract(BigInteger.ONE).gcd(this.q.subtract(BigInteger.ONE)));\n    };\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.mod_pow_d_crt = function(x, cb) {\n      var n, r, r_e, r_inv, x_1, xp, xq, y, y_0, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      if (this.dP == null) {\n        this.dP = this.d.mod(this.p.subtract(BigInteger.ONE));\n      }\n      if (this.dQ == null) {\n        this.dQ = this.d.mod(this.q.subtract(BigInteger.ONE));\n      }\n      if (this.qInv == null) {\n        this.qInv = this.q.modInverse(this.p);\n      }\n\n      /* Chinese remainder theorem (CRT) states:\n      \n        Suppose n1, n2, ..., nk are positive integers which are pairwise\n        coprime (n1 and n2 have no common factors other than 1). For any\n        integers x1, x2, ..., xk there exists an integer x solving the\n        system of simultaneous congruences (where ~= means modularly\n        congruent so a ~= b mod n means a mod n = b mod n):\n      \n        x ~= x1 mod n1\n        x ~= x2 mod n2\n        ...\n        x ~= xk mod nk\n      \n        This system of congruences has a single simultaneous solution x\n        between 0 and n - 1. Furthermore, each xk solution and x itself\n        is congruent modulo the product n = n1*n2*...*nk.\n        So x1 mod n = x2 mod n = xk mod n = x mod n.\n      \n        The single simultaneous solution x can be solved with the following\n        equation:\n      \n        x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.\n      \n        Where x is less than n, xi = x mod ni.\n      \n        For RSA we are only concerned with k = 2. The modulus n = pq, where\n        p and q are coprime. The RSA decryption algorithm is:\n      \n        y = x^d mod n\n      \n        Given the above:\n      \n        x1 = x^d mod p\n        r1 = n/p = q\n        s1 = q^-1 mod p\n        x2 = x^d mod q\n        r2 = n/q = p\n        s2 = p^-1 mod q\n      \n        So y = (x1r1s1 + x2r2s2) mod n\n             = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n\n      \n        According to Fermat's Little Theorem, if the modulus P is prime,\n        for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.\n        Since A is not divisible by P it follows that if:\n        N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:\n      \n        A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort\n        to calculate). In order to calculate x^d mod p more quickly the\n        exponent d mod (p - 1) is stored in the RSA private key (the same\n        is done for x^d mod q). These values are referred to as dP and dQ\n        respectively. Therefore we now have:\n      \n        y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n\n      \n        Since we'll be reducing x^dP by modulo p (same for q) we can also\n        reduce x by p (and q respectively) before hand. Therefore, let\n      \n        xp = ((x mod p)^dP mod p), and\n        xq = ((x mod q)^dQ mod q), yielding:\n      \n        y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n\n      \n        This can be further reduced to a simple algorithm that only\n        requires 1 inverse (the q inverse is used) to be used and stored.\n        The algorithm is called Garner's algorithm. If qInv is the\n        inverse of q, we simply calculate:\n      \n        y = (qInv*(xp - xq) mod p) * q + xq\n      \n        However, there are two further complications. First, we need to\n        ensure that xp > xq to prevent signed BigIntegers from being used\n        so we add p until this is true (since we will be mod'ing with\n        p anyway). Then, there is a known timing attack on algorithms\n        using the CRT. To mitigate this risk, \"cryptographic blinding\"\n        should be used (*Not yet implemented*). This requires simply\n        generating a random number r between 0 and n-1 and its inverse\n        and multiplying x by r^e before calculating y and then multiplying\n        y by r^-1 afterwards.\n       */\n      n = this.pub.n;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Priv.mod_pow_d_crt\"\n          });\n          SRF().random_zn(n, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return r = arguments[0];\n              };\n            })(),\n            lineno: 141\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          r_inv = r.modInverse(n);\n          r_e = r.modPow(_this.pub.e, n);\n          x_1 = x.multiply(r_e).mod(n);\n          xp = x_1.mod(_this.p).modPow(_this.dP, _this.p);\n          xq = x_1.mod(_this.q).modPow(_this.dQ, _this.q);\n          while (xp.compareTo(xq) < 0) {\n            xp = xp.add(_this.p);\n          }\n          y_0 = xp.subtract(xq).multiply(_this.qInv).mod(_this.p).multiply(_this.q).add(xq);\n          y = y_0.multiply(r_inv).mod(n);\n          return cb(y);\n        };\n      })(this));\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.RSA;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.ORDER = ['n', 'e'];\n\n    Pub.prototype.ORDER = Pub.ORDER;\n\n    function Pub(_arg) {\n      this.n = _arg.n, this.e = _arg.e;\n    }\n\n    Pub.prototype.encrypt = function(p, cb) {\n      return this.mod_pow(p, this.e, cb);\n    };\n\n    Pub.prototype.verify = function(s, cb) {\n      return this.mod_pow(s, this.e, cb);\n    };\n\n    Pub.prototype.nbits = function() {\n      var _ref5;\n      return (_ref5 = this.n) != null ? _ref5.bitLength() : void 0;\n    };\n\n    Pub.alloc = function(raw) {\n      return BaseKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.mod_pow = function(x, d, cb) {\n      return cb(x.modPow(d, this.n));\n    };\n\n    Pub.prototype.validity_check = function(cb) {\n      var err;\n      err = !this.n.gcd(this.e).equals(BigInteger.ONE) ? new Error(\"gcd(n,e) != 1\") : !this.n.mod(nbv(2)).equals(BigInteger.ONE) ? new Error(\"n % 2 != 1\") : this.e.compareTo(BigInteger.ONE) <= 0 ? new Error(\"e <= 1\") : this.e.bitLength() > 32 ? new Error(\"e=\" + this.e + \" > 2^32\") : null;\n      return cb(err);\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.type = C.public_key_algorithms.RSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.klass_name = 'RSA';\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    function Pair(_arg) {\n      var priv, pub;\n      priv = _arg.priv, pub = _arg.pub;\n      Pair.__super__.constructor.call(this, {\n        priv: priv,\n        pub: pub\n      });\n    }\n\n    Pair.parse = function(pub_raw) {\n      return BaseKeyPair.parse(Pair, pub_raw);\n    };\n\n    Pair.alloc = function(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      return BaseKeyPair.alloc({\n        pub: pub,\n        priv: priv\n      });\n    };\n\n    Pair.subkey_algo = function(flags) {\n      return Pair;\n    };\n\n    Pair.prototype.sanity_check = function(cb) {\n      var err, x0, x1, x2, y0, y1, y2, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = this.priv.n().compareTo(this.pub.n) === 0 ? null : new Error(\"pq != n\");\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            x0 = MRF().random_zn(_this.pub.n);\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                funcname: \"Pair.sanity_check\"\n              });\n              _this.encrypt(x0, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return x1 = arguments[0];\n                  };\n                })(),\n                lineno: 240\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                  funcname: \"Pair.sanity_check\"\n                });\n                _this.decrypt(x1, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return x2 = arguments[1];\n                    };\n                  })(),\n                  lineno: 241\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return __iced_k((err == null) && x0.compareTo(x2) !== 0 ? err = new Error(\"Decrypt/encrypt failed\") : void 0);\n              });\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              y0 = MRF().random_zn(_this.pub.n);\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                  funcname: \"Pair.sanity_check\"\n                });\n                _this.sign(y0, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return y1 = arguments[0];\n                    };\n                  })(),\n                  lineno: 246\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                    funcname: \"Pair.sanity_check\"\n                  });\n                  _this.verify(y1, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return y2 = arguments[0];\n                      };\n                    })(),\n                    lineno: 247\n                  }));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return __iced_k(y0.compareTo(y2) !== 0 ? err = new Error(\"Sign/verify failed\") : void 0);\n                });\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Pair.parse_sig = function(slice) {\n      var err, n, raw, ret, _ref5;\n      _ref5 = bn.mpi_from_buffer(slice.peek_rest_to_buffer()), err = _ref5[0], ret = _ref5[1], raw = _ref5[2], n = _ref5[3];\n      if (err != null) {\n        throw err;\n      }\n      slice.advance(n);\n      return ret;\n    };\n\n    Pair.prototype.encrypt = function(p, cb) {\n      return this.pub.encrypt(p, cb);\n    };\n\n    Pair.prototype.decrypt = function(c, cb) {\n      return this.priv.decrypt(c, cb);\n    };\n\n    Pair.prototype.max_value = function() {\n      return this.pub.n;\n    };\n\n    Pair.make = function(_arg) {\n      var d, dmp1, dmq1, e, lambda, n, p, p1, phi, priv, pub, q, q1, u;\n      p = _arg.p, q = _arg.q, e = _arg.e, phi = _arg.phi, p1 = _arg.p1, q1 = _arg.q1, lambda = _arg.lambda;\n      n = p.multiply(q);\n      d = e.modInverse(lambda);\n      dmp1 = d.mod(p1);\n      dmq1 = d.mod(q1);\n      u = p.modInverse(q);\n      pub = new Pub({\n        n: n,\n        e: e\n      });\n      priv = new Priv({\n        p: p,\n        q: q,\n        d: d,\n        dmp1: dmp1,\n        dmq1: dmq1,\n        u: u,\n        pub: pub\n      });\n      return new Pair({\n        priv: priv,\n        pub: pub\n      });\n    };\n\n    Pair.prototype.to_openpgp = function() {\n      var key;\n      key = new (new RSA).keyObject();\n      key.n = this.pub.n;\n      key.e = this.pub.e.intValue();\n      key.ee = this.pub.e;\n      key.d = this.priv.d;\n      key.p = this.priv.p;\n      key.q = this.priv.q;\n      key.dmp1 = this.priv.dmp1;\n      key.dmq1 = this.priv.dmq1;\n      key.u = this.priv.u;\n      return key;\n    };\n\n    Pair.prototype.sign = function(m, cb) {\n      return this.priv.sign(m, cb);\n    };\n\n    Pair.prototype.verify = function(s, cb) {\n      return this.pub.verify(s, cb);\n    };\n\n    Pair.prototype.pad_and_encrypt = function(data, params, cb) {\n      var ct, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Pair.pad_and_encrypt\"\n          });\n          eme_pkcs1_encode(data, _this.pub.n.mpi_byte_length(), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return m = arguments[1];\n              };\n            })(),\n            lineno: 306\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                  funcname: \"Pair.pad_and_encrypt\"\n                });\n                _this.encrypt(m, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return ct = arguments[0];\n                    };\n                  })(),\n                  lineno: 308\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return __iced_k(ret = _this.export_output({\n                  y_mpi: ct\n                }));\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, ret);\n          });\n        };\n      })(this));\n    };\n\n    Pair.prototype.decrypt_and_unpad = function(ciphertext, params, cb) {\n      var b, err, p, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Pair.decrypt_and_unpad\"\n          });\n          _this.decrypt(ciphertext.y(), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return p = arguments[1];\n              };\n            })(),\n            lineno: 318\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref5;\n          if (err == null) {\n            b = p.to_padded_octets(_this.pub.n);\n            _ref5 = eme_pkcs1_decode(b), err = _ref5[0], ret = _ref5[1];\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var hashed_data, hasher, m, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hasher = _arg.hasher;\n      hasher || (hasher = SHA512);\n      hashed_data = hasher(data);\n      m = emsa_pkcs1_encode(hashed_data, this.pub.n.mpi_byte_length(), {\n        hasher: hasher\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Pair.pad_and_sign\"\n          });\n          _this.sign(m, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 330\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null, sig.to_mpi_buffer());\n        };\n      })(this));\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var b, data, err, hash, hasher, hd1, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref5;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      err = null;\n      if (Buffer.isBuffer(sig)) {\n        _ref5 = bn.mpi_from_buffer(sig), err = _ref5[0], sig = _ref5[1];\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                funcname: \"Pair.verify_unpad_and_check_hash\"\n              });\n              _this.verify(sig, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return v = arguments[0];\n                  };\n                })(),\n                lineno: 339\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              var _ref6;\n              b = v.to_padded_octets(_this.pub.n);\n              _ref6 = emsa_pkcs1_decode(b, hasher), err = _ref6[0], hd1 = _ref6[1];\n              return __iced_k(err == null ? (hash || (hash = hasher(data)), !bufeq_secure(hd1, hash) ? err = new Error(\"hash mismatch\") : void 0) : void 0);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var asp, e, e_orig, esc, go, iters, key, lambda, nbits, p, p1, phi, q, q1, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      nbits = _arg.nbits, iters = _arg.iters, e = _arg.e, asp = _arg.asp;\n      e || (e = (1 << 16) + 1);\n      e_orig = e;\n      nbits || (nbits = 4096);\n      iters || (iters = 10);\n      asp || (asp = new ASP({}));\n      e = nbv(e_orig);\n      esc = make_esc(cb, \"generate_rsa_keypair\");\n      go = true;\n      nbits >>= 1;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _while;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!go) {\n              return _break();\n            } else {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                  funcname: \"Pair.generate\"\n                });\n                random_prime({\n                  asp: asp.section('p'),\n                  e: e,\n                  nbits: nbits,\n                  iters: iters\n                }, esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return p = arguments[0];\n                    };\n                  })(),\n                  lineno: 363\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                    funcname: \"Pair.generate\"\n                  });\n                  asp.progress({\n                    what: \"found\",\n                    p: p\n                  }, esc(__iced_deferrals.defer({\n                    lineno: 364\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                      funcname: \"Pair.generate\"\n                    });\n                    random_prime({\n                      asp: asp.section('q'),\n                      e: e,\n                      nbits: nbits,\n                      iters: iters\n                    }, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return q = arguments[0];\n                        };\n                      })(),\n                      lineno: 365\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n                        funcname: \"Pair.generate\"\n                      });\n                      asp.progress({\n                        what: \"found\",\n                        q: q\n                      }, esc(__iced_deferrals.defer({\n                        lineno: 366\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      var _ref5;\n                      if (p.compareTo(q) <= 0) {\n                        _ref5 = [q, p], p = _ref5[0], q = _ref5[1];\n                      }\n                      q1 = q.subtract(BigInteger.ONE);\n                      p1 = p.subtract(BigInteger.ONE);\n                      phi = p1.multiply(q1);\n                      lambda = phi.divide(q1.gcd(p1));\n                      return _next(phi.gcd(e).compareTo(BigInteger.ONE) !== 0 ? (typeof progress_hook === \"function\" ? progress_hook({\n                        what: \"unlucky_phi\"\n                      }) : void 0, go = true) : go = false);\n                    });\n                  });\n                });\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          key = Pair.make({\n            p: p,\n            q: q,\n            e: e,\n            phi: phi,\n            p1: p1,\n            q1: q1,\n            lambda: lambda\n          });\n          return cb(null, key);\n        };\n      })(this));\n    };\n\n    Pair.parse_output = function(buf) {\n      return Output.parse(buf);\n    };\n\n    Pair.prototype.export_output = function(args) {\n      return new Output(args);\n    };\n\n    Pair.prototype.validity_check = function(cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Pair.validity_check\"\n          });\n          _this.pub.validity_check(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 391\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  Output = (function() {\n    function Output(_arg) {\n      this.y_mpi = _arg.y_mpi, this.y_buf = _arg.y_buf;\n    }\n\n    Output.parse = function(buf) {\n      var err, n, raw, ret, _ref5;\n      _ref5 = bn.mpi_from_buffer(buf), err = _ref5[0], ret = _ref5[1], raw = _ref5[2], n = _ref5[3];\n      if (err != null) {\n        throw err;\n      }\n      if (raw.length !== 0) {\n        throw new Error(\"junk at the end of input\");\n      }\n      return new Output({\n        y_mpi: ret\n      });\n    };\n\n    Output.prototype.y = function() {\n      return this.y_mpi;\n    };\n\n    Output.prototype.hide = function(_arg, cb) {\n      var err, i, key, max, slosh, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, max = _arg.max, slosh = _arg.slosh;\n      max || (max = 8192);\n      slosh || (slosh = 128);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rsa.iced\",\n            funcname: \"Output.hide\"\n          });\n          key.hide({\n            i: _this.y(),\n            max: max,\n            slosh: slosh\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return i = arguments[1];\n              };\n            })(),\n            lineno: 417\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            _this.y_mpi = i;\n            _this.y_buf = null;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Output.prototype.find = function(_arg) {\n      var key;\n      key = _arg.key;\n      return this.y_mpi = key.find(this.y_mpi);\n    };\n\n    Output.prototype.output = function() {\n      return this.y_buf || this.y_mpi.to_mpi_buffer();\n    };\n\n    return Output;\n\n  })();\n\n  exports.RSA = exports.Pair = Pair;\n\n  exports.Output = Output;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/primegen.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, Avg, BigInteger, MRF, PrimeFinder, SRF, Timer, fermat2_test, fta, iced, make_esc, miller_rabin, naive_is_prime, native_rng, nbi, nbs, nbv, prime_search, prng, quickmod, random_prime, small_primes, _MR_inner, _MR_small_check, __iced_k, __iced_k_noop, _ref, _ref1;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger;\n\n  prng = require('triplesec').prng;\n\n  native_rng = prng.native_rng;\n\n  small_primes = require('./primes').small_primes;\n\n  make_esc = require('iced-error').make_esc;\n\n  ASP = require('./util').ASP;\n\n  nbs = require('./bn').nbs;\n\n  _ref1 = require('./rand'), MRF = _ref1.MRF, SRF = _ref1.SRF;\n\n  Timer = (function() {\n    function Timer() {\n      this.start = Date.now();\n    }\n\n    Timer.prototype.stop = function() {\n      return Date.now() - this.start;\n    };\n\n    return Timer;\n\n  })();\n\n  Avg = (function() {\n    function Avg() {\n      this.tot = 0;\n      this.n = 0;\n    }\n\n    Avg.prototype.start = function() {\n      return this._t = Date.now();\n    };\n\n    Avg.prototype.stop = function() {\n      var s;\n      s = Date.now() - this._t;\n      console.log(\"ran in \" + s);\n      this.tot += s;\n      return this.n++;\n    };\n\n    Avg.prototype.avg = function() {\n      return this.tot / this.n;\n    };\n\n    return Avg;\n\n  })();\n\n  quickmod = function(p, d) {\n    return p.modInt(d);\n  };\n\n  fta = new Avg();\n\n  fermat2_test = function(n) {\n    var Bl, bl, i, ret, t, _i;\n    t = nbv(1);\n    bl = n.bitLength();\n    bl--;\n    Bl = n.byteLength();\n    for (i = _i = bl; bl <= 0 ? _i <= 0 : _i >= 0; i = bl <= 0 ? ++_i : --_i) {\n      t = t.square();\n      if (t.byteLength() > Bl) {\n        t = t.mod(n);\n      }\n      if (n.testBit(i)) {\n        t = t.shiftLeft(1);\n      }\n    }\n    if (t.compareTo(n) > 0) {\n      t = t.mod(n);\n    }\n    ret = t.compareTo(nbv(2)) === 0;\n    return ret;\n  };\n\n  _MR_inner = function(_arg) {\n    var a, j, p, p1, r, s, y, _i, _ref2;\n    s = _arg.s, r = _arg.r, p = _arg.p, p1 = _arg.p1;\n    a = MRF().random_zn(p);\n    y = a.modPow(r, p);\n    if (y.compareTo(BigInteger.ONE) !== 0) {\n      for (j = _i = _ref2 = s - 1; _ref2 <= 0 ? _i <= 0 : _i >= 0; j = _ref2 <= 0 ? ++_i : --_i) {\n        if (!(y.compareTo(p1) !== 0)) {\n          continue;\n        }\n        if (j === 0) {\n          return false;\n        }\n        y = y.square().mod(p);\n        if (y.compareTo(BigInteger.ONE) === 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  _MR_small_check = function(_arg) {\n    var p, _ref2;\n    p = _arg.p;\n    if (p.compareTo(BigInteger.ZERO) <= 0) {\n      return false;\n    } else if (p.compareTo(nbv(7)) <= 0) {\n      return (_ref2 = p.intValue()) === 2 || _ref2 === 3 || _ref2 === 5 || _ref2 === 7;\n    } else if (!p.testBit(0)) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  miller_rabin = function(_arg, cb) {\n    var asp, esc, i, iter, p, p1, r, ret, s, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    p = _arg.p, iter = _arg.iter, asp = _arg.asp;\n    asp || (asp = new ASP({}));\n    iter || (iter = 10);\n    esc = make_esc(cb, \"miller_rabin\");\n    ret = _MR_small_check({\n      p: p\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        if (ret) {\n          p1 = p.subtract(BigInteger.ONE);\n          s = p1.getLowestSetBit();\n          r = p1.shiftRight(s);\n          ret = true;\n          (function(__iced_k) {\n            var _begin, _end, _i, _positive, _results, _step, _while;\n            i = 0;\n            _begin = 0;\n            _end = iter;\n            if (_end > _begin) {\n              _step = 1;\n            } else {\n              _step = -1;\n            }\n            _positive = _end > _begin;\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = __iced_k;\n              _continue = function() {\n                return iced.trampoline(function() {\n                  i += _step;\n                  return _while(__iced_k);\n                });\n              };\n              _next = _continue;\n              if (!!((_positive === true && i >= iter) || (_positive === false && i <= iter))) {\n                return _break();\n              } else {\n\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n                  });\n                  asp.progress({\n                    what: \"mr\",\n                    i: i,\n                    total: iter,\n                    p: p\n                  }, esc(__iced_deferrals.defer({\n                    lineno: 122\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    if (!_MR_inner({\n                      s: s,\n                      r: r,\n                      p: p,\n                      p1: p1\n                    })) {\n                      ret = false;\n                      (function(__iced_k) {\n_break()\n                      })(__iced_k);\n                    } else {\n                      return __iced_k();\n                    }\n                  })(_next);\n                });\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n              });\n              asp.progress({\n                what: \"mr\",\n                i: iter,\n                total: iter,\n                p: p\n              }, esc(__iced_deferrals.defer({\n                lineno: 127\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          });\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(null, ret);\n      };\n    })(this));\n  };\n\n  PrimeFinder = (function() {\n    function PrimeFinder(p, sieve) {\n      this.p = p;\n      this.sieve = sieve;\n      this.inc = 0;\n      this.maxinc = -1;\n      this.sievepos = quickmod(this.p, this.sieve.length);\n      this.calcmods();\n    }\n\n    PrimeFinder.prototype.getp = function() {\n      return this.p;\n    };\n\n    PrimeFinder.prototype.setmax = function(i) {\n      if (this.maxinc !== -1) {\n        throw new Error(\"can only setmax() once\");\n      }\n      return this.maxinc = i;\n    };\n\n    PrimeFinder.prototype.calcmods = function() {\n      var sp;\n      this.p = this.p.add(nbv(this.inc));\n      if (this.maxinc !== -1) {\n        this.maxinc -= this.inc;\n      }\n      this.inc = 0;\n      return this.mods = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = small_primes.length; _i < _len; _i++) {\n          sp = small_primes[_i];\n          _results.push(quickmod(this.p, sp));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    PrimeFinder.prototype.decrement_mods_find_divisor = function() {\n      var i, sp, _i, _len;\n      for (i = _i = 0, _len = small_primes.length; _i < _len; i = ++_i) {\n        sp = small_primes[i];\n        while (this.mods[i] + this.inc >= sp) {\n          this.mods[i] -= sp;\n          if ((this.mods[i] + this.inc) === 0) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    PrimeFinder.prototype.next_weak = function() {\n      var step;\n      while (true) {\n        step = this.sieve[this.sievepos];\n        this.sievepos = (this.sievepos + step) % this.sieve.length;\n        this.inc += step;\n        if (this.inc > this.maxinc && this.maxinc > 0) {\n          this.tmp = nbv(0);\n          return this.tmp;\n        }\n        if (this.inc < 0) {\n          this.calcmods();\n        }\n        if (!this.decrement_mods_find_divisor()) {\n          this.tmp = this.p.add(nbv(this.inc));\n          return this.tmp;\n        }\n      }\n    };\n\n    PrimeFinder.prototype.next_fermat = function() {\n      while (true) {\n        this.next_weak();\n        if (!this.tmp || fermat2_test(this.tmp)) {\n          return this.tmp;\n        }\n      }\n    };\n\n    PrimeFinder.prototype.next_strong = function(iter) {\n      if (iter == null) {\n        iter = 32;\n      }\n      while (true) {\n        this.next_weak();\n        if (!this.tmp || (fermat2_test(this.tmp) && probab_prime(this.tmp, iter))) {\n          return this.tmp;\n        }\n      }\n    };\n\n    return PrimeFinder;\n\n  })();\n\n  prime_search = function(_arg, cb) {\n    var asp, esc, i, is_prime, iters, p, pf, pp, pvec, range, ret, sieve, start, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    start = _arg.start, range = _arg.range, sieve = _arg.sieve, asp = _arg.asp, iters = _arg.iters;\n    iters || (iters = 20);\n    pf = new PrimeFinder(start, sieve);\n    pf.setmax(range);\n    pvec = ((function() {\n      var _results;\n      _results = [];\n      while ((pp = pf.next_weak()).compareTo(BigInteger.ZERO) > 0) {\n        _results.push(pp);\n      }\n      return _results;\n    })());\n    esc = make_esc(cb, \"prime_search\");\n    ret = null;\n    (function(_this) {\n      return (function(__iced_k) {\n        var _while;\n        _while = function(__iced_k) {\n          var _break, _continue, _next;\n          _break = __iced_k;\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = _continue;\n          if (!(pvec.length && (ret == null))) {\n            return _break();\n          } else {\n            i = MRF().random_word() % pvec.length;\n            p = pvec[i];\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n              });\n              asp.progress({\n                what: \"fermat\",\n                p: p\n              }, esc(__iced_deferrals.defer({\n                lineno: 226\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                if (!fermat2_test(p)) {\n                  return __iced_k();\n                } else {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n                    });\n                    miller_rabin({\n                      p: p,\n                      iters: iters,\n                      asp: asp\n                    }, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return is_prime = arguments[0];\n                        };\n                      })(),\n                      lineno: 229\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n                      });\n                      asp.progress({\n                        what: \"passed_mr\",\n                        p: p\n                      }, esc(__iced_deferrals.defer({\n                        lineno: 230\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      return __iced_k(is_prime ? ret = p : asp.progress({\n                        what: \"failed_mr\",\n                        p: p\n                      }));\n                    });\n                  });\n                }\n              })(function() {\n                tmp = pvec.pop();\n                return _next(i < pvec.length ? pvec[i] = tmp : void 0);\n              });\n            });\n          }\n        };\n        _while(__iced_k);\n      });\n    })(this)((function(_this) {\n      return function() {\n        if (ret == null) {\n          ret = nbv(0);\n        }\n        return cb(null, ret);\n      };\n    })(this));\n  };\n\n  random_prime = function(_arg, cb) {\n    var asp, e, esc, go, iters, nbits, p, range, sieve, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    nbits = _arg.nbits, iters = _arg.iters, asp = _arg.asp, e = _arg.e;\n    sieve = [1, 2];\n    go = true;\n    esc = make_esc(cb, \"random_prime\");\n    range = nbits;\n    p = null;\n    (function(_this) {\n      return (function(__iced_k) {\n        var _while;\n        _while = function(__iced_k) {\n          var _break, _continue, _next;\n          _break = __iced_k;\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = _continue;\n          if (!go) {\n            return _break();\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n              });\n              SRF().random_nbit(nbits, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return p = arguments[0];\n                  };\n                })(),\n                lineno: 262\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              p = p.setBit(0).setBit(nbits - 1).setBit(nbits - 2);\n              (function(__iced_k) {\n                if ((e == null) || p.subtract(BigInteger.ONE).gcd(e).compareTo(BigInteger.ONE) === 0) {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n                    });\n                    asp.progress({\n                      what: \"guess\",\n                      p: p\n                    }, esc(__iced_deferrals.defer({\n                      lineno: 265\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n                      });\n                      prime_search({\n                        start: p,\n                        range: range,\n                        sieve: sieve,\n                        asp: asp,\n                        iters: iters\n                      }, esc(__iced_deferrals.defer({\n                        assign_fn: (function() {\n                          return function() {\n                            return p = arguments[0];\n                          };\n                        })(),\n                        lineno: 266\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      return __iced_k(go = (p == null) || (p.compareTo(BigInteger.ZERO) === 0));\n                    });\n                  });\n                } else {\n                  return __iced_k();\n                }\n              })(_next);\n            });\n          }\n        };\n        _while(__iced_k);\n      });\n    })(this)((function(_this) {\n      return function() {\n        (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/primegen.iced\"\n          });\n          asp.progress({\n            what: \"found\",\n            p: p\n          }, esc(__iced_deferrals.defer({\n            lineno: 269\n          })));\n          __iced_deferrals._fulfill();\n        })(function() {\n          return cb(null, p);\n        });\n      };\n    })(this));\n  };\n\n  exports.naive_is_prime = naive_is_prime = function(n) {\n    var biggest, p, _i, _len;\n    biggest = Math.floor(Math.sqrt(n));\n    for (_i = 0, _len = small_primes.length; _i < _len; _i++) {\n      p = small_primes[_i];\n      if (p > biggest) {\n        return true;\n      }\n      if ((n % p) === 0) {\n        return false;\n      }\n    }\n    return false;\n  };\n\n  exports.fermat2_test = fermat2_test;\n\n  exports.nbs = nbs;\n\n  exports.small_primes = small_primes;\n\n  exports.miller_rabin = miller_rabin;\n\n  exports.random_prime = random_prime;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/primes.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  exports.small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859, 10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957, 10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399, 11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 11549, 11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731, 11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113, 12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251, 12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527, 12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217, 13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337, 13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681, 13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083, 14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221, 14243, 14249, 14251, 14281, 14293, 14303, 14321, 14323, 14327, 14341, 14347, 14369, 14387, 14389, 14401, 14407, 14411, 14419, 14423, 14431, 14437, 14447, 14449, 14461, 14479, 14489, 14503, 14519, 14533, 14537, 14543, 14549, 14551, 14557, 14561, 14563, 14591, 14593, 14621, 14627, 14629, 14633, 14639, 14653, 14657, 14669, 14683, 14699, 14713, 14717, 14723, 14731, 14737, 14741, 14747, 14753, 14759, 14767, 14771, 14779, 14783, 14797, 14813, 14821, 14827, 14831, 14843, 14851, 14867, 14869, 14879, 14887, 14891, 14897, 14923, 14929, 14939, 14947, 14951, 14957, 14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073, 15077, 15083, 15091, 15101, 15107, 15121, 15131, 15137, 15139, 15149, 15161, 15173, 15187, 15193, 15199, 15217, 15227, 15233, 15241, 15259, 15263, 15269, 15271, 15277, 15287, 15289, 15299, 15307, 15313, 15319, 15329, 15331, 15349, 15359, 15361, 15373, 15377, 15383, 15391, 15401, 15413, 15427, 15439, 15443, 15451, 15461, 15467, 15473, 15493, 15497, 15511, 15527, 15541, 15551, 15559, 15569, 15581, 15583, 15601, 15607, 15619, 15629, 15641, 15643, 15647, 15649, 15661, 15667, 15671, 15679, 15683, 15727, 15731, 15733, 15737, 15739, 15749, 15761, 15767, 15773, 15787, 15791, 15797, 15803, 15809, 15817, 15823, 15859, 15877, 15881, 15887, 15889, 15901, 15907, 15913, 15919, 15923, 15937, 15959, 15971, 15973, 15991, 16001, 16007, 16033, 16057, 16061, 16063, 16067, 16069, 16073, 16087, 16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183, 16187, 16189, 16193, 16217, 16223, 16229, 16231, 16249, 16253, 16267, 16273, 16301, 16319, 16333, 16339, 16349, 16361, 16363, 16369, 16381, 16411, 16417, 16421, 16427, 16433, 16447, 16451, 16453, 16477, 16481, 16487, 16493, 16519, 16529, 16547, 16553, 16561, 16567, 16573, 16603, 16607, 16619, 16631, 16633, 16649, 16651, 16657, 16661, 16673, 16691, 16693, 16699, 16703, 16729, 16741, 16747, 16759, 16763, 16787, 16811, 16823, 16829, 16831, 16843, 16871, 16879, 16883, 16889, 16901, 16903, 16921, 16927, 16931, 16937, 16943, 16963, 16979, 16981, 16987, 16993, 17011, 17021, 17027, 17029, 17033, 17041, 17047, 17053, 17077, 17093, 17099, 17107, 17117, 17123, 17137, 17159, 17167, 17183, 17189, 17191, 17203, 17207, 17209, 17231, 17239, 17257, 17291, 17293, 17299, 17317, 17321, 17327, 17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389, 17393, 17401, 17417, 17419, 17431, 17443, 17449, 17467, 17471, 17477, 17483, 17489, 17491, 17497, 17509, 17519, 17539, 17551, 17569, 17573, 17579, 17581, 17597, 17599, 17609, 17623, 17627, 17657, 17659, 17669, 17681, 17683, 17707, 17713, 17729, 17737, 17747, 17749, 17761, 17783, 17789, 17791, 17807, 17827, 17837, 17839, 17851, 17863, 17881, 17891, 17903, 17909, 17911, 17921, 17923, 17929, 17939, 17957, 17959, 17971, 17977, 17981, 17987, 17989, 18013, 18041, 18043, 18047, 18049, 18059, 18061, 18077, 18089, 18097, 18119, 18121, 18127, 18131, 18133, 18143, 18149, 18169, 18181, 18191, 18199, 18211, 18217, 18223, 18229, 18233, 18251, 18253, 18257, 18269, 18287, 18289, 18301, 18307, 18311, 18313, 18329, 18341, 18353, 18367, 18371, 18379, 18397, 18401, 18413, 18427, 18433, 18439, 18443, 18451, 18457, 18461, 18481, 18493, 18503, 18517, 18521, 18523, 18539, 18541, 18553, 18583, 18587, 18593, 18617, 18637, 18661, 18671, 18679, 18691, 18701, 18713, 18719, 18731, 18743, 18749, 18757, 18773, 18787, 18793, 18797, 18803, 18839, 18859, 18869, 18899, 18911, 18913, 18917, 18919, 18947, 18959, 18973, 18979, 19001, 19009, 19013, 19031, 19037, 19051, 19069, 19073, 19079, 19081, 19087, 19121, 19139, 19141, 19157, 19163, 19181, 19183, 19207, 19211, 19213, 19219, 19231, 19237, 19249, 19259, 19267, 19273, 19289, 19301, 19309, 19319, 19333, 19373, 19379, 19381, 19387, 19391, 19403, 19417, 19421, 19423, 19427, 19429, 19433, 19441, 19447, 19457, 19463, 19469, 19471, 19477, 19483, 19489, 19501, 19507, 19531, 19541, 19543, 19553, 19559, 19571, 19577, 19583, 19597, 19603, 19609, 19661, 19681, 19687, 19697, 19699, 19709, 19717, 19727, 19739, 19751, 19753, 19759, 19763, 19777, 19793, 19801, 19813, 19819, 19841, 19843, 19853, 19861, 19867, 19889, 19891, 19913, 19919, 19927, 19937, 19949, 19961, 19963, 19973, 19979, 19991, 19993, 19997, 20011, 20021, 20023, 20029, 20047, 20051, 20063, 20071, 20089, 20101, 20107, 20113, 20117, 20123, 20129, 20143, 20147, 20149, 20161, 20173, 20177, 20183, 20201, 20219, 20231, 20233, 20249, 20261, 20269, 20287, 20297, 20323, 20327, 20333, 20341, 20347, 20353, 20357, 20359, 20369, 20389, 20393, 20399, 20407, 20411, 20431, 20441, 20443, 20477, 20479, 20483, 20507, 20509, 20521, 20533, 20543, 20549, 20551, 20563, 20593, 20599, 20611, 20627, 20639, 20641, 20663, 20681, 20693, 20707, 20717, 20719, 20731, 20743, 20747, 20749, 20753, 20759, 20771, 20773, 20789, 20807, 20809, 20849, 20857, 20873, 20879, 20887, 20897, 20899, 20903, 20921, 20929, 20939, 20947, 20959, 20963, 20981, 20983, 21001, 21011, 21013, 21017, 21019, 21023, 21031, 21059, 21061, 21067, 21089, 21101, 21107, 21121, 21139, 21143, 21149, 21157, 21163, 21169, 21179, 21187, 21191, 21193, 21211, 21221, 21227, 21247, 21269, 21277, 21283, 21313, 21317, 21319, 21323, 21341, 21347, 21377, 21379, 21383, 21391, 21397, 21401, 21407, 21419, 21433, 21467, 21481, 21487, 21491, 21493, 21499, 21503, 21517, 21521, 21523, 21529, 21557, 21559, 21563, 21569, 21577, 21587, 21589, 21599, 21601, 21611, 21613, 21617, 21647, 21649, 21661, 21673, 21683, 21701, 21713, 21727, 21737, 21739, 21751, 21757, 21767, 21773, 21787, 21799, 21803, 21817, 21821, 21839, 21841, 21851, 21859, 21863, 21871, 21881, 21893, 21911, 21929, 21937, 21943, 21961, 21977, 21991, 21997, 22003, 22013, 22027, 22031, 22037, 22039, 22051, 22063, 22067, 22073, 22079, 22091, 22093, 22109, 22111, 22123, 22129, 22133, 22147, 22153, 22157, 22159, 22171, 22189, 22193, 22229, 22247, 22259, 22271, 22273, 22277, 22279, 22283, 22291, 22303, 22307, 22343, 22349, 22367, 22369, 22381, 22391, 22397, 22409, 22433, 22441, 22447, 22453, 22469, 22481, 22483, 22501, 22511, 22531, 22541, 22543, 22549, 22567, 22571, 22573, 22613, 22619, 22621, 22637, 22639, 22643, 22651, 22669, 22679, 22691, 22697, 22699, 22709, 22717, 22721, 22727, 22739, 22741, 22751, 22769, 22777, 22783, 22787, 22807, 22811, 22817, 22853, 22859, 22861, 22871, 22877, 22901, 22907, 22921, 22937, 22943, 22961, 22963, 22973, 22993, 23003, 23011, 23017, 23021, 23027, 23029, 23039, 23041, 23053, 23057, 23059, 23063, 23071, 23081, 23087, 23099, 23117, 23131, 23143, 23159, 23167, 23173, 23189, 23197, 23201, 23203, 23209, 23227, 23251, 23269, 23279, 23291, 23293, 23297, 23311, 23321, 23327, 23333, 23339, 23357, 23369, 23371, 23399, 23417, 23431, 23447, 23459, 23473, 23497, 23509, 23531, 23537, 23539, 23549, 23557, 23561, 23563, 23567, 23581, 23593, 23599, 23603, 23609, 23623, 23627, 23629, 23633, 23663, 23669, 23671, 23677, 23687, 23689, 23719, 23741, 23743, 23747, 23753, 23761, 23767, 23773, 23789, 23801, 23813, 23819, 23827, 23831, 23833, 23857, 23869, 23873, 23879, 23887, 23893, 23899, 23909, 23911, 23917, 23929, 23957, 23971, 23977, 23981, 23993, 24001, 24007, 24019, 24023, 24029, 24043, 24049, 24061, 24071, 24077, 24083, 24091, 24097, 24103, 24107, 24109, 24113, 24121, 24133, 24137, 24151, 24169, 24179, 24181, 24197, 24203, 24223, 24229, 24239, 24247, 24251, 24281, 24317, 24329, 24337, 24359, 24371, 24373, 24379, 24391, 24407, 24413, 24419, 24421, 24439, 24443, 24469, 24473, 24481, 24499, 24509, 24517, 24527, 24533, 24547, 24551, 24571, 24593, 24611, 24623, 24631, 24659, 24671, 24677, 24683, 24691, 24697, 24709, 24733, 24749, 24763, 24767, 24781, 24793, 24799, 24809, 24821, 24841, 24847, 24851, 24859, 24877, 24889, 24907, 24917, 24919, 24923, 24943, 24953, 24967, 24971, 24977, 24979, 24989, 25013, 25031, 25033, 25037, 25057, 25073, 25087, 25097, 25111, 25117, 25121, 25127, 25147, 25153, 25163, 25169, 25171, 25183, 25189, 25219, 25229, 25237, 25243, 25247, 25253, 25261, 25301, 25303, 25307, 25309, 25321, 25339, 25343, 25349, 25357, 25367, 25373, 25391, 25409, 25411, 25423, 25439, 25447, 25453, 25457, 25463, 25469, 25471, 25523, 25537, 25541, 25561, 25577, 25579, 25583, 25589, 25601, 25603, 25609, 25621, 25633, 25639, 25643, 25657, 25667, 25673, 25679, 25693, 25703, 25717, 25733, 25741, 25747, 25759, 25763, 25771, 25793, 25799, 25801, 25819, 25841, 25847, 25849, 25867, 25873, 25889, 25903, 25913, 25919, 25931, 25933, 25939, 25943, 25951, 25969, 25981, 25997, 25999, 26003, 26017, 26021, 26029, 26041, 26053, 26083, 26099, 26107, 26111, 26113, 26119, 26141, 26153, 26161, 26171, 26177, 26183, 26189, 26203, 26209, 26227, 26237, 26249, 26251, 26261, 26263, 26267, 26293, 26297, 26309, 26317, 26321, 26339, 26347, 26357, 26371, 26387, 26393, 26399, 26407, 26417, 26423, 26431, 26437, 26449, 26459, 26479, 26489, 26497, 26501, 26513, 26539, 26557, 26561, 26573, 26591, 26597, 26627, 26633, 26641, 26647, 26669, 26681, 26683, 26687, 26693, 26699, 26701, 26711, 26713, 26717, 26723, 26729, 26731, 26737, 26759, 26777, 26783, 26801, 26813, 26821, 26833, 26839, 26849, 26861, 26863, 26879, 26881, 26891, 26893, 26903, 26921, 26927, 26947, 26951, 26953, 26959, 26981, 26987, 26993, 27011, 27017, 27031, 27043, 27059, 27061, 27067, 27073, 27077, 27091, 27103, 27107, 27109, 27127, 27143, 27179, 27191, 27197, 27211, 27239, 27241, 27253, 27259, 27271, 27277, 27281, 27283, 27299, 27329, 27337, 27361, 27367, 27397, 27407, 27409, 27427, 27431, 27437, 27449, 27457, 27479, 27481, 27487, 27509, 27527, 27529, 27539, 27541, 27551, 27581, 27583, 27611, 27617, 27631, 27647, 27653, 27673, 27689, 27691, 27697, 27701, 27733, 27737, 27739, 27743, 27749, 27751, 27763, 27767, 27773, 27779, 27791, 27793, 27799, 27803, 27809, 27817, 27823, 27827, 27847, 27851, 27883, 27893, 27901, 27917, 27919, 27941, 27943, 27947, 27953, 27961, 27967, 27983, 27997, 28001, 28019, 28027, 28031, 28051, 28057, 28069, 28081, 28087, 28097, 28099, 28109, 28111, 28123, 28151, 28163, 28181, 28183, 28201, 28211, 28219, 28229, 28277, 28279, 28283, 28289, 28297, 28307, 28309, 28319, 28349, 28351, 28387, 28393, 28403, 28409, 28411, 28429, 28433, 28439, 28447, 28463, 28477, 28493, 28499, 28513, 28517, 28537, 28541, 28547, 28549, 28559, 28571, 28573, 28579, 28591, 28597, 28603, 28607, 28619, 28621, 28627, 28631, 28643, 28649, 28657, 28661, 28663, 28669, 28687, 28697, 28703, 28711, 28723, 28729, 28751, 28753, 28759, 28771, 28789, 28793, 28807, 28813, 28817, 28837, 28843, 28859, 28867, 28871, 28879, 28901, 28909, 28921, 28927, 28933, 28949, 28961, 28979, 29009, 29017, 29021, 29023, 29027, 29033, 29059, 29063, 29077, 29101, 29123, 29129, 29131, 29137, 29147, 29153, 29167, 29173, 29179, 29191, 29201, 29207, 29209, 29221, 29231, 29243, 29251, 29269, 29287, 29297, 29303, 29311, 29327, 29333, 29339, 29347, 29363, 29383, 29387, 29389, 29399, 29401, 29411, 29423, 29429, 29437, 29443, 29453, 29473, 29483, 29501, 29527, 29531, 29537, 29567, 29569, 29573, 29581, 29587, 29599, 29611, 29629, 29633, 29641, 29663, 29669, 29671, 29683, 29717, 29723, 29741, 29753, 29759, 29761, 29789, 29803, 29819, 29833, 29837, 29851, 29863, 29867, 29873, 29879, 29881, 29917, 29921, 29927, 29947, 29959, 29983, 29989, 30011, 30013, 30029, 30047, 30059, 30071, 30089, 30091, 30097, 30103, 30109, 30113, 30119, 30133, 30137, 30139, 30161, 30169, 30181, 30187, 30197, 30203, 30211, 30223, 30241, 30253, 30259, 30269, 30271, 30293, 30307, 30313, 30319, 30323, 30341, 30347, 30367, 30389, 30391, 30403, 30427, 30431, 30449, 30467, 30469, 30491, 30493, 30497, 30509, 30517, 30529, 30539, 30553, 30557, 30559, 30577, 30593, 30631, 30637, 30643, 30649, 30661, 30671, 30677, 30689, 30697, 30703, 30707, 30713, 30727, 30757, 30763, 30773, 30781, 30803, 30809, 30817, 30829, 30839, 30841, 30851, 30853, 30859, 30869, 30871, 30881, 30893, 30911, 30931, 30937, 30941, 30949, 30971, 30977, 30983, 31013, 31019, 31033, 31039, 31051, 31063, 31069, 31079, 31081, 31091, 31121, 31123, 31139, 31147, 31151, 31153, 31159, 31177, 31181, 31183, 31189, 31193, 31219, 31223, 31231, 31237, 31247, 31249, 31253, 31259, 31267, 31271, 31277, 31307, 31319, 31321, 31327, 31333, 31337, 31357, 31379, 31387, 31391, 31393, 31397, 31469, 31477, 31481, 31489, 31511, 31513, 31517, 31531, 31541, 31543, 31547, 31567, 31573, 31583, 31601, 31607, 31627, 31643, 31649, 31657, 31663, 31667, 31687, 31699, 31721, 31723, 31727, 31729, 31741, 31751, 31769, 31771, 31793, 31799, 31817, 31847, 31849, 31859, 31873, 31883, 31891, 31907, 31957, 31963, 31973, 31981, 31991, 32003, 32009, 32027, 32029, 32051, 32057, 32059, 32063, 32069, 32077, 32083, 32089, 32099, 32117, 32119, 32141, 32143, 32159, 32173, 32183, 32189, 32191, 32203, 32213, 32233, 32237, 32251, 32257, 32261, 32297, 32299, 32303, 32309, 32321, 32323, 32327, 32341, 32353, 32359, 32363, 32369, 32371, 32377, 32381, 32401, 32411, 32413, 32423, 32429, 32441, 32443, 32467, 32479, 32491, 32497, 32503, 32507, 32531, 32533, 32537, 32561, 32563, 32569, 32573, 32579, 32587, 32603, 32609, 32611, 32621, 32633, 32647, 32653, 32687, 32693, 32707, 32713, 32717, 32719, 32749, 32771, 32779, 32783, 32789, 32797, 32801, 32803, 32831, 32833, 32839, 32843, 32869, 32887, 32909, 32911, 32917, 32933, 32939, 32941, 32957, 32969, 32971, 32983, 32987, 32993, 32999, 33013, 33023, 33029, 33037, 33049, 33053, 33071, 33073, 33083, 33091, 33107, 33113, 33119, 33149, 33151, 33161, 33179, 33181, 33191, 33199, 33203, 33211, 33223, 33247, 33287, 33289, 33301, 33311, 33317, 33329, 33331, 33343, 33347, 33349, 33353, 33359, 33377, 33391, 33403, 33409, 33413, 33427, 33457, 33461, 33469, 33479, 33487, 33493, 33503, 33521, 33529, 33533, 33547, 33563, 33569, 33577, 33581, 33587, 33589, 33599, 33601, 33613, 33617, 33619, 33623, 33629, 33637, 33641, 33647, 33679, 33703, 33713, 33721, 33739, 33749, 33751, 33757, 33767, 33769, 33773, 33791, 33797, 33809, 33811, 33827, 33829, 33851, 33857, 33863, 33871, 33889, 33893, 33911, 33923, 33931, 33937, 33941, 33961, 33967, 33997, 34019, 34031, 34033, 34039, 34057, 34061, 34123, 34127, 34129, 34141, 34147, 34157, 34159, 34171, 34183, 34211, 34213, 34217, 34231, 34253, 34259, 34261, 34267, 34273, 34283, 34297, 34301, 34303, 34313, 34319, 34327, 34337, 34351, 34361, 34367, 34369, 34381, 34403, 34421, 34429, 34439, 34457, 34469, 34471, 34483, 34487, 34499, 34501, 34511, 34513, 34519, 34537, 34543, 34549, 34583, 34589, 34591, 34603, 34607, 34613, 34631, 34649, 34651, 34667, 34673, 34679, 34687, 34693, 34703, 34721, 34729, 34739, 34747, 34757, 34759, 34763, 34781, 34807, 34819, 34841, 34843, 34847, 34849, 34871, 34877, 34883, 34897, 34913, 34919, 34939, 34949, 34961, 34963, 34981, 35023, 35027, 35051, 35053, 35059, 35069, 35081, 35083, 35089, 35099, 35107, 35111, 35117, 35129, 35141, 35149, 35153, 35159, 35171, 35201, 35221, 35227, 35251, 35257, 35267, 35279, 35281, 35291, 35311, 35317, 35323, 35327, 35339, 35353, 35363, 35381, 35393, 35401, 35407, 35419, 35423, 35437, 35447, 35449, 35461, 35491, 35507, 35509, 35521, 35527, 35531, 35533, 35537, 35543, 35569, 35573, 35591, 35593, 35597, 35603, 35617, 35671, 35677, 35729, 35731, 35747, 35753, 35759, 35771, 35797, 35801, 35803, 35809, 35831, 35837, 35839, 35851, 35863, 35869, 35879, 35897, 35899, 35911, 35923, 35933, 35951, 35963, 35969, 35977, 35983, 35993, 35999, 36007, 36011, 36013, 36017, 36037, 36061, 36067, 36073, 36083, 36097, 36107, 36109, 36131, 36137, 36151, 36161, 36187, 36191, 36209, 36217, 36229, 36241, 36251, 36263, 36269, 36277, 36293, 36299, 36307, 36313, 36319, 36341, 36343, 36353, 36373, 36383, 36389, 36433, 36451, 36457, 36467, 36469, 36473, 36479, 36493, 36497, 36523, 36527, 36529, 36541, 36551, 36559, 36563, 36571, 36583, 36587, 36599, 36607, 36629, 36637, 36643, 36653, 36671, 36677, 36683, 36691, 36697, 36709, 36713, 36721, 36739, 36749, 36761, 36767, 36779, 36781, 36787, 36791, 36793, 36809, 36821, 36833, 36847, 36857, 36871, 36877, 36887, 36899, 36901, 36913, 36919, 36923, 36929, 36931, 36943, 36947, 36973, 36979, 36997, 37003, 37013, 37019, 37021, 37039, 37049, 37057, 37061, 37087, 37097, 37117, 37123, 37139, 37159, 37171, 37181, 37189, 37199, 37201, 37217, 37223, 37243, 37253, 37273, 37277, 37307, 37309, 37313, 37321, 37337, 37339, 37357, 37361, 37363, 37369, 37379, 37397, 37409, 37423, 37441, 37447, 37463, 37483, 37489, 37493, 37501, 37507, 37511, 37517, 37529, 37537, 37547, 37549, 37561, 37567, 37571, 37573, 37579, 37589, 37591, 37607, 37619, 37633, 37643, 37649, 37657, 37663, 37691, 37693, 37699, 37717, 37747, 37781, 37783, 37799, 37811, 37813, 37831, 37847, 37853, 37861, 37871, 37879, 37889, 37897, 37907, 37951, 37957, 37963, 37967, 37987, 37991, 37993, 37997, 38011, 38039, 38047, 38053, 38069, 38083, 38113, 38119, 38149, 38153, 38167, 38177, 38183, 38189, 38197, 38201, 38219, 38231, 38237, 38239, 38261, 38273, 38281, 38287, 38299, 38303, 38317, 38321, 38327, 38329, 38333, 38351, 38371, 38377, 38393, 38431, 38447, 38449, 38453, 38459, 38461, 38501, 38543, 38557, 38561, 38567, 38569, 38593, 38603, 38609, 38611, 38629, 38639, 38651, 38653, 38669, 38671, 38677, 38693, 38699, 38707, 38711, 38713, 38723, 38729, 38737, 38747, 38749, 38767, 38783, 38791, 38803, 38821, 38833, 38839, 38851, 38861, 38867, 38873, 38891, 38903, 38917, 38921, 38923, 38933, 38953, 38959, 38971, 38977, 38993, 39019, 39023, 39041, 39043, 39047, 39079, 39089, 39097, 39103, 39107, 39113, 39119, 39133, 39139, 39157, 39161, 39163, 39181, 39191, 39199, 39209, 39217, 39227, 39229, 39233, 39239, 39241, 39251, 39293, 39301, 39313, 39317, 39323, 39341, 39343, 39359, 39367, 39371, 39373, 39383, 39397, 39409, 39419, 39439, 39443, 39451, 39461, 39499, 39503, 39509, 39511, 39521, 39541, 39551, 39563, 39569, 39581, 39607, 39619, 39623, 39631, 39659, 39667, 39671, 39679, 39703, 39709, 39719, 39727, 39733, 39749, 39761, 39769, 39779, 39791, 39799, 39821, 39827, 39829, 39839, 39841, 39847, 39857, 39863, 39869, 39877, 39883, 39887, 39901, 39929, 39937, 39953, 39971, 39979, 39983, 39989, 40009, 40013, 40031, 40037, 40039, 40063, 40087, 40093, 40099, 40111, 40123, 40127, 40129, 40151, 40153, 40163, 40169, 40177, 40189, 40193, 40213, 40231, 40237, 40241, 40253, 40277, 40283, 40289, 40343, 40351, 40357, 40361, 40387, 40423, 40427, 40429, 40433, 40459, 40471, 40483, 40487, 40493, 40499, 40507, 40519, 40529, 40531, 40543, 40559, 40577, 40583, 40591, 40597, 40609, 40627, 40637, 40639, 40693, 40697, 40699, 40709, 40739, 40751, 40759, 40763, 40771, 40787, 40801, 40813, 40819, 40823, 40829, 40841, 40847, 40849, 40853, 40867, 40879, 40883, 40897, 40903, 40927, 40933, 40939, 40949, 40961, 40973, 40993, 41011, 41017, 41023, 41039, 41047, 41051, 41057, 41077, 41081, 41113, 41117, 41131, 41141, 41143, 41149, 41161, 41177, 41179, 41183, 41189, 41201, 41203, 41213, 41221, 41227, 41231, 41233, 41243, 41257, 41263, 41269, 41281, 41299, 41333, 41341, 41351, 41357, 41381, 41387, 41389, 41399, 41411, 41413, 41443, 41453, 41467, 41479, 41491, 41507, 41513, 41519, 41521, 41539, 41543, 41549, 41579, 41593, 41597, 41603, 41609, 41611, 41617, 41621, 41627, 41641, 41647, 41651, 41659, 41669, 41681, 41687, 41719, 41729, 41737, 41759, 41761, 41771, 41777, 41801, 41809, 41813, 41843, 41849, 41851, 41863, 41879, 41887, 41893, 41897, 41903, 41911, 41927, 41941, 41947, 41953, 41957, 41959, 41969, 41981, 41983, 41999, 42013, 42017, 42019, 42023, 42043, 42061, 42071, 42073, 42083, 42089, 42101, 42131, 42139, 42157, 42169, 42179, 42181, 42187, 42193, 42197, 42209, 42221, 42223, 42227, 42239, 42257, 42281, 42283, 42293, 42299, 42307, 42323, 42331, 42337, 42349, 42359, 42373, 42379, 42391, 42397, 42403, 42407, 42409, 42433, 42437, 42443, 42451, 42457, 42461, 42463, 42467, 42473, 42487, 42491, 42499, 42509, 42533, 42557, 42569, 42571, 42577, 42589, 42611, 42641, 42643, 42649, 42667, 42677, 42683, 42689, 42697, 42701, 42703, 42709, 42719, 42727, 42737, 42743, 42751, 42767, 42773, 42787, 42793, 42797, 42821, 42829, 42839, 42841, 42853, 42859, 42863, 42899, 42901, 42923, 42929, 42937, 42943, 42953, 42961, 42967, 42979, 42989, 43003, 43013, 43019, 43037, 43049, 43051, 43063, 43067, 43093, 43103, 43117, 43133, 43151, 43159, 43177, 43189, 43201, 43207, 43223, 43237, 43261, 43271, 43283, 43291, 43313, 43319, 43321, 43331, 43391, 43397, 43399, 43403, 43411, 43427, 43441, 43451, 43457, 43481, 43487, 43499, 43517, 43541, 43543, 43573, 43577, 43579, 43591, 43597, 43607, 43609, 43613, 43627, 43633, 43649, 43651, 43661, 43669, 43691, 43711, 43717, 43721, 43753, 43759, 43777, 43781, 43783, 43787, 43789, 43793, 43801, 43853, 43867, 43889, 43891, 43913, 43933, 43943, 43951, 43961, 43963, 43969, 43973, 43987, 43991, 43997, 44017, 44021, 44027, 44029, 44041, 44053, 44059, 44071, 44087, 44089, 44101, 44111, 44119, 44123, 44129, 44131, 44159, 44171, 44179, 44189, 44201, 44203, 44207, 44221, 44249, 44257, 44263, 44267, 44269, 44273, 44279, 44281, 44293, 44351, 44357, 44371, 44381, 44383, 44389, 44417, 44449, 44453, 44483, 44491, 44497, 44501, 44507, 44519, 44531, 44533, 44537, 44543, 44549, 44563, 44579, 44587, 44617, 44621, 44623, 44633, 44641, 44647, 44651, 44657, 44683, 44687, 44699, 44701, 44711, 44729, 44741, 44753, 44771, 44773, 44777, 44789, 44797, 44809, 44819, 44839, 44843, 44851, 44867, 44879, 44887, 44893, 44909, 44917, 44927, 44939, 44953, 44959, 44963, 44971, 44983, 44987, 45007, 45013, 45053, 45061, 45077, 45083, 45119, 45121, 45127, 45131, 45137, 45139, 45161, 45179, 45181, 45191, 45197, 45233, 45247, 45259, 45263, 45281, 45289, 45293, 45307, 45317, 45319, 45329, 45337, 45341, 45343, 45361, 45377, 45389, 45403, 45413, 45427, 45433, 45439, 45481, 45491, 45497, 45503, 45523, 45533, 45541, 45553, 45557, 45569, 45587, 45589, 45599, 45613, 45631, 45641, 45659, 45667, 45673, 45677, 45691, 45697, 45707, 45737, 45751, 45757, 45763, 45767, 45779, 45817, 45821, 45823, 45827, 45833, 45841, 45853, 45863, 45869, 45887, 45893, 45943, 45949, 45953, 45959, 45971, 45979, 45989, 46021, 46027, 46049, 46051, 46061, 46073, 46091, 46093, 46099, 46103, 46133, 46141, 46147, 46153, 46171, 46181, 46183, 46187, 46199, 46219, 46229, 46237, 46261, 46271, 46273, 46279, 46301, 46307, 46309, 46327, 46337, 46349, 46351, 46381, 46399, 46411, 46439, 46441, 46447, 46451, 46457, 46471, 46477, 46489, 46499, 46507, 46511, 46523, 46549, 46559, 46567, 46573, 46589, 46591, 46601, 46619, 46633, 46639, 46643, 46649, 46663, 46679, 46681, 46687, 46691, 46703, 46723, 46727, 46747, 46751, 46757, 46769, 46771, 46807, 46811, 46817, 46819, 46829, 46831, 46853, 46861, 46867, 46877, 46889, 46901, 46919, 46933, 46957, 46993, 46997, 47017, 47041, 47051, 47057, 47059, 47087, 47093, 47111, 47119, 47123, 47129, 47137, 47143, 47147, 47149, 47161, 47189, 47207, 47221, 47237, 47251, 47269, 47279, 47287, 47293, 47297, 47303, 47309, 47317, 47339, 47351, 47353, 47363, 47381, 47387, 47389, 47407, 47417, 47419, 47431, 47441, 47459, 47491, 47497, 47501, 47507, 47513, 47521, 47527, 47533, 47543, 47563, 47569, 47581, 47591, 47599, 47609, 47623, 47629, 47639, 47653, 47657, 47659, 47681, 47699, 47701, 47711, 47713, 47717, 47737, 47741, 47743, 47777, 47779, 47791, 47797, 47807, 47809, 47819, 47837, 47843, 47857, 47869, 47881, 47903, 47911, 47917, 47933, 47939, 47947, 47951, 47963, 47969, 47977, 47981, 48017, 48023, 48029, 48049, 48073, 48079, 48091, 48109, 48119, 48121, 48131, 48157, 48163, 48179, 48187, 48193, 48197, 48221, 48239, 48247, 48259, 48271, 48281, 48299, 48311, 48313, 48337, 48341, 48353, 48371, 48383, 48397, 48407, 48409, 48413, 48437, 48449, 48463, 48473, 48479, 48481, 48487, 48491, 48497, 48523, 48527, 48533, 48539, 48541, 48563, 48571, 48589, 48593, 48611, 48619, 48623, 48647, 48649, 48661, 48673, 48677, 48679, 48731, 48733, 48751, 48757, 48761, 48767, 48779, 48781, 48787, 48799, 48809, 48817, 48821, 48823, 48847, 48857, 48859, 48869, 48871, 48883, 48889, 48907, 48947, 48953, 48973, 48989, 48991, 49003, 49009, 49019, 49031, 49033, 49037, 49043, 49057, 49069, 49081, 49103, 49109, 49117, 49121, 49123, 49139, 49157, 49169, 49171, 49177, 49193, 49199, 49201, 49207, 49211, 49223, 49253, 49261, 49277, 49279, 49297, 49307, 49331, 49333, 49339, 49363, 49367, 49369, 49391, 49393, 49409, 49411, 49417, 49429, 49433, 49451, 49459, 49463, 49477, 49481, 49499, 49523, 49529, 49531, 49537, 49547, 49549, 49559, 49597, 49603, 49613, 49627, 49633, 49639, 49663, 49667, 49669, 49681, 49697, 49711, 49727, 49739, 49741, 49747, 49757, 49783, 49787, 49789, 49801, 49807, 49811, 49823, 49831, 49843, 49853, 49871, 49877, 49891, 49919, 49921, 49927, 49937, 49939, 49943, 49957, 49991, 49993, 49999, 50021, 50023, 50033, 50047, 50051, 50053, 50069, 50077, 50087, 50093, 50101, 50111, 50119, 50123, 50129, 50131, 50147, 50153, 50159, 50177, 50207, 50221, 50227, 50231, 50261, 50263, 50273, 50287, 50291, 50311, 50321, 50329, 50333, 50341, 50359, 50363, 50377, 50383, 50387, 50411, 50417, 50423, 50441, 50459, 50461, 50497, 50503, 50513, 50527, 50539, 50543, 50549, 50551, 50581, 50587, 50591, 50593, 50599, 50627, 50647, 50651, 50671, 50683, 50707, 50723, 50741, 50753, 50767, 50773, 50777, 50789, 50821, 50833, 50839, 50849, 50857, 50867, 50873, 50891, 50893, 50909, 50923, 50929, 50951, 50957, 50969, 50971, 50989, 50993, 51001, 51031, 51043, 51047, 51059, 51061, 51071, 51109, 51131, 51133, 51137, 51151, 51157, 51169, 51193, 51197, 51199, 51203, 51217, 51229, 51239, 51241, 51257, 51263, 51283, 51287, 51307, 51329, 51341, 51343, 51347, 51349, 51361, 51383, 51407, 51413, 51419, 51421, 51427, 51431, 51437, 51439, 51449, 51461, 51473, 51479, 51481, 51487, 51503, 51511, 51517, 51521, 51539, 51551, 51563, 51577, 51581, 51593, 51599, 51607, 51613, 51631, 51637, 51647, 51659, 51673, 51679, 51683, 51691, 51713, 51719, 51721, 51749, 51767, 51769, 51787, 51797, 51803, 51817, 51827, 51829, 51839, 51853, 51859, 51869, 51871, 51893, 51899, 51907, 51913, 51929, 51941, 51949, 51971, 51973, 51977, 51991, 52009, 52021, 52027, 52051, 52057, 52067, 52069, 52081, 52103, 52121, 52127, 52147, 52153, 52163, 52177, 52181, 52183, 52189, 52201, 52223, 52237, 52249, 52253, 52259, 52267, 52289, 52291, 52301, 52313, 52321, 52361, 52363, 52369, 52379, 52387, 52391, 52433, 52453, 52457, 52489, 52501, 52511, 52517, 52529, 52541, 52543, 52553, 52561, 52567, 52571, 52579, 52583, 52609, 52627, 52631, 52639, 52667, 52673, 52691, 52697, 52709, 52711, 52721, 52727, 52733, 52747, 52757, 52769, 52783, 52807, 52813, 52817, 52837, 52859, 52861, 52879, 52883, 52889, 52901, 52903, 52919, 52937, 52951, 52957, 52963, 52967, 52973, 52981, 52999, 53003, 53017, 53047, 53051, 53069, 53077, 53087, 53089, 53093, 53101, 53113, 53117, 53129, 53147, 53149, 53161, 53171, 53173, 53189, 53197, 53201, 53231, 53233, 53239, 53267, 53269, 53279, 53281, 53299, 53309, 53323, 53327, 53353, 53359, 53377, 53381, 53401, 53407, 53411, 53419, 53437, 53441, 53453, 53479, 53503, 53507, 53527, 53549, 53551, 53569, 53591, 53593, 53597, 53609, 53611, 53617, 53623, 53629, 53633, 53639, 53653, 53657, 53681, 53693, 53699, 53717, 53719, 53731, 53759, 53773, 53777, 53783, 53791, 53813, 53819, 53831, 53849, 53857, 53861, 53881, 53887, 53891, 53897, 53899, 53917, 53923, 53927, 53939, 53951, 53959, 53987, 53993, 54001, 54011, 54013, 54037, 54049, 54059, 54083, 54091, 54101, 54121, 54133, 54139, 54151, 54163, 54167, 54181, 54193, 54217, 54251, 54269, 54277, 54287, 54293, 54311, 54319, 54323, 54331, 54347, 54361, 54367, 54371, 54377, 54401, 54403, 54409, 54413, 54419, 54421, 54437, 54443, 54449, 54469, 54493, 54497, 54499, 54503, 54517, 54521, 54539, 54541, 54547, 54559, 54563, 54577, 54581, 54583, 54601, 54617, 54623, 54629, 54631, 54647, 54667, 54673, 54679, 54709, 54713, 54721, 54727, 54751, 54767, 54773, 54779, 54787, 54799, 54829, 54833, 54851, 54869, 54877, 54881, 54907, 54917, 54919, 54941, 54949, 54959, 54973, 54979, 54983, 55001, 55009, 55021, 55049, 55051, 55057, 55061, 55073, 55079, 55103, 55109, 55117, 55127, 55147, 55163, 55171, 55201, 55207, 55213, 55217, 55219, 55229, 55243, 55249, 55259, 55291, 55313, 55331, 55333, 55337, 55339, 55343, 55351, 55373, 55381, 55399, 55411, 55439, 55441, 55457, 55469, 55487, 55501, 55511, 55529, 55541, 55547, 55579, 55589, 55603, 55609, 55619, 55621, 55631, 55633, 55639, 55661, 55663, 55667, 55673, 55681, 55691, 55697, 55711, 55717, 55721, 55733, 55763, 55787, 55793, 55799, 55807, 55813, 55817, 55819, 55823, 55829, 55837, 55843, 55849, 55871, 55889, 55897, 55901, 55903, 55921, 55927, 55931, 55933, 55949, 55967, 55987, 55997, 56003, 56009, 56039, 56041, 56053, 56081, 56087, 56093, 56099, 56101, 56113, 56123, 56131, 56149, 56167, 56171, 56179, 56197, 56207, 56209, 56237, 56239, 56249, 56263, 56267, 56269, 56299, 56311, 56333, 56359, 56369, 56377, 56383, 56393, 56401, 56417, 56431, 56437, 56443, 56453, 56467, 56473, 56477, 56479, 56489, 56501, 56503, 56509, 56519, 56527, 56531, 56533, 56543, 56569, 56591, 56597, 56599, 56611, 56629, 56633, 56659, 56663, 56671, 56681, 56687, 56701, 56711, 56713, 56731, 56737, 56747, 56767, 56773, 56779, 56783, 56807, 56809, 56813, 56821, 56827, 56843, 56857, 56873, 56891, 56893, 56897, 56909, 56911, 56921, 56923, 56929, 56941, 56951, 56957, 56963, 56983, 56989, 56993, 56999, 57037, 57041, 57047, 57059, 57073, 57077, 57089, 57097, 57107, 57119, 57131, 57139, 57143, 57149, 57163, 57173, 57179, 57191, 57193, 57203, 57221, 57223, 57241, 57251, 57259, 57269, 57271, 57283, 57287, 57301, 57329, 57331, 57347, 57349, 57367, 57373, 57383, 57389, 57397, 57413, 57427, 57457, 57467, 57487, 57493, 57503, 57527, 57529, 57557, 57559, 57571, 57587, 57593, 57601, 57637, 57641, 57649, 57653, 57667, 57679, 57689, 57697, 57709, 57713, 57719, 57727, 57731, 57737, 57751, 57773, 57781, 57787, 57791, 57793, 57803, 57809, 57829, 57839, 57847, 57853, 57859, 57881, 57899, 57901, 57917, 57923, 57943, 57947, 57973, 57977, 57991, 58013, 58027, 58031, 58043, 58049, 58057, 58061, 58067, 58073, 58099, 58109, 58111, 58129, 58147, 58151, 58153, 58169, 58171, 58189, 58193, 58199, 58207, 58211, 58217, 58229, 58231, 58237, 58243, 58271, 58309, 58313, 58321, 58337, 58363, 58367, 58369, 58379, 58391, 58393, 58403, 58411, 58417, 58427, 58439, 58441, 58451, 58453, 58477, 58481, 58511, 58537, 58543, 58549, 58567, 58573, 58579, 58601, 58603, 58613, 58631, 58657, 58661, 58679, 58687, 58693, 58699, 58711, 58727, 58733, 58741, 58757, 58763, 58771, 58787, 58789, 58831, 58889, 58897, 58901, 58907, 58909, 58913, 58921, 58937, 58943, 58963, 58967, 58979, 58991, 58997, 59009, 59011, 59021, 59023, 59029, 59051, 59053, 59063, 59069, 59077, 59083, 59093, 59107, 59113, 59119, 59123, 59141, 59149, 59159, 59167, 59183, 59197, 59207, 59209, 59219, 59221, 59233, 59239, 59243, 59263, 59273, 59281, 59333, 59341, 59351, 59357, 59359, 59369, 59377, 59387, 59393, 59399, 59407, 59417, 59419, 59441, 59443, 59447, 59453, 59467, 59471, 59473, 59497, 59509, 59513, 59539, 59557, 59561, 59567, 59581, 59611, 59617, 59621, 59627, 59629, 59651, 59659, 59663, 59669, 59671, 59693, 59699, 59707, 59723, 59729, 59743, 59747, 59753, 59771, 59779, 59791, 59797, 59809, 59833, 59863, 59879, 59887, 59921, 59929, 59951, 59957, 59971, 59981, 59999, 60013, 60017, 60029, 60037, 60041, 60077, 60083, 60089, 60091, 60101, 60103, 60107, 60127, 60133, 60139, 60149, 60161, 60167, 60169, 60209, 60217, 60223, 60251, 60257, 60259, 60271, 60289, 60293, 60317, 60331, 60337, 60343, 60353, 60373, 60383, 60397, 60413, 60427, 60443, 60449, 60457, 60493, 60497, 60509, 60521, 60527, 60539, 60589, 60601, 60607, 60611, 60617, 60623, 60631, 60637, 60647, 60649, 60659, 60661, 60679, 60689, 60703, 60719, 60727, 60733, 60737, 60757, 60761, 60763, 60773, 60779, 60793, 60811, 60821, 60859, 60869, 60887, 60889, 60899, 60901, 60913, 60917, 60919, 60923, 60937, 60943, 60953, 60961, 61001, 61007, 61027, 61031, 61043, 61051, 61057, 61091, 61099, 61121, 61129, 61141, 61151, 61153, 61169, 61211, 61223, 61231, 61253, 61261, 61283, 61291, 61297, 61331, 61333, 61339, 61343, 61357, 61363, 61379, 61381, 61403, 61409, 61417, 61441, 61463, 61469, 61471, 61483, 61487, 61493, 61507, 61511, 61519, 61543, 61547, 61553, 61559, 61561, 61583, 61603, 61609, 61613, 61627, 61631, 61637, 61643, 61651, 61657, 61667, 61673, 61681, 61687, 61703, 61717, 61723, 61729, 61751, 61757, 61781, 61813, 61819, 61837, 61843, 61861, 61871, 61879, 61909, 61927, 61933, 61949, 61961, 61967, 61979, 61981, 61987, 61991, 62003, 62011, 62017, 62039, 62047, 62053, 62057, 62071, 62081, 62099, 62119, 62129, 62131, 62137, 62141, 62143, 62171, 62189, 62191, 62201, 62207, 62213, 62219, 62233, 62273, 62297, 62299, 62303, 62311, 62323, 62327, 62347, 62351, 62383, 62401, 62417, 62423, 62459, 62467, 62473, 62477, 62483, 62497, 62501, 62507, 62533, 62539, 62549, 62563, 62581, 62591, 62597, 62603, 62617, 62627, 62633, 62639, 62653, 62659, 62683, 62687, 62701, 62723, 62731, 62743, 62753, 62761, 62773, 62791, 62801, 62819, 62827, 62851, 62861, 62869, 62873, 62897, 62903, 62921, 62927, 62929, 62939, 62969, 62971, 62981, 62983, 62987, 62989, 63029, 63031, 63059, 63067, 63073, 63079, 63097, 63103, 63113, 63127, 63131, 63149, 63179, 63197, 63199, 63211, 63241, 63247, 63277, 63281, 63299, 63311, 63313, 63317, 63331, 63337, 63347, 63353, 63361, 63367, 63377, 63389, 63391, 63397, 63409, 63419, 63421, 63439, 63443, 63463, 63467, 63473, 63487, 63493, 63499, 63521, 63527, 63533, 63541, 63559, 63577, 63587, 63589, 63599, 63601, 63607, 63611, 63617, 63629, 63647, 63649, 63659, 63667, 63671, 63689, 63691, 63697, 63703, 63709, 63719, 63727, 63737, 63743, 63761, 63773, 63781, 63793, 63799, 63803, 63809, 63823, 63839, 63841, 63853, 63857, 63863, 63901, 63907, 63913, 63929, 63949, 63977, 63997, 64007, 64013, 64019, 64033, 64037, 64063, 64067, 64081, 64091, 64109, 64123, 64151, 64153, 64157, 64171, 64187, 64189, 64217, 64223, 64231, 64237, 64271, 64279, 64283, 64301, 64303, 64319, 64327, 64333, 64373, 64381, 64399, 64403, 64433, 64439, 64451, 64453, 64483, 64489, 64499, 64513, 64553, 64567, 64577, 64579, 64591, 64601, 64609, 64613, 64621, 64627, 64633, 64661, 64663, 64667, 64679, 64693, 64709, 64717, 64747, 64763, 64781, 64783, 64793, 64811, 64817, 64849, 64853, 64871, 64877, 64879, 64891, 64901, 64919, 64921, 64927, 64937, 64951, 64969, 64997, 65003, 65011, 65027, 65029, 65033, 65053, 65063, 65071, 65089, 65099, 65101, 65111, 65119, 65123, 65129, 65141, 65147, 65167, 65171, 65173, 65179, 65183, 65203, 65213, 65239, 65257, 65267, 65269, 65287, 65293, 65309, 65323, 65327, 65353, 65357, 65371, 65381, 65393, 65407, 65413, 65419, 65423, 65437, 65447, 65449, 65479, 65497, 65519, 65521, 65537, 65539, 65543, 65551, 65557, 65563, 65579, 65581, 65587, 65599, 65609, 65617, 65629, 65633, 65647, 65651, 65657, 65677, 65687, 65699, 65701, 65707, 65713, 65717, 65719, 65729, 65731, 65761, 65777, 65789, 65809, 65827, 65831, 65837, 65839, 65843, 65851, 65867, 65881, 65899, 65921, 65927, 65929, 65951, 65957, 65963, 65981, 65983, 65993, 66029, 66037, 66041, 66047, 66067, 66071, 66083, 66089, 66103, 66107, 66109, 66137, 66161, 66169, 66173, 66179, 66191, 66221, 66239, 66271, 66293, 66301, 66337, 66343, 66347, 66359, 66361, 66373, 66377, 66383, 66403, 66413, 66431, 66449, 66457, 66463, 66467, 66491, 66499, 66509, 66523, 66529, 66533, 66541, 66553, 66569, 66571, 66587, 66593, 66601, 66617, 66629, 66643, 66653, 66683, 66697, 66701, 66713, 66721, 66733, 66739, 66749, 66751, 66763, 66791, 66797, 66809, 66821, 66841, 66851, 66853, 66863, 66877, 66883, 66889, 66919, 66923, 66931, 66943, 66947, 66949, 66959, 66973, 66977, 67003, 67021, 67033, 67043, 67049, 67057, 67061, 67073, 67079, 67103, 67121, 67129, 67139, 67141, 67153, 67157, 67169, 67181, 67187, 67189, 67211, 67213, 67217, 67219, 67231, 67247, 67261, 67271, 67273, 67289, 67307, 67339, 67343, 67349, 67369, 67391, 67399, 67409, 67411, 67421, 67427, 67429, 67433, 67447, 67453, 67477, 67481, 67489, 67493, 67499, 67511, 67523, 67531, 67537, 67547, 67559, 67567, 67577, 67579, 67589, 67601, 67607, 67619, 67631, 67651, 67679, 67699, 67709, 67723, 67733, 67741, 67751, 67757, 67759, 67763, 67777, 67783, 67789, 67801, 67807, 67819, 67829, 67843, 67853, 67867, 67883, 67891, 67901, 67927, 67931, 67933, 67939, 67943, 67957, 67961, 67967, 67979, 67987, 67993, 68023, 68041, 68053, 68059, 68071, 68087, 68099, 68111, 68113, 68141, 68147, 68161, 68171, 68207, 68209, 68213, 68219, 68227, 68239, 68261, 68279, 68281, 68311, 68329, 68351, 68371, 68389, 68399, 68437, 68443, 68447, 68449, 68473, 68477, 68483, 68489, 68491, 68501, 68507, 68521, 68531, 68539, 68543, 68567, 68581, 68597, 68611, 68633, 68639, 68659, 68669, 68683, 68687, 68699, 68711, 68713, 68729, 68737, 68743, 68749, 68767, 68771, 68777, 68791, 68813, 68819, 68821, 68863, 68879, 68881, 68891, 68897, 68899, 68903, 68909, 68917, 68927, 68947, 68963, 68993, 69001, 69011, 69019, 69029, 69031, 69061, 69067, 69073, 69109, 69119, 69127, 69143, 69149, 69151, 69163, 69191, 69193, 69197, 69203, 69221, 69233, 69239, 69247, 69257, 69259, 69263, 69313, 69317, 69337, 69341, 69371, 69379, 69383, 69389, 69401, 69403, 69427, 69431, 69439, 69457, 69463, 69467, 69473, 69481, 69491, 69493, 69497, 69499, 69539, 69557, 69593, 69623, 69653, 69661, 69677, 69691, 69697, 69709, 69737, 69739, 69761, 69763, 69767, 69779, 69809, 69821, 69827, 69829, 69833, 69847, 69857, 69859, 69877, 69899, 69911, 69929, 69931, 69941, 69959, 69991, 69997, 70001, 70003, 70009, 70019, 70039, 70051, 70061, 70067, 70079, 70099, 70111, 70117, 70121, 70123, 70139, 70141, 70157, 70163, 70177, 70181, 70183, 70199, 70201, 70207, 70223, 70229, 70237, 70241, 70249, 70271, 70289, 70297, 70309, 70313, 70321, 70327, 70351, 70373, 70379, 70381, 70393, 70423, 70429, 70439, 70451, 70457, 70459, 70481, 70487, 70489, 70501, 70507, 70529, 70537, 70549, 70571, 70573, 70583, 70589, 70607, 70619, 70621, 70627, 70639, 70657, 70663, 70667, 70687, 70709, 70717, 70729, 70753, 70769, 70783, 70793, 70823, 70841, 70843, 70849, 70853, 70867, 70877, 70879, 70891, 70901, 70913, 70919, 70921, 70937, 70949, 70951, 70957, 70969, 70979, 70981, 70991, 70997, 70999, 71011, 71023, 71039, 71059, 71069, 71081, 71089, 71119, 71129, 71143, 71147, 71153, 71161, 71167, 71171, 71191, 71209, 71233, 71237, 71249, 71257, 71261, 71263, 71287, 71293, 71317, 71327, 71329, 71333, 71339, 71341, 71347, 71353, 71359, 71363, 71387, 71389, 71399, 71411, 71413, 71419, 71429, 71437, 71443, 71453, 71471, 71473, 71479, 71483, 71503, 71527, 71537, 71549, 71551, 71563, 71569, 71593, 71597, 71633, 71647, 71663, 71671, 71693, 71699, 71707, 71711, 71713, 71719, 71741, 71761, 71777, 71789, 71807, 71809, 71821, 71837, 71843, 71849, 71861, 71867, 71879, 71881, 71887, 71899, 71909, 71917, 71933, 71941, 71947, 71963, 71971, 71983, 71987, 71993, 71999, 72019, 72031, 72043, 72047, 72053, 72073, 72077, 72089, 72091, 72101, 72103, 72109, 72139, 72161, 72167, 72169, 72173, 72211, 72221, 72223, 72227, 72229, 72251, 72253, 72269, 72271, 72277, 72287, 72307, 72313, 72337, 72341, 72353, 72367, 72379, 72383, 72421, 72431, 72461, 72467, 72469, 72481, 72493, 72497, 72503, 72533, 72547, 72551, 72559, 72577, 72613, 72617, 72623, 72643, 72647, 72649, 72661, 72671, 72673, 72679, 72689, 72701, 72707, 72719, 72727, 72733, 72739, 72763, 72767, 72797, 72817, 72823, 72859, 72869, 72871, 72883, 72889, 72893, 72901, 72907, 72911, 72923, 72931, 72937, 72949, 72953, 72959, 72973, 72977, 72997, 73009, 73013, 73019, 73037, 73039, 73043, 73061, 73063, 73079, 73091, 73121, 73127, 73133, 73141, 73181, 73189, 73237, 73243, 73259, 73277, 73291, 73303, 73309, 73327, 73331, 73351, 73361, 73363, 73369, 73379, 73387, 73417, 73421, 73433, 73453, 73459, 73471, 73477, 73483, 73517, 73523, 73529, 73547, 73553, 73561, 73571, 73583, 73589, 73597, 73607, 73609, 73613, 73637, 73643, 73651, 73673, 73679, 73681, 73693, 73699, 73709, 73721, 73727, 73751, 73757, 73771, 73783, 73819, 73823, 73847, 73849, 73859, 73867, 73877, 73883, 73897, 73907, 73939, 73943, 73951, 73961, 73973, 73999, 74017, 74021, 74027, 74047, 74051, 74071, 74077, 74093, 74099, 74101, 74131, 74143, 74149, 74159, 74161, 74167, 74177, 74189, 74197, 74201, 74203, 74209, 74219, 74231, 74257, 74279, 74287, 74293, 74297, 74311, 74317, 74323, 74353, 74357, 74363, 74377, 74381, 74383, 74411, 74413, 74419, 74441, 74449, 74453, 74471, 74489, 74507, 74509, 74521, 74527, 74531, 74551, 74561, 74567, 74573, 74587, 74597, 74609, 74611, 74623, 74653, 74687, 74699, 74707, 74713, 74717, 74719, 74729, 74731, 74747, 74759, 74761, 74771, 74779, 74797, 74821, 74827, 74831, 74843, 74857, 74861, 74869, 74873, 74887, 74891, 74897, 74903, 74923, 74929, 74933, 74941, 74959, 75011, 75013, 75017, 75029, 75037, 75041, 75079, 75083, 75109, 75133, 75149, 75161, 75167, 75169, 75181, 75193, 75209, 75211, 75217, 75223, 75227, 75239, 75253, 75269, 75277, 75289, 75307, 75323, 75329, 75337, 75347, 75353, 75367, 75377, 75389, 75391, 75401, 75403, 75407, 75431, 75437, 75479, 75503, 75511, 75521, 75527, 75533, 75539, 75541, 75553, 75557, 75571, 75577, 75583, 75611, 75617, 75619, 75629, 75641, 75653, 75659, 75679, 75683, 75689, 75703, 75707, 75709, 75721, 75731, 75743, 75767, 75773, 75781, 75787, 75793, 75797, 75821, 75833, 75853, 75869, 75883, 75913, 75931, 75937, 75941, 75967, 75979, 75983, 75989, 75991, 75997, 76001, 76003, 76031, 76039, 76079, 76081, 76091, 76099, 76103, 76123, 76129, 76147, 76157, 76159, 76163, 76207, 76213, 76231, 76243, 76249, 76253, 76259, 76261, 76283, 76289, 76303, 76333, 76343, 76367, 76369, 76379, 76387, 76403, 76421, 76423, 76441, 76463, 76471, 76481, 76487, 76493, 76507, 76511, 76519, 76537, 76541, 76543, 76561, 76579, 76597, 76603, 76607, 76631, 76649, 76651, 76667, 76673, 76679, 76697, 76717, 76733, 76753, 76757, 76771, 76777, 76781, 76801, 76819, 76829, 76831, 76837, 76847, 76871, 76873, 76883, 76907, 76913, 76919, 76943, 76949, 76961, 76963, 76991, 77003, 77017, 77023, 77029, 77041, 77047, 77069, 77081, 77093, 77101, 77137, 77141, 77153, 77167, 77171, 77191, 77201, 77213, 77237, 77239, 77243, 77249, 77261, 77263, 77267, 77269, 77279, 77291, 77317, 77323, 77339, 77347, 77351, 77359, 77369, 77377, 77383, 77417, 77419, 77431, 77447, 77471, 77477, 77479, 77489, 77491, 77509, 77513, 77521, 77527, 77543, 77549, 77551, 77557, 77563, 77569, 77573, 77587, 77591, 77611, 77617, 77621, 77641, 77647, 77659, 77681, 77687, 77689, 77699, 77711, 77713, 77719, 77723, 77731, 77743, 77747, 77761, 77773, 77783, 77797, 77801, 77813, 77839, 77849, 77863, 77867, 77893, 77899, 77929, 77933, 77951, 77969, 77977, 77983, 77999, 78007, 78017, 78031, 78041, 78049, 78059, 78079, 78101, 78121, 78137, 78139, 78157, 78163, 78167, 78173, 78179, 78191, 78193, 78203, 78229, 78233, 78241, 78259, 78277, 78283, 78301, 78307, 78311, 78317, 78341, 78347, 78367, 78401, 78427, 78437, 78439, 78467, 78479, 78487, 78497, 78509, 78511, 78517, 78539, 78541, 78553, 78569, 78571, 78577, 78583, 78593, 78607, 78623, 78643, 78649, 78653, 78691, 78697, 78707, 78713, 78721, 78737, 78779, 78781, 78787, 78791, 78797, 78803, 78809, 78823, 78839, 78853, 78857, 78877, 78887, 78889, 78893, 78901, 78919, 78929, 78941, 78977, 78979, 78989, 79031, 79039, 79043, 79063, 79087, 79103, 79111, 79133, 79139, 79147, 79151, 79153, 79159, 79181, 79187, 79193, 79201, 79229, 79231, 79241, 79259, 79273, 79279, 79283, 79301, 79309, 79319, 79333, 79337, 79349, 79357, 79367, 79379, 79393, 79397, 79399, 79411, 79423, 79427, 79433, 79451, 79481, 79493, 79531, 79537, 79549, 79559, 79561, 79579, 79589, 79601, 79609, 79613, 79621, 79627, 79631, 79633, 79657, 79669, 79687, 79691, 79693, 79697, 79699, 79757, 79769, 79777, 79801, 79811, 79813, 79817, 79823, 79829, 79841, 79843, 79847, 79861, 79867, 79873, 79889, 79901, 79903, 79907, 79939, 79943, 79967, 79973, 79979, 79987, 79997, 79999, 80021, 80039, 80051, 80071, 80077, 80107, 80111, 80141, 80147, 80149, 80153, 80167, 80173, 80177, 80191, 80207, 80209, 80221, 80231, 80233, 80239, 80251, 80263, 80273, 80279, 80287, 80309, 80317, 80329, 80341, 80347, 80363, 80369, 80387, 80407, 80429, 80447, 80449, 80471, 80473, 80489, 80491, 80513, 80527, 80537, 80557, 80567, 80599, 80603, 80611, 80621, 80627, 80629, 80651, 80657, 80669, 80671, 80677, 80681, 80683, 80687, 80701, 80713, 80737, 80747, 80749, 80761, 80777, 80779, 80783, 80789, 80803, 80809, 80819, 80831, 80833, 80849, 80863, 80897, 80909, 80911, 80917, 80923, 80929, 80933, 80953, 80963, 80989, 81001, 81013, 81017, 81019, 81023, 81031, 81041, 81043, 81047, 81049, 81071, 81077, 81083, 81097, 81101, 81119, 81131, 81157, 81163, 81173, 81181, 81197, 81199, 81203, 81223, 81233, 81239, 81281, 81283, 81293, 81299, 81307, 81331, 81343, 81349, 81353, 81359, 81371, 81373, 81401, 81409, 81421, 81439, 81457, 81463, 81509, 81517, 81527, 81533, 81547, 81551, 81553, 81559, 81563, 81569, 81611, 81619, 81629, 81637, 81647, 81649, 81667, 81671, 81677, 81689, 81701, 81703, 81707, 81727, 81737, 81749, 81761, 81769, 81773, 81799, 81817, 81839, 81847, 81853, 81869, 81883, 81899, 81901, 81919, 81929, 81931, 81937, 81943, 81953, 81967, 81971, 81973, 82003, 82007, 82009, 82013, 82021, 82031, 82037, 82039, 82051, 82067, 82073, 82129, 82139, 82141, 82153, 82163, 82171, 82183, 82189, 82193, 82207, 82217, 82219, 82223, 82231, 82237, 82241, 82261, 82267, 82279, 82301, 82307, 82339, 82349, 82351, 82361, 82373, 82387, 82393, 82421, 82457, 82463, 82469, 82471, 82483, 82487, 82493, 82499, 82507, 82529, 82531, 82549, 82559, 82561, 82567, 82571, 82591, 82601, 82609, 82613, 82619, 82633, 82651, 82657, 82699, 82721, 82723, 82727, 82729, 82757, 82759, 82763, 82781, 82787, 82793, 82799, 82811, 82813, 82837, 82847, 82883, 82889, 82891, 82903, 82913, 82939, 82963, 82981, 82997, 83003, 83009, 83023, 83047, 83059, 83063, 83071, 83077, 83089, 83093, 83101, 83117, 83137, 83177, 83203, 83207, 83219, 83221, 83227, 83231, 83233, 83243, 83257, 83267, 83269, 83273, 83299, 83311, 83339, 83341, 83357, 83383, 83389, 83399, 83401, 83407, 83417, 83423, 83431, 83437, 83443, 83449, 83459, 83471, 83477, 83497, 83537, 83557, 83561, 83563, 83579, 83591, 83597, 83609, 83617, 83621, 83639, 83641, 83653, 83663, 83689, 83701, 83717, 83719, 83737, 83761, 83773, 83777, 83791, 83813, 83833, 83843, 83857, 83869, 83873, 83891, 83903, 83911, 83921, 83933, 83939, 83969, 83983, 83987, 84011, 84017, 84047, 84053, 84059, 84061, 84067, 84089, 84121, 84127, 84131, 84137, 84143, 84163, 84179, 84181, 84191, 84199, 84211, 84221, 84223, 84229, 84239, 84247, 84263, 84299, 84307, 84313, 84317, 84319, 84347, 84349, 84377, 84389, 84391, 84401, 84407, 84421, 84431, 84437, 84443, 84449, 84457, 84463, 84467, 84481, 84499, 84503, 84509, 84521, 84523, 84533, 84551, 84559, 84589, 84629, 84631, 84649, 84653, 84659, 84673, 84691, 84697, 84701, 84713, 84719, 84731, 84737, 84751, 84761, 84787, 84793, 84809, 84811, 84827, 84857, 84859, 84869, 84871, 84913, 84919, 84947, 84961, 84967, 84977, 84979, 84991, 85009, 85021, 85027, 85037, 85049, 85061, 85081, 85087, 85091, 85093, 85103, 85109, 85121, 85133, 85147, 85159, 85193, 85199, 85201, 85213, 85223, 85229, 85237, 85243, 85247, 85259, 85297, 85303, 85313, 85331, 85333, 85361, 85363, 85369, 85381, 85411, 85427, 85429, 85439, 85447, 85451, 85453, 85469, 85487, 85513, 85517, 85523, 85531, 85549, 85571, 85577, 85597, 85601, 85607, 85619, 85621, 85627, 85639, 85643, 85661, 85667, 85669, 85691, 85703, 85711, 85717, 85733, 85751, 85781, 85793, 85817, 85819, 85829, 85831, 85837, 85843, 85847, 85853, 85889, 85903, 85909, 85931, 85933, 85991, 85999, 86011, 86017, 86027, 86029, 86069, 86077, 86083, 86111, 86113, 86117, 86131, 86137, 86143, 86161, 86171, 86179, 86183, 86197, 86201, 86209, 86239, 86243, 86249, 86257, 86263, 86269, 86287, 86291, 86293, 86297, 86311, 86323, 86341, 86351, 86353, 86357, 86369, 86371, 86381, 86389, 86399, 86413, 86423, 86441, 86453, 86461, 86467, 86477, 86491, 86501, 86509, 86531, 86533, 86539, 86561, 86573, 86579, 86587, 86599, 86627, 86629, 86677, 86689, 86693, 86711, 86719, 86729, 86743, 86753, 86767, 86771, 86783, 86813, 86837, 86843, 86851, 86857, 86861, 86869, 86923, 86927, 86929, 86939, 86951, 86959, 86969, 86981, 86993, 87011, 87013, 87037, 87041, 87049, 87071, 87083, 87103, 87107, 87119, 87121, 87133, 87149, 87151, 87179, 87181, 87187, 87211, 87221, 87223, 87251, 87253, 87257, 87277, 87281, 87293, 87299, 87313, 87317, 87323, 87337, 87359, 87383, 87403, 87407, 87421, 87427, 87433, 87443, 87473, 87481, 87491, 87509, 87511, 87517, 87523, 87539, 87541, 87547, 87553, 87557, 87559, 87583, 87587, 87589, 87613, 87623, 87629, 87631, 87641, 87643, 87649, 87671, 87679, 87683, 87691, 87697, 87701, 87719, 87721, 87739, 87743, 87751, 87767, 87793, 87797, 87803, 87811, 87833, 87853, 87869, 87877, 87881, 87887, 87911, 87917, 87931, 87943, 87959, 87961, 87973, 87977, 87991, 88001, 88003, 88007, 88019, 88037, 88069, 88079, 88093, 88117, 88129, 88169, 88177, 88211, 88223, 88237, 88241, 88259, 88261, 88289, 88301, 88321, 88327, 88337, 88339, 88379, 88397, 88411, 88423, 88427, 88463, 88469, 88471, 88493, 88499, 88513, 88523, 88547, 88589, 88591, 88607, 88609, 88643, 88651, 88657, 88661, 88663, 88667, 88681, 88721, 88729, 88741, 88747, 88771, 88789, 88793, 88799, 88801, 88807, 88811, 88813, 88817, 88819, 88843, 88853, 88861, 88867, 88873, 88883, 88897, 88903, 88919, 88937, 88951, 88969, 88993, 88997, 89003, 89009, 89017, 89021, 89041, 89051, 89057, 89069, 89071, 89083, 89087, 89101, 89107, 89113, 89119, 89123, 89137, 89153, 89189, 89203, 89209, 89213, 89227, 89231, 89237, 89261, 89269, 89273, 89293, 89303, 89317, 89329, 89363, 89371, 89381, 89387, 89393, 89399, 89413, 89417, 89431, 89443, 89449, 89459, 89477, 89491, 89501, 89513, 89519, 89521, 89527, 89533, 89561, 89563, 89567, 89591, 89597, 89599, 89603, 89611, 89627, 89633, 89653, 89657, 89659, 89669, 89671, 89681, 89689, 89753, 89759, 89767, 89779, 89783, 89797, 89809, 89819, 89821, 89833, 89839, 89849, 89867, 89891, 89897, 89899, 89909, 89917, 89923, 89939, 89959, 89963, 89977, 89983, 89989, 90001, 90007, 90011, 90017, 90019, 90023, 90031, 90053, 90059, 90067, 90071, 90073, 90089, 90107, 90121, 90127, 90149, 90163, 90173, 90187, 90191, 90197, 90199, 90203, 90217, 90227, 90239, 90247, 90263, 90271, 90281, 90289, 90313, 90353, 90359, 90371, 90373, 90379, 90397, 90401, 90403, 90407, 90437, 90439, 90469, 90473, 90481, 90499, 90511, 90523, 90527, 90529, 90533, 90547, 90583, 90599, 90617, 90619, 90631, 90641, 90647, 90659, 90677, 90679, 90697, 90703, 90709, 90731, 90749, 90787, 90793, 90803, 90821, 90823, 90833, 90841, 90847, 90863, 90887, 90901, 90907, 90911, 90917, 90931, 90947, 90971, 90977, 90989, 90997, 91009, 91019, 91033, 91079, 91081, 91097, 91099, 91121, 91127, 91129, 91139, 91141, 91151, 91153, 91159, 91163, 91183, 91193, 91199, 91229, 91237, 91243, 91249, 91253, 91283, 91291, 91297, 91303, 91309, 91331, 91367, 91369, 91373, 91381, 91387, 91393, 91397, 91411, 91423, 91433, 91453, 91457, 91459, 91463, 91493, 91499, 91513, 91529, 91541, 91571, 91573, 91577, 91583, 91591, 91621, 91631, 91639, 91673, 91691, 91703, 91711, 91733, 91753, 91757, 91771, 91781, 91801, 91807, 91811, 91813, 91823, 91837, 91841, 91867, 91873, 91909, 91921, 91939, 91943, 91951, 91957, 91961, 91967, 91969, 91997, 92003, 92009, 92033, 92041, 92051, 92077, 92083, 92107, 92111, 92119, 92143, 92153, 92173, 92177, 92179, 92189, 92203, 92219, 92221, 92227, 92233, 92237, 92243, 92251, 92269, 92297, 92311, 92317, 92333, 92347, 92353, 92357, 92363, 92369, 92377, 92381, 92383, 92387, 92399, 92401, 92413, 92419, 92431, 92459, 92461, 92467, 92479, 92489, 92503, 92507, 92551, 92557, 92567, 92569, 92581, 92593, 92623, 92627, 92639, 92641, 92647, 92657, 92669, 92671, 92681, 92683, 92693, 92699, 92707, 92717, 92723, 92737, 92753, 92761, 92767, 92779, 92789, 92791, 92801, 92809, 92821, 92831, 92849, 92857, 92861, 92863, 92867, 92893, 92899, 92921, 92927, 92941, 92951, 92957, 92959, 92987, 92993, 93001, 93047, 93053, 93059, 93077, 93083, 93089, 93097, 93103, 93113, 93131, 93133, 93139, 93151, 93169, 93179, 93187, 93199, 93229, 93239, 93241, 93251, 93253, 93257, 93263, 93281, 93283, 93287, 93307, 93319, 93323, 93329, 93337, 93371, 93377, 93383, 93407, 93419, 93427, 93463, 93479, 93481, 93487, 93491, 93493, 93497, 93503, 93523, 93529, 93553, 93557, 93559, 93563, 93581, 93601, 93607, 93629, 93637, 93683, 93701, 93703, 93719, 93739, 93761, 93763, 93787, 93809, 93811, 93827, 93851, 93871, 93887, 93889, 93893, 93901, 93911, 93913, 93923, 93937, 93941, 93949, 93967, 93971, 93979, 93983, 93997, 94007, 94009, 94033, 94049, 94057, 94063, 94079, 94099, 94109, 94111, 94117, 94121, 94151, 94153, 94169, 94201, 94207, 94219, 94229, 94253, 94261, 94273, 94291, 94307, 94309, 94321, 94327, 94331, 94343, 94349, 94351, 94379, 94397, 94399, 94421, 94427, 94433, 94439, 94441, 94447, 94463, 94477, 94483, 94513, 94529, 94531, 94541, 94543, 94547, 94559, 94561, 94573, 94583, 94597, 94603, 94613, 94621, 94649, 94651, 94687, 94693, 94709, 94723, 94727, 94747, 94771, 94777, 94781, 94789, 94793, 94811, 94819, 94823, 94837, 94841, 94847, 94849, 94873, 94889, 94903, 94907, 94933, 94949, 94951, 94961, 94993, 94999, 95003, 95009, 95021, 95027, 95063, 95071, 95083, 95087, 95089, 95093, 95101, 95107, 95111, 95131, 95143, 95153, 95177, 95189, 95191, 95203, 95213, 95219, 95231, 95233, 95239, 95257, 95261, 95267, 95273, 95279, 95287, 95311, 95317, 95327, 95339, 95369, 95383, 95393, 95401, 95413, 95419, 95429, 95441, 95443, 95461, 95467, 95471, 95479, 95483, 95507, 95527, 95531, 95539, 95549, 95561, 95569, 95581, 95597, 95603, 95617, 95621, 95629, 95633, 95651, 95701, 95707, 95713, 95717, 95723, 95731, 95737, 95747, 95773, 95783, 95789, 95791, 95801, 95803, 95813, 95819, 95857, 95869, 95873, 95881, 95891, 95911, 95917, 95923, 95929, 95947, 95957, 95959, 95971, 95987, 95989, 96001, 96013, 96017, 96043, 96053, 96059, 96079, 96097, 96137, 96149, 96157, 96167, 96179, 96181, 96199, 96211, 96221, 96223, 96233, 96259, 96263, 96269, 96281, 96289, 96293, 96323, 96329, 96331, 96337, 96353, 96377, 96401, 96419, 96431, 96443, 96451, 96457, 96461, 96469, 96479, 96487, 96493, 96497, 96517, 96527, 96553, 96557, 96581, 96587, 96589, 96601, 96643, 96661, 96667, 96671, 96697, 96703, 96731, 96737, 96739, 96749, 96757, 96763, 96769, 96779, 96787, 96797, 96799, 96821, 96823, 96827, 96847, 96851, 96857, 96893, 96907, 96911, 96931, 96953, 96959, 96973, 96979, 96989, 96997, 97001, 97003, 97007, 97021, 97039, 97073, 97081, 97103, 97117, 97127, 97151, 97157, 97159, 97169, 97171, 97177, 97187, 97213, 97231, 97241, 97259, 97283, 97301, 97303, 97327, 97367, 97369, 97373, 97379, 97381, 97387, 97397, 97423, 97429, 97441, 97453, 97459, 97463, 97499, 97501, 97511, 97523, 97547, 97549, 97553, 97561, 97571, 97577, 97579, 97583, 97607, 97609, 97613, 97649, 97651, 97673, 97687, 97711, 97729, 97771, 97777, 97787, 97789, 97813, 97829, 97841, 97843, 97847, 97849, 97859, 97861, 97871, 97879, 97883, 97919, 97927, 97931, 97943, 97961, 97967, 97973, 97987, 98009, 98011, 98017, 98041, 98047, 98057, 98081, 98101, 98123, 98129, 98143, 98179, 98207, 98213, 98221, 98227, 98251, 98257, 98269, 98297, 98299, 98317, 98321, 98323, 98327, 98347, 98369, 98377, 98387, 98389, 98407, 98411, 98419, 98429, 98443, 98453, 98459, 98467, 98473, 98479, 98491, 98507, 98519, 98533, 98543, 98561, 98563, 98573, 98597, 98621, 98627, 98639, 98641, 98663, 98669, 98689, 98711, 98713, 98717, 98729, 98731, 98737, 98773, 98779, 98801, 98807, 98809, 98837, 98849, 98867, 98869, 98873, 98887, 98893, 98897, 98899, 98909, 98911, 98927, 98929, 98939, 98947, 98953, 98963, 98981, 98993, 98999, 99013, 99017, 99023, 99041, 99053, 99079, 99083, 99089, 99103, 99109, 99119, 99131, 99133, 99137, 99139, 99149, 99173, 99181, 99191, 99223, 99233, 99241, 99251, 99257, 99259, 99277, 99289, 99317, 99347, 99349, 99367, 99371, 99377, 99391, 99397, 99401, 99409, 99431, 99439, 99469, 99487, 99497, 99523, 99527, 99529, 99551, 99559, 99563, 99571, 99577, 99581, 99607, 99611, 99623, 99643, 99661, 99667, 99679, 99689, 99707, 99709, 99713, 99719, 99721, 99733, 99761, 99767, 99787, 99793, 99809, 99817, 99823, 99829, 99833, 99839, 99859, 99871, 99877, 99881, 99901, 99907, 99923, 99929, 99961, 99971, 99989, 99991, 100003, 100019, 100043, 100049, 100057, 100069, 100103, 100109, 100129, 100151, 100153, 100169, 100183, 100189, 100193, 100207, 100213, 100237, 100267, 100271, 100279, 100291, 100297, 100313, 100333, 100343, 100357, 100361, 100363, 100379, 100391, 100393, 100403, 100411, 100417, 100447, 100459, 100469, 100483, 100493, 100501, 100511, 100517, 100519, 100523, 100537, 100547, 100549, 100559, 100591, 100609, 100613, 100621, 100649, 100669, 100673, 100693, 100699, 100703, 100733, 100741, 100747, 100769, 100787, 100799, 100801, 100811, 100823, 100829, 100847, 100853, 100907, 100913, 100927, 100931, 100937, 100943, 100957, 100981, 100987, 100999, 101009, 101021, 101027, 101051, 101063, 101081, 101089, 101107, 101111, 101113, 101117, 101119, 101141, 101149, 101159, 101161, 101173, 101183, 101197, 101203, 101207, 101209, 101221, 101267, 101273, 101279, 101281, 101287, 101293, 101323, 101333, 101341, 101347, 101359, 101363, 101377, 101383, 101399, 101411, 101419, 101429, 101449, 101467, 101477, 101483, 101489, 101501, 101503, 101513, 101527, 101531, 101533, 101537, 101561, 101573, 101581, 101599, 101603, 101611, 101627, 101641, 101653, 101663, 101681, 101693, 101701, 101719, 101723, 101737, 101741, 101747, 101749, 101771, 101789, 101797, 101807, 101833, 101837, 101839, 101863, 101869, 101873, 101879, 101891, 101917, 101921, 101929, 101939, 101957, 101963, 101977, 101987, 101999, 102001, 102013, 102019, 102023, 102031, 102043, 102059, 102061, 102071, 102077, 102079, 102101, 102103, 102107, 102121, 102139, 102149, 102161, 102181, 102191, 102197, 102199, 102203, 102217, 102229, 102233, 102241, 102251, 102253, 102259, 102293, 102299, 102301, 102317, 102329, 102337, 102359, 102367, 102397, 102407, 102409, 102433, 102437, 102451, 102461, 102481, 102497, 102499, 102503, 102523, 102533, 102539, 102547, 102551, 102559, 102563, 102587, 102593, 102607, 102611, 102643, 102647, 102653, 102667, 102673, 102677, 102679, 102701, 102761, 102763, 102769, 102793, 102797, 102811, 102829, 102841, 102859, 102871, 102877, 102881, 102911, 102913, 102929, 102931, 102953, 102967, 102983, 103001, 103007, 103043, 103049, 103067, 103069, 103079, 103087, 103091, 103093, 103099, 103123, 103141, 103171, 103177, 103183, 103217, 103231, 103237, 103289, 103291, 103307, 103319, 103333, 103349, 103357, 103387, 103391, 103393, 103399, 103409, 103421, 103423, 103451, 103457, 103471, 103483, 103511, 103529, 103549, 103553, 103561, 103567, 103573, 103577, 103583, 103591, 103613, 103619, 103643, 103651, 103657, 103669, 103681, 103687, 103699, 103703, 103723, 103769, 103787, 103801, 103811, 103813, 103837, 103841, 103843, 103867, 103889, 103903, 103913, 103919, 103951, 103963, 103967, 103969, 103979, 103981, 103991, 103993, 103997, 104003, 104009, 104021, 104033, 104047, 104053, 104059, 104087, 104089, 104107, 104113, 104119, 104123, 104147, 104149, 104161, 104173, 104179, 104183, 104207, 104231, 104233, 104239, 104243, 104281, 104287, 104297, 104309, 104311, 104323, 104327, 104347, 104369, 104381, 104383, 104393, 104399, 104417, 104459, 104471, 104473, 104479, 104491, 104513, 104527, 104537, 104543, 104549, 104551, 104561, 104579, 104593, 104597, 104623, 104639, 104651, 104659, 104677, 104681, 104683, 104693, 104701, 104707, 104711, 104717, 104723, 104729];\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/util.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var k, m, mods, v, _i, _len;\n\n  mods = [require(\"pgp-utils\").util, require(\"./openpgp/util\"), require(\"./keybase/util\")];\n\n  for (_i = 0, _len = mods.length; _i < _len; _i++) {\n    m = mods[_i];\n    for (k in m) {\n      v = m[k];\n      exports[k] = v;\n    }\n  }\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/util.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, calc_checksum, encode_length, fit_to_size, ops_to_keyflags;\n\n  C = require('../const');\n\n  exports.make_time_packet = function(d) {\n    var b;\n    d || (d = Math.floor(Date.now() / 1000));\n    b = new Buffer(4);\n    b.writeUInt32BE(d, 0);\n    return b;\n  };\n\n  exports.calc_checksum = calc_checksum = function(text) {\n    var i, ret, _i, _ref;\n    ret = 0;\n    for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      ret = (ret + text.readUInt8(i)) % 65536;\n    }\n    return ret;\n  };\n\n  exports.encode_length = encode_length = function(l, five_byte) {\n    var ret;\n    if (five_byte == null) {\n      five_byte = false;\n    }\n    ret = null;\n    if (l >= 8384 || five_byte) {\n      ret = new Buffer(5);\n      ret.writeUInt8(0xff, 0);\n      ret.writeUInt32BE(l, 1);\n    } else if (l < 192) {\n      ret = new Buffer(1);\n      ret.writeUInt8(l, 0);\n    } else if (l >= 192 && l < 8384) {\n      ret = new Buffer(2);\n      ret.writeUInt16BE((l - 192) + (192 << 8), 0);\n    }\n    return ret;\n  };\n\n  exports.ops_to_keyflags = ops_to_keyflags = function(ops) {\n    var out;\n    out = 0;\n    if (ops & C.ops.encrypt) {\n      out |= C.openpgp.key_flags.encrypt_comm;\n    }\n    if (ops & C.ops.decrypt) {\n      out |= C.openpgp.key_flags.encrypt_comm;\n    }\n    if (ops & C.ops.verify) {\n      out |= C.openpgp.key_flags.sign_data;\n    }\n    if (ops & C.ops.sign) {\n      out |= C.openpgp.key_flags.sign_data;\n    }\n    return out;\n  };\n\n  exports.fit_to_size = fit_to_size = function(size, buf) {\n    var i, l;\n    l = size - buf.length;\n    if (l === 0) {\n      return buf;\n    } else if (l > 0) {\n      return Buffer.concat([\n        buf, new Buffer((function() {\n          var _i, _results;\n          _results = [];\n          for (i = _i = 1; 1 <= l ? _i <= l : _i >= l; i = 1 <= l ? ++_i : --_i) {\n            _results.push(0x00);\n          }\n          return _results;\n        })())\n      ]);\n    } else if (l < 0) {\n      return buf.slice(-size);\n    }\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/const.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var config, k, openpgp, v;\n\n  exports.openpgp = openpgp = {\n    public_key_algorithms: {\n      RSA: 1,\n      RSA_ENCRYPT_ONLY: 2,\n      RSA_SIGN_ONLY: 3,\n      ELGAMAL: 16,\n      DSA: 17,\n      ECDH: 18,\n      ECDSA: 19,\n      ELGAMAL_SIGN_AND_ENCRYPT: 20,\n      EDDSA: 22\n    },\n    symmetric_key_algorithms: {\n      CAST5: 3,\n      AES128: 7,\n      AES192: 8,\n      AES256: 9\n    },\n    hash_algorithms: {\n      MD5: 1,\n      SHA1: 2,\n      RIPEMD160: 3,\n      SHA256: 8,\n      SHA384: 9,\n      SHA512: 10,\n      SHA224: 11\n    },\n    sig_subpacket: {\n      creation_time: 2,\n      expiration_time: 3,\n      exportable_certificate: 4,\n      trust_signature: 5,\n      regular_expression: 6,\n      revocable: 7,\n      key_expiration_time: 9,\n      preferred_symmetric_algorithms: 11,\n      revocation_key: 12,\n      issuer: 16,\n      notation_data: 20,\n      preferred_hash_algorithms: 21,\n      preferred_compression_algorithms: 22,\n      key_server_preferences: 23,\n      preferred_key_server: 24,\n      primary_user_id: 25,\n      policy_uri: 26,\n      key_flags: 27,\n      signers_user_id: 28,\n      reason_for_revocation: 29,\n      features: 30,\n      signature_target: 31,\n      embedded_signature: 32,\n      issuer_fingerprint: 33,\n      experimental_low: 101,\n      experimental_high: 110\n    },\n    sig_types: {\n      binary_doc: 0x00,\n      canonical_text: 0x01,\n      issuer: 0x10,\n      persona: 0x11,\n      casual: 0x12,\n      positive: 0x13,\n      subkey_binding: 0x18,\n      primary_binding: 0x19,\n      direct: 0x1f,\n      key_revocation: 0x20,\n      subkey_revocation: 0x28,\n      certificate_revocation: 0x30\n    },\n    message_types: {\n      generic: 0,\n      public_key: 4,\n      private_key: 5,\n      signature: 8,\n      clearsign: 9\n    },\n    s2k: {\n      plain: 0,\n      salt: 1,\n      salt_iter: 3,\n      gnu: 101,\n      gnu_dummy: 1001\n    },\n    s2k_convention: {\n      none: 0,\n      checksum: 255,\n      sha1: 254\n    },\n    ecdh: {\n      param_bytes: 3,\n      version: 1\n    },\n    packet_tags: {\n      PKESK: 1,\n      signature: 2,\n      one_pass_sig: 4,\n      secret_key: 5,\n      public_key: 6,\n      secret_subkey: 7,\n      compressed: 8,\n      literal: 11,\n      public_subkey: 14,\n      userid: 13,\n      user_attribute: 17,\n      SEIPD: 18,\n      MDC: 19\n    },\n    literal_formats: {\n      binary: 0x62,\n      text: 0x74,\n      utf8: 0x75\n    },\n    versions: {\n      PKESK: 3,\n      SEIPD: 1,\n      one_pass_sig: 3,\n      keymaterial: {\n        V4: 4\n      },\n      signature: {\n        V2: 2,\n        V3: 3,\n        V4: 4\n      }\n    },\n    signatures: {\n      key: 0x99,\n      userid: 0xb4,\n      user_attribute: 0xd1\n    },\n    key_flags: {\n      certify_keys: 0x1,\n      sign_data: 0x2,\n      encrypt_comm: 0x4,\n      encrypt_storage: 0x8,\n      private_split: 0x10,\n      auth: 0x20,\n      shared: 0x80\n    },\n    features: {\n      modification_detection: 0x1\n    },\n    key_server_preferences: {\n      no_modify: 0x80\n    },\n    compression: {\n      none: 0,\n      zip: 1,\n      zlib: 2,\n      bzip: 3\n    }\n  };\n\n  exports.kb = {\n    key_encryption: {\n      none: 0,\n      triplesec_v1: 1,\n      triplesec_v2: 2,\n      triplesec_v3: 3\n    },\n    packet_tags: {\n      p3skb: 0x201,\n      signature: 0x202,\n      encryption: 0x203\n    },\n    public_key_algorithms: {\n      NACL_EDDSA: 0x20,\n      NACL_DH: 0x21\n    },\n    versions: {\n      V1: 1\n    },\n    padding: {\n      EMSA_PCKS1_v1_5: 3,\n      RSASSA_PSS: 4\n    },\n    key_defaults: {\n      primary: {\n        expire_in: 0,\n        nbits: {\n          RSA: 4096,\n          ECDSA: 384,\n          DSA: 2048\n        }\n      },\n      sub: {\n        expire_in: 24 * 60 * 60 * 365 * 8,\n        nbits: {\n          RSA: 2048,\n          ECDH: 256,\n          ECDSA: 256,\n          DSA: 2048,\n          ELGAMAL: 2048\n        }\n      }\n    },\n    kid: {\n      version: 1,\n      trailer: 0x0a,\n      algo: 8,\n      len: 32\n    }\n  };\n\n  exports.ops = {\n    encrypt: 0x1,\n    decrypt: 0x2,\n    verify: 0x4,\n    sign: 0x8\n  };\n\n  exports.header = {\n    version: \"Keybase OpenPGP\",\n    comment: \"https://keybase.io/crypto\"\n  };\n\n  config = {\n    default_key_expire_in: 24 * 60 * 60 * 365 * 4\n  };\n\n  for (k in config) {\n    v = config[k];\n    exports[k] = v;\n  }\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keybase/util.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var SRF, bufxor, genseed, iced, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  SRF = require('../rand').SRF;\n\n  exports.bufxor = bufxor = function(b1, b2) {\n    var arr, c, i;\n    arr = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (i = _i = 0, _len = b1.length; _i < _len; i = ++_i) {\n        c = b1[i];\n        _results.push(c ^ b2[i]);\n      }\n      return _results;\n    })();\n    return new Buffer(arr);\n  };\n\n  exports.genseed = genseed = function(_arg, cb) {\n    var err, len, rseed, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    seed = _arg.seed, split = _arg.split, len = _arg.len, server_half = _arg.server_half;\n    err = rseed = null;\n    if (server_half == null) {\n      server_half = null;\n    }\n    (function(_this) {\n      return (function(__iced_k) {\n        if ((seed == null) || (split && (server_half == null))) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/util.iced\"\n            });\n            SRF().random_bytes(len, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return rseed = arguments[0];\n                };\n              })(),\n              lineno: 16\n            }));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        if ((seed != null) && seed.length !== len) {\n          err = new Error(\"Wrong seed length; need \" + len + \" bytes; got \" + seed.length);\n        } else if ((seed != null) && (rseed != null)) {\n          server_half = rseed;\n          seed = bufxor(seed, rseed);\n        } else if ((seed != null) && (server_half != null)) {\n          seed = bufxor(seed, server_half);\n        } else if (seed == null) {\n          seed = rseed;\n        }\n        return cb(err, {\n          seed: seed,\n          server_half: server_half\n        });\n      };\n    })(this));\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/rand.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BigInteger, Lock, MRF, MediumRandomFountain, SRF, StrongRandomFountain, WordArray, iced, native_rng, prng, __iced_k, __iced_k_noop, _mrf, _ref, _srf;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  BigInteger = require('bn').BigInteger;\n\n  _ref = require('triplesec'), WordArray = _ref.WordArray, prng = _ref.prng;\n\n  native_rng = prng.native_rng;\n\n  Lock = require('iced-lock').Lock;\n\n  MediumRandomFountain = (function() {\n    function MediumRandomFountain() {}\n\n    MediumRandomFountain.prototype.nextBytes = function(v) {\n      var b, c, i, _i, _len, _results;\n      b = native_rng(v.length);\n      _results = [];\n      for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {\n        c = b[i];\n        _results.push(v[i] = c);\n      }\n      return _results;\n    };\n\n    MediumRandomFountain.prototype.random_word = function() {\n      return native_rng(4).readUInt32BE(0);\n    };\n\n    MediumRandomFountain.prototype.random_zn = function(n) {\n      var i;\n      while (true) {\n        i = BigInteger.random_nbit(n.bitLength(), this);\n        if (i.compareTo(BigInteger.ONE) > 0 && i.compareTo(n) < 0) {\n          return i;\n        }\n      }\n    };\n\n    return MediumRandomFountain;\n\n  })();\n\n  _mrf = null;\n\n  MRF = function() {\n    if (_mrf == null) {\n      _mrf = new MediumRandomFountain();\n    }\n    return _mrf;\n  };\n\n  StrongRandomFountain = (function() {\n    function StrongRandomFountain() {\n      this.buf = null;\n      this.lock = new Lock();\n    }\n\n    StrongRandomFountain.prototype.random_word = function(cb) {\n      var wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_word\"\n          });\n          prng.generate(4, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return wa = arguments[0];\n              };\n            })(),\n            lineno: 49\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(wa.to_buffer().readUInt32BE(0));\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.random_double = function(cb) {\n      var wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_double\"\n          });\n          prng.generate(8, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return wa = arguments[0];\n              };\n            })(),\n            lineno: 55\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(wa.to_buffer().readDoubleBE(0));\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.rand_0_1 = function(cb) {\n      var ret, w1, w2, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.rand_0_1\"\n          });\n          _this.random_word(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return w1 = arguments[0];\n              };\n            })(),\n            lineno: 61\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n              funcname: \"StrongRandomFountain.rand_0_1\"\n            });\n            _this.random_word(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return w2 = arguments[0];\n                };\n              })(),\n              lineno: 62\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            ret = w1 * Math.pow(2, -32) + w2 * Math.pow(2, -64);\n            return cb(ret);\n          });\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.random_zn = function(n, cb) {\n      var go, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      go = true;\n      ret = false;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _while;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!go) {\n              return _break();\n            } else {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n                  funcname: \"StrongRandomFountain.random_zn\"\n                });\n                _this.random_nbit(n.bitLength(), __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return ret = arguments[0];\n                    };\n                  })(),\n                  lineno: 72\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return _next(go = (ret.compareTo(BigInteger.ONE) <= 0) || (ret.compareTo(n) >= 0));\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(ret);\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.nextBytes = function(v) {\n      var i, _i, _ref1, _results;\n      _results = [];\n      for (i = _i = 0, _ref1 = v.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {\n        _results.push(v[i] = this.buf[i]);\n      }\n      return _results;\n    };\n\n    StrongRandomFountain.prototype.random_word_array = function(nbytes, cb) {\n      var b, d, max_pull, n, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      ret = new WordArray();\n      max_pull = 512;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_word_array\"\n          });\n          _this.lock.acquire(__iced_deferrals.defer({\n            lineno: 88\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _while;\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = __iced_k;\n              _continue = function() {\n                return iced.trampoline(function() {\n                  return _while(__iced_k);\n                });\n              };\n              _next = _continue;\n              if (!((d = nbytes - ret.sigBytes) > 0)) {\n                return _break();\n              } else {\n                n = Math.min(max_pull, d);\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n                    funcname: \"StrongRandomFountain.random_word_array\"\n                  });\n                  prng.generate(n, __iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return b = arguments[0];\n                      };\n                    })(),\n                    lineno: 91\n                  }));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return _next(ret = ret.concat(b));\n                });\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            _this.lock.release();\n            return cb(ret);\n          });\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.random_bytes = function(nbytes, cb) {\n      var tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_bytes\"\n          });\n          _this.random_word_array(nbytes, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return tmp = arguments[0];\n              };\n            })(),\n            lineno: 99\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(tmp.to_buffer());\n        };\n      })(this));\n    };\n\n    StrongRandomFountain.prototype.random_nbit = function(nbits, cb) {\n      var nbytes, ret, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      nbytes = (nbits >> 3) + 1;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n            funcname: \"StrongRandomFountain.random_nbit\"\n          });\n          _this.random_bytes(nbytes, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return tmp = arguments[0];\n              };\n            })(),\n            lineno: 106\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/rand.iced\",\n              funcname: \"StrongRandomFountain.random_nbit\"\n            });\n            _this.lock.acquire(__iced_deferrals.defer({\n              lineno: 107\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            _this.buf = tmp;\n            ret = BigInteger.random_nbit(nbits, _this);\n            _this.lock.release();\n            return cb(ret);\n          });\n        };\n      })(this));\n    };\n\n    return StrongRandomFountain;\n\n  })();\n\n  _srf = null;\n\n  SRF = function() {\n    if (_srf == null) {\n      _srf = new StrongRandomFountain();\n    }\n    return _srf;\n  };\n\n  exports.MRF = MRF;\n\n  exports.SRF = SRF;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/bn.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BigInteger, bn_from_left_n_bits, buffer_shift_right, buffer_to_ui8a, mpi_byte_length, mpi_from_buffer, mpi_to_padded_octets, nbi, nbits, nbs, nbv, toMPI, _ref;\n\n  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger, nbits = _ref.nbits;\n\n  buffer_to_ui8a = require('./util').buffer_to_ui8a;\n\n  nbs = function(s, base) {\n    var r;\n    if (base == null) {\n      base = 10;\n    }\n    r = nbi();\n    return r.fromString(s, base);\n  };\n\n  mpi_byte_length = function(bn) {\n    return bn.toByteArray().length;\n  };\n\n  toMPI = function(bn) {\n    var ba, hdr, size;\n    ba = bn.toByteArray();\n    size = (ba.length - 1) * 8 + nbits(ba[0]);\n    hdr = new Buffer(2);\n    hdr.writeUInt16BE(size, 0);\n    return Buffer.concat([hdr, new Buffer(ba)]);\n  };\n\n  mpi_from_buffer = function(raw) {\n    var err, hdr, i, n_bits, n_bytes;\n    err = i = null;\n    if (raw.length < 2) {\n      err = new Error(\"need at least 2 bytes; got \" + raw.length);\n    } else {\n      hdr = new Buffer(raw.slice(0, 2));\n      raw = raw.slice(2);\n      n_bits = hdr.readUInt16BE(0);\n      n_bytes = Math.ceil(n_bits / 8);\n      if (raw.length < n_bytes) {\n        err = new Error(\"MPI said \" + n_bytes + \" bytes but only got \" + raw.length);\n      } else {\n        i = nbi().fromBuffer(raw.slice(0, n_bytes));\n        raw = raw.slice(n_bytes);\n      }\n    }\n    return [err, i, raw, n_bytes + 2];\n  };\n\n  mpi_to_padded_octets = function(bn, base) {\n    var ba, diff, i, n, pad;\n    n = base.mpi_byte_length();\n    ba = bn.toByteArray();\n    diff = n - ba.length;\n    pad = new Buffer((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= diff ? _i < diff : _i > diff; i = 0 <= diff ? ++_i : --_i) {\n        _results.push(0);\n      }\n      return _results;\n    })());\n    return Buffer.concat([pad, new Buffer(ba)]);\n  };\n\n  buffer_shift_right = function(buf, nbits) {\n    var c, i, l, mask, nbytes, nxt, rem, _i, _ref1;\n    nbytes = nbits >> 3;\n    rem = nbits % 8;\n    buf = buf.slice(0, buf.length - nbytes);\n    l = buf.length;\n    mask = (1 << rem) - 1;\n    for (i = _i = _ref1 = l - 1; _ref1 <= 0 ? _i <= 0 : _i >= 0; i = _ref1 <= 0 ? ++_i : --_i) {\n      c = buf.readUInt8(i) >> rem;\n      if (i > 0) {\n        nxt = buf.readUInt8(i - 1) & mask;\n        c |= nxt << (8 - rem);\n      }\n      buf.writeUInt8(c, i);\n    }\n    return buf;\n  };\n\n  bn_from_left_n_bits = function(raw, bits) {\n    var buf, bytes, rem, ret;\n    if (raw.length * 8 <= bits) {\n      return nbi().fromBuffer(raw);\n    } else {\n      rem = bits % 8;\n      bytes = (bits >> 3) + (rem ? 1 : 0);\n      buf = raw.slice(0, bytes);\n      ret = nbi().fromBuffer(buf);\n      if (rem > 0) {\n        ret = ret.shiftRight(8 - rem);\n      }\n      return ret;\n    }\n  };\n\n  exports.toMPI = toMPI;\n\n  exports.nbs = nbs;\n\n  exports.mpi_from_buffer = mpi_from_buffer;\n\n  exports.mpi_to_padded_octets = mpi_to_padded_octets;\n\n  exports.buffer_shift_right = buffer_shift_right;\n\n  exports.bn_from_left_n_bits = bn_from_left_n_bits;\n\n  BigInteger.prototype.to_mpi_buffer = function() {\n    return toMPI(this);\n  };\n\n  BigInteger.prototype.mpi_byte_length = function() {\n    return mpi_byte_length(this);\n  };\n\n  BigInteger.prototype.to_padded_octets = function(base) {\n    return mpi_to_padded_octets(this, base);\n  };\n\n  exports.BigInteger = BigInteger;\n\n  exports.nbi = nbi;\n\n  exports.nbv = nbv;\n\n  exports.nbits = nbits;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/hash.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, WordArray, algos, alloc, alloc_or_throw, decorate, k, make_hasher, make_streamer, streamers, triplesec, v, _lookup, _ref;\n\n  C = require('./const').openpgp;\n\n  triplesec = require('triplesec');\n\n  WordArray = triplesec.WordArray;\n\n  algos = triplesec.hash;\n\n  decorate = function(f, klass, name, type) {\n    f.type = type;\n    f.algname = name;\n    f.output_length = klass.output_size;\n    f.klass = klass;\n    return f;\n  };\n\n  make_hasher = function(klass, name, type) {\n    var f;\n    if (klass != null) {\n      f = function(x) {\n        return (new klass).bufhash(x);\n      };\n      return decorate(f, klass, name, type);\n    } else {\n      return null;\n    }\n  };\n\n  make_streamer = function(klass, name, type) {\n    return function() {\n      var obj, ret;\n      obj = new klass;\n      ret = function(buf) {\n        return obj.clone().finalize(buf != null ? WordArray.from_buffer(buf) : null).to_buffer();\n      };\n      ret.update = function(buf) {\n        if (buf != null) {\n          obj.update(WordArray.from_buffer(buf));\n        }\n        return this;\n      };\n      return decorate(ret, klass, name, type);\n    };\n  };\n\n  _lookup = {};\n\n  exports.streamers = streamers = {};\n\n  _ref = C.hash_algorithms;\n  for (k in _ref) {\n    v = _ref[k];\n    _lookup[v] = k;\n    exports[k] = make_hasher(algos[k], k, v);\n    streamers[k] = make_streamer(algos[k], k, v);\n  }\n\n  exports.alloc = alloc = function(typ) {\n    var klass, name, ret;\n    ret = null;\n    name = _lookup[typ];\n    if (name != null) {\n      klass = algos[name];\n    }\n    if (klass != null) {\n      ret = make_hasher(klass, name, typ);\n    }\n    return ret;\n  };\n\n  exports.alloc_or_throw = alloc_or_throw = function(typ) {\n    var ret;\n    ret = alloc(typ);\n    if (!ret) {\n      throw new Error(\"unknown hash type: \" + typ);\n    }\n    return ret;\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/pad.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, SHA512, SRF, bufeq_secure, buffer_to_ui8a, eme_random, emsa_pkcs1_decode, emsa_pkcs1_encode, hash_headers, iced, nbs, __iced_k, __iced_k_noop, _ref;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  SHA512 = require('./hash').SHA512;\n\n  C = require('./const').openpgp;\n\n  nbs = require('./bn').nbs;\n\n  _ref = require('./util'), buffer_to_ui8a = _ref.buffer_to_ui8a, bufeq_secure = _ref.bufeq_secure;\n\n  SRF = require('./rand').SRF;\n\n  hash_headers = {\n    MD5: [0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10],\n    SHA1: [0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14],\n    SHA224: [0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1C],\n    SHA256: [0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20],\n    SHA384: [0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30],\n    SHA512: [0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40]\n  };\n\n  exports.emsa_pkcs1_encode = emsa_pkcs1_encode = function(hashed_data, len, opts) {\n    var buf, hasher, headers, i, n;\n    if (opts == null) {\n      opts = {};\n    }\n    hasher = opts.hasher || SHA512;\n    headers = hash_headers[hasher.algname];\n    n = len - headers.length - 3 - hasher.output_length;\n    buf = Buffer.concat([\n      new Buffer([0x00, 0x01]), new Buffer((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n          _results.push(0xff);\n        }\n        return _results;\n      })()), new Buffer([0x00]), new Buffer(headers), hashed_data\n    ]);\n    return nbs(buffer_to_ui8a(buf), 256);\n  };\n\n  exports.emsa_pkcs1_decode = emsa_pkcs1_decode = function(v, hasher) {\n    var err, h, header, i, ret;\n    err = ret = null;\n    i = 0;\n    if (v.length < 2) {\n      err = new Error(\"signature was way too short: < 2 bytes\");\n    } else {\n      if (v.readUInt16BE(0) !== 0x0001) {\n        err = new Error(\"Sig verify error: Didn't get two-byte header 0x00 0x01\");\n      } else {\n        i = 2;\n        while (i < v.length && (v.readUInt8(i) === 0xff)) {\n          i++;\n        }\n        if (i >= v.length || v.readUInt8(i) !== 0) {\n          err = new Error(\"Sig verify error: Missed the 0x0 separator\");\n        } else {\n          i++;\n          header = hash_headers[hasher.algname];\n          if (!bufeq_secure(new Buffer(header), v.slice(i, header.length + i))) {\n            err = new Error(\"Sig verify error: missing ASN header for \" + hasher.algname);\n          } else {\n            i += header.length;\n            h = v.slice(i);\n            if (h.length !== hasher.output_length) {\n              err = new Error(\"Sig verify error: trailing garbage in signature\");\n            } else {\n              ret = h;\n            }\n          }\n        }\n      }\n    }\n    return [err, ret];\n  };\n\n  eme_random = function(n, cb) {\n    var b, bytes, c, diff, i, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    bytes = [];\n    (function(_this) {\n      return (function(__iced_k) {\n        var _while;\n        _while = function(__iced_k) {\n          var _break, _continue, _next;\n          _break = __iced_k;\n          _continue = function() {\n            return iced.trampoline(function() {\n              return _while(__iced_k);\n            });\n          };\n          _next = _continue;\n          if (!(bytes.length < n)) {\n            return _break();\n          } else {\n            diff = n - bytes.length;\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/pad.iced\"\n              });\n              SRF().random_bytes(diff, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return b = arguments[0];\n                  };\n                })(),\n                lineno: 77\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              var _i;\n              for (i = _i = 0; 0 <= diff ? _i < diff : _i > diff; i = 0 <= diff ? ++_i : --_i) {\n                c = b.readUInt8(i);\n                if (c !== 0) {\n                  bytes.push(c);\n                }\n              }\n              return _next();\n            });\n          }\n        };\n        _while(__iced_k);\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(new Buffer(bytes));\n      };\n    })(this));\n  };\n\n  exports.eme_pkcs1_encode = function(v, len, cb) {\n    var PS, buf, err, n_randos, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    ret = err = null;\n    (function(_this) {\n      return (function(__iced_k) {\n        if (v.length > len - 11) {\n          return __iced_k(err = new Error(\"cannot encrypt message -- it's too long!\"));\n        } else {\n          n_randos = len - 3 - v.length;\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/pad.iced\",\n              funcname: \"eme_pkcs1_encode\"\n            });\n            eme_random(n_randos, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return PS = arguments[0];\n                };\n              })(),\n              lineno: 93\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            buf = Buffer.concat([new Buffer([0x00, 0x02]), PS, new Buffer([0x00]), v]);\n            return __iced_k(ret = nbs(buffer_to_ui8a(buf), 256));\n          });\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, ret);\n      };\n    })(this));\n  };\n\n  exports.eme_pkcs1_decode = function(v) {\n    var err, i, ret;\n    err = ret = null;\n    if (v.length < 12) {\n      err = new Error(\"Ciphertext too short, needs to be >= 12 bytes\");\n    } else if (v.readUInt16BE(0) !== 0x0002) {\n      err = new Error(\"Failed to find expected header: 0x00 0x02\");\n    } else {\n      i = 2;\n      while (i < v.length && (v.readUInt8(i) !== 0x0)) {\n        i++;\n      }\n      if (i >= v.length) {\n        err = new Error(\"didn't get 0x00 seperator octet\");\n      } else {\n        i++;\n        ret = v.slice(i);\n      }\n    }\n    return [err, ret];\n  };\n\n  exports.ecc_pkcs5_pad_data = function(d) {\n    var err, pad_len, ret, v;\n    err = ret = null;\n    pad_len = 40 - d.length;\n    if (pad_len < 0) {\n      err = new Error(\"Pad underrun\");\n    } else {\n      v = (function() {\n        var _i, _results;\n        _results = [];\n        for (_i = 0; 0 <= pad_len ? _i < pad_len : _i > pad_len; 0 <= pad_len ? _i++ : _i--) {\n          _results.push(pad_len);\n        }\n        return _results;\n      })();\n      ret = Buffer.concat([d, new Buffer(v)]);\n    }\n    return [err, ret];\n  };\n\n  exports.ecc_pkcs5_unpad_data = function(buf, data_len) {\n    var c, err, i, pad_len, _i, _ref1;\n    err = null;\n    pad_len = buf.length - data_len;\n    if (pad_len < 0) {\n      err = new Error(\"Pad length was < 0; pad underrun\");\n    } else if ((buf.length % 8) !== 0) {\n      err = new Error(\"Padded data must be a multiple of 8 bytes long\");\n    } else {\n      for (i = _i = data_len, _ref1 = buf.length; data_len <= _ref1 ? _i < _ref1 : _i > _ref1; i = data_len <= _ref1 ? ++_i : --_i) {\n        if ((c = buf.readUInt8(i)) !== pad_len) {\n          err = new Error(\"Got bad PKCS#5 pad character \" + c + \" at position \" + i + \"; wanted \" + pad_len);\n          break;\n        }\n      }\n    }\n    return err;\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/basekeypair.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BaseKey, BaseKeyPair, C, K, SHA256, SHA512, SRF, bn, bufeq_secure, iced, konst, __iced_k, __iced_k_noop, _ref;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref = require('./hash'), SHA256 = _ref.SHA256, SHA512 = _ref.SHA512;\n\n  bn = require('./bn');\n\n  bufeq_secure = require('pgp-utils').util.bufeq_secure;\n\n  SRF = require('./rand').SRF;\n\n  exports.BaseKey = BaseKey = (function() {\n    function BaseKey() {}\n\n    BaseKey.alloc = function(klass, raw, d) {\n      var err, o, orig_len, _i, _len, _ref1, _ref2;\n      if (d == null) {\n        d = {};\n      }\n      orig_len = raw.length;\n      err = null;\n      _ref1 = klass.ORDER;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        o = _ref1[_i];\n        if (err == null) {\n          _ref2 = bn.mpi_from_buffer(raw), err = _ref2[0], d[o] = _ref2[1], raw = _ref2[2];\n        }\n      }\n      if (err) {\n        return [err, null];\n      } else {\n        return [null, new klass(d), orig_len - raw.length];\n      }\n    };\n\n    BaseKey.prototype.serialize = function() {\n      var e;\n      return Buffer.concat((function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = this.ORDER;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          e = _ref1[_i];\n          _results.push(this[e].to_mpi_buffer());\n        }\n        return _results;\n      }).call(this));\n    };\n\n    BaseKey.prototype.validity_check = function(cb) {\n      return cb(null);\n    };\n\n    return BaseKey;\n\n  })();\n\n  exports.BaseKeyPair = BaseKeyPair = (function() {\n    function BaseKeyPair(_arg) {\n      this.priv = _arg.priv, this.pub = _arg.pub;\n      this.pub.parent = this;\n      if (this.priv != null) {\n        this.priv.parent = this;\n      }\n    }\n\n    BaseKeyPair.prototype.serialize = function() {\n      return this.pub.serialize();\n    };\n\n    BaseKeyPair.prototype.hash = function() {\n      return SHA256(this.serialize());\n    };\n\n    BaseKeyPair.prototype.ekid = function() {\n      return Buffer.concat([new Buffer([K.kid.version, this.get_type()]), this.hash(), new Buffer([K.kid.trailer])]);\n    };\n\n    BaseKeyPair.prototype.can_sign = function() {\n      return this.priv != null;\n    };\n\n    BaseKeyPair.prototype.can_decrypt = function() {\n      return this.priv != null;\n    };\n\n    BaseKeyPair.prototype.has_private = function() {\n      return this.priv != null;\n    };\n\n    BaseKeyPair.prototype.fulfills_flags = function(flags) {\n      return false;\n    };\n\n    BaseKeyPair.prototype.is_toxic = function() {\n      return false;\n    };\n\n    BaseKeyPair.prototype.nbits = function() {\n      var _ref1;\n      return (_ref1 = this.pub) != null ? _ref1.nbits() : void 0;\n    };\n\n    BaseKeyPair.prototype.good_for_flags = function() {\n      return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage | C.key_flags.certify_keys | C.key_flags.sign_data;\n    };\n\n    BaseKeyPair.prototype.eq = function(k2) {\n      return (this.type === k2.type) && (bufeq_secure(this.serialize(), k2.serialize()));\n    };\n\n    BaseKeyPair.prototype.can_perform = function(ops_mask) {\n      if ((ops_mask & konst.ops.sign) && !this.can_sign()) {\n        return false;\n      } else if ((ops_mask & konst.ops.decrypt) && !this.can_decrypt()) {\n        return false;\n      } else {\n        return true;\n      }\n    };\n\n    BaseKeyPair.parse = function(klass, pub_raw) {\n      var err, key, len, _ref1;\n      _ref1 = klass.Pub.alloc(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];\n      if (key != null) {\n        key = new klass({\n          pub: key\n        });\n      }\n      return [err, key, len];\n    };\n\n    BaseKeyPair.parse_kb = function(klass, pub_raw) {\n      var err, key, len, _ref1;\n      _ref1 = klass.Pub.alloc_kb(pub_raw), err = _ref1[0], key = _ref1[1], len = _ref1[2];\n      if (key != null) {\n        key = new klass({\n          pub: key\n        });\n      }\n      return [err, key, len];\n    };\n\n    BaseKeyPair.prototype.add_priv = function(priv_raw) {\n      var err, len, _ref1;\n      _ref1 = Priv.alloc(priv_raw), err = _ref1[0], this.priv = _ref1[1], len = _ref1[2];\n      return [err, len];\n    };\n\n    BaseKeyPair.alloc = function(klass, _arg) {\n      var err, priv, pub, _ref1, _ref2;\n      pub = _arg.pub, priv = _arg.priv;\n      _ref1 = klass.Pub.alloc(pub), err = _ref1[0], pub = _ref1[1];\n      if ((err == null) && (priv != null)) {\n        _ref2 = klass.Priv.alloc(priv, pub), err = _ref2[0], priv = _ref2[1];\n      }\n      if (err != null) {\n        return [err, null];\n      } else {\n        return [\n          null, new klass({\n            priv: priv,\n            pub: pub\n          })\n        ];\n      }\n    };\n\n    BaseKeyPair.prototype.read_priv = function(raw_priv) {\n      var err, _ref1;\n      _ref1 = this.Priv.alloc(raw_priv, this.pub), err = _ref1[0], this.priv = _ref1[1];\n      return err;\n    };\n\n    BaseKeyPair.prototype.find = function(i) {\n      return i.mod(this.max_value());\n    };\n\n    BaseKeyPair.prototype.hide = function(_arg, cb) {\n      var L, err, i, max, n, r, r_bits, ret, slosh, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      i = _arg.i, max = _arg.max, slosh = _arg.slosh;\n      ret = err = null;\n      n = this.max_value();\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((L = n.bitLength()) > max) {\n            return __iced_k(err = new Error(\"Can't hide > \" + max + \" bits; got \" + L));\n          } else {\n            r_bits = (max - L) + slosh;\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/basekeypair.iced\",\n                funcname: \"BaseKeyPair.hide\"\n              });\n              SRF().random_nbit(r_bits, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return r = arguments[0];\n                  };\n                })(),\n                lineno: 127\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(ret = r.multiply(n).add(i));\n            });\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    BaseKeyPair.prototype.validity_check = function(cb) {\n      return this.pub.validity_check(cb);\n    };\n\n    BaseKeyPair.prototype._dsa_verify_update_and_check_hash = function(_arg, cb) {\n      var data, err, hash, hasher, klass, sig, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash, klass = _arg.klass;\n      err = null;\n      if (Buffer.isBuffer(sig)) {\n        _ref1 = klass.read_sig_from_buf(sig), err = _ref1[0], sig = _ref1[1];\n      }\n      hash || (hash = hasher(data));\n      (function(_this) {\n        return (function(__iced_k) {\n          if (sig.length !== 2) {\n            return __iced_k(err = new Error(\"Need an [r,s] pair for a DSA-style signature\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/basekeypair.iced\",\n                funcname: \"BaseKeyPair._dsa_verify_update_and_check_hash\"\n              });\n              _this.pub.verify(sig, hash, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return v = arguments[1];\n                  };\n                })(),\n                lineno: 148\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return BaseKeyPair;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/ecc/ecdsa.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, BaseEccKey, BaseKey, BaseKeyPair, BigInteger, C, ECDH, K, Pair, Priv, Pub, bn, bufeq_secure, generate, iced, konst, make_esc, nbits, nbv, uint_to_buffer, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  bn = require('../bn');\n\n  nbits = bn.nbits, nbv = bn.nbv, BigInteger = bn.BigInteger;\n\n  _ref = require('../util'), uint_to_buffer = _ref.uint_to_buffer, bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref1 = require('../basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;\n\n  _ref2 = require('./base'), generate = _ref2.generate, BaseEccKey = _ref2.BaseEccKey;\n\n  ECDH = require('./ecdh').ECDH;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    function Pub() {\n      return Pub.__super__.constructor.apply(this, arguments);\n    }\n\n    Pub.type = C.public_key_algorithms.ECDSA;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.prototype.nbits = function() {\n      return this.curve.nbits();\n    };\n\n    Pub.prototype.read_params = function(sb) {};\n\n    Pub.prototype.trunc_hash = function(h) {\n      return bn.bn_from_left_n_bits(h, this.nbits());\n    };\n\n    Pub.alloc = function(raw) {\n      return BaseEccKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.verify = function(_arg, h, cb) {\n      var err, hi, n, p, r, s, u1, u2, v, w;\n      r = _arg[0], s = _arg[1];\n      err = null;\n      hi = this.trunc_hash(h);\n      if ((r.signum() <= 0) || (r.compareTo(this.curve.p) > 0)) {\n        err = new Error(\"bad r\");\n      } else if ((r.signum() <= 0) || (s.compareTo(this.curve.p) > 0)) {\n        err = new Error(\"bad s\");\n      } else {\n        n = this.curve.n;\n        w = s.modInverse(n);\n        u1 = hi.multiply(w).mod(n);\n        u2 = r.multiply(w).mod(n);\n        p = this.curve.G.multiplyTwo(u1, this.R, u2);\n        v = p.affineX.mod(n);\n        if (!v.equals(r)) {\n          err = new Error(\"verification failed\");\n        }\n      }\n      return cb(err);\n    };\n\n    return Pub;\n\n  })(BaseEccKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = ['x'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(_arg) {\n      this.x = _arg.x, this.pub = _arg.pub;\n    }\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.sign = function(h, cb) {\n      var G, Q, err, hi, k, n, r, s, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref3;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      _ref3 = this.pub.curve, n = _ref3.n, G = _ref3.G;\n      hi = this.pub.trunc_hash(h);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced\",\n            funcname: \"Priv.sign\"\n          });\n          _this.pub.curve.random_scalar(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return k = arguments[0];\n              };\n            })(),\n            lineno: 79\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          Q = G.multiply(k);\n          r = Q.affineX.mod(n);\n          if (r.signum() === 0) {\n            throw new Error(\"invalid r-value\");\n          }\n          s = k.modInverse(n).multiply(hi.add(_this.x.multiply(r))).mod(n);\n          return cb([r, s]);\n        };\n      })(this));\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.ECDSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.klass_name = \"ECDSA\";\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.parse = function(pub_raw) {\n      return BaseKeyPair.parse(Pair, pub_raw);\n    };\n\n    Pair.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    Pair.subkey_algo = function(flags) {\n      if (flags & (C.key_flags.certify_keys | C.key_flags.sign_data)) {\n        return Pair;\n      } else {\n        return ECDH;\n      }\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = C.key_flags.certify_keys | C.key_flags.sign_data;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, hash, hasher, sig;\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      return this._dsa_verify_update_and_check_hash({\n        sig: sig,\n        data: data,\n        hasher: hasher,\n        hash: hash,\n        klass: Pair\n      }, cb);\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var h, hasher, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hasher = _arg.hasher;\n      hasher || (hasher = SHA512);\n      h = hasher(data);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdsa.iced\",\n            funcname: \"Pair.pad_and_sign\"\n          });\n          _this.priv.sign(h, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 134\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null, Buffer.concat((function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = sig.length; _i < _len; _i++) {\n              s = sig[_i];\n              _results.push(s.to_mpi_buffer());\n            }\n            return _results;\n          })()));\n        };\n      })(this));\n    };\n\n    Pair.parse_sig = function(slice) {\n      var buf, err, n, ret, _ref3;\n      buf = slice.peek_rest_to_buffer();\n      _ref3 = Pair.read_sig_from_buf(buf), err = _ref3[0], ret = _ref3[1], n = _ref3[2];\n      if (err != null) {\n        throw err;\n      }\n      slice.advance(n);\n      return ret;\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var err, n, o, order, orig_len, ret, x;\n      orig_len = buf.length;\n      order = ['r', 's'];\n      err = null;\n      ret = (function() {\n        var _i, _len, _ref3, _results;\n        _results = [];\n        for (_i = 0, _len = order.length; _i < _len; _i++) {\n          o = order[_i];\n          if (!(err == null)) {\n            continue;\n          }\n          _ref3 = bn.mpi_from_buffer(buf), err = _ref3[0], x = _ref3[1], buf = _ref3[2];\n          _results.push(x);\n        }\n        return _results;\n      })();\n      n = orig_len - buf.length;\n      return [err, ret, n];\n    };\n\n    Pair.prototype.good_for_flags = function() {\n      return C.key_flags.certify_keys | C.key_flags.sign_data;\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var asp, nbits;\n      nbits = _arg.nbits, asp = _arg.asp;\n      return generate({\n        nbits: nbits,\n        asp: asp,\n        Pair: Pair\n      }, cb);\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.ECDSA = exports.Pair = Pair;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/ecc/base.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BaseEccKey, SlicerBuffer, alloc_by_name, alloc_by_nbits, alloc_by_oid, iced, __iced_k, __iced_k_noop, _ref;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;\n\n  _ref = require('./curves'), alloc_by_nbits = _ref.alloc_by_nbits, alloc_by_oid = _ref.alloc_by_oid, alloc_by_name = _ref.alloc_by_name;\n\n  exports.BaseEccKey = BaseEccKey = (function() {\n    function BaseEccKey(_arg) {\n      this.curve = _arg.curve, this.R = _arg.R;\n    }\n\n    BaseEccKey.prototype.serialize = function() {\n      var oid;\n      oid = this.curve.oid;\n      return Buffer.concat([new Buffer([oid.length]), oid, this.curve.point_to_mpi_buffer(this.R)]);\n    };\n\n    BaseEccKey._alloc = function(klass, raw) {\n      var R, curve, err, l, len, oid, pre, pub, sb, _ref1, _ref2;\n      sb = new SlicerBuffer(raw);\n      pre = sb.rem();\n      l = sb.read_uint8();\n      oid = sb.read_buffer(l);\n      _ref1 = alloc_by_oid(oid), err = _ref1[0], curve = _ref1[1];\n      if (err != null) {\n        throw err;\n      }\n      _ref2 = curve.mpi_point_from_slicer_buffer(sb), err = _ref2[0], R = _ref2[1];\n      if (err != null) {\n        throw err;\n      }\n      pub = new klass({\n        curve: curve,\n        R: R\n      });\n      pub.read_params(sb);\n      len = pre - sb.rem();\n      return [pub, len];\n    };\n\n    BaseEccKey.alloc = function(klass, raw) {\n      var e, err, len, pub, _ref1;\n      pub = len = err = null;\n      try {\n        _ref1 = BaseEccKey._alloc(klass, raw), pub = _ref1[0], len = _ref1[1];\n      } catch (_error) {\n        e = _error;\n        err = e;\n      }\n      return [err, pub, len];\n    };\n\n    BaseEccKey.prototype.validity_check = function(cb) {\n      return cb(null);\n    };\n\n    return BaseEccKey;\n\n  })();\n\n  exports.generate = function(_arg, cb) {\n    var Pair, R, asp, curve, curve_name, err, nbits, priv, pub, ret, x, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1, _ref2;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    nbits = _arg.nbits, asp = _arg.asp, curve_name = _arg.curve_name, Pair = _arg.Pair;\n    ret = null;\n    if (curve_name) {\n      _ref1 = alloc_by_name(curve_name), err = _ref1[0], curve = _ref1[1];\n    } else {\n      _ref2 = alloc_by_nbits(nbits), err = _ref2[0], curve = _ref2[1];\n    }\n    (function(_this) {\n      return (function(__iced_k) {\n        if (err == null) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/zapu/pgp/kbpgp/src/ecc/base.iced\",\n              funcname: \"generate\"\n            });\n            curve.generate(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  x = arguments[0].x;\n                  return R = arguments[0].R;\n                };\n              })(),\n              lineno: 58\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            pub = new Pair.Pub({\n              curve: curve,\n              R: R\n            });\n            priv = new Pair.Priv({\n              pub: pub,\n              x: x\n            });\n            return __iced_k(ret = new Pair({\n              pub: pub,\n              priv: priv\n            }));\n          });\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, ret);\n      };\n    })(this));\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/buffer.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var SlicerBuffer;\n\n  SlicerBuffer = (function() {\n    function SlicerBuffer(buf, start) {\n      this.buf = buf;\n      this.start = start != null ? start : 0;\n      if (!Buffer.isBuffer(this.buf)) {\n        throw new Error('need a Buffer!');\n      }\n      this.i = this.start;\n      this._end = null;\n    }\n\n    SlicerBuffer.prototype.clamp = function(len) {\n      var ret;\n      ret = this._end;\n      this._end = this.i + len;\n      return ret;\n    };\n\n    SlicerBuffer.prototype.unclamp = function(e) {\n      this.start = this.i;\n      return this._end = e;\n    };\n\n    SlicerBuffer.prototype.len = function() {\n      return this.buf.length - this.start;\n    };\n\n    SlicerBuffer.prototype.rem = function() {\n      return this.buf.length - this.i;\n    };\n\n    SlicerBuffer.prototype.offset = function() {\n      return this.i - this.start;\n    };\n\n    SlicerBuffer.prototype.check = function() {\n      if ((this._end && this.i > this._end) || (this.i > this.buf.length)) {\n        throw new Error(\"read off the end of the packet @\" + this.i + \"/\" + this.buf.length + \"/\" + this._end);\n      }\n    };\n\n    SlicerBuffer.prototype.read_uint8 = function() {\n      var ret;\n      ret = this.buf.readUInt8(this.i++);\n      this.check();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.read_uint16 = function() {\n      var ret;\n      ret = this.buf.readUInt16BE(this.i);\n      this.i += 2;\n      this.check();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.read_uint32 = function() {\n      var ret;\n      ret = this.buf.readUInt32BE(this.i);\n      this.i += 4;\n      this.check();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.read_buffer_at_most = function(l) {\n      return this.read_buffer(Math.min(l, this.rem()));\n    };\n\n    SlicerBuffer.prototype.read_buffer = function(l) {\n      var ret;\n      ret = this.buf.slice(this.i, this.i + l);\n      this.i += l;\n      this.check();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.end = function() {\n      return this._end || this.buf.length;\n    };\n\n    SlicerBuffer.prototype.peek_rest_to_buffer = function() {\n      return this.buf.slice(this.i, this.end());\n    };\n\n    SlicerBuffer.prototype.consume_rest_to_buffer = function() {\n      var ret;\n      ret = this.peek_rest_to_buffer();\n      this.i = this.end();\n      return ret;\n    };\n\n    SlicerBuffer.prototype.advance = function(i) {\n      if (i == null) {\n        i = 1;\n      }\n      return this.i += i;\n    };\n\n    SlicerBuffer.prototype.peek_to_buffer = function(len) {\n      return this.buf.slice(this.i, this.i + len);\n    };\n\n    SlicerBuffer.prototype.peek_uint8 = function() {\n      return this.buf.readUInt8(this.i);\n    };\n\n    SlicerBuffer.prototype.peek_uint16 = function() {\n      return this.buf.readUInt16BE(this.i);\n    };\n\n    SlicerBuffer.prototype.read_string = function() {\n      return this.read_buffer(this.read_uint8());\n    };\n\n    SlicerBuffer.prototype.read_v4_length = function() {\n      var five_byte, len, p;\n      p = this.peek_uint8();\n      five_byte = false;\n      len = p < 192 ? (this.advance(1), p) : p < 224 ? this.read_uint16() - (192 << 8) + 192 : p < 0xff ? (this.advance(1), 1 << (p & 0x1f)) : (this.advance(1), five_byte = true, this.read_uint32());\n      return [len, five_byte];\n    };\n\n    return SlicerBuffer;\n\n  })();\n\n  exports.SlicerBuffer = SlicerBuffer;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/ecc/curves.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BigInteger, Curve, Curve25519, H, OIDS, OID_LOOKUP, OID_NAMES, SRF, SlicerBuffer, base, bn, brainpool_p256, brainpool_p384, brainpool_p512, cv25519, iced, k, kbnacl, nist_p256, nist_p384, nist_p521, uint_to_buffer, v, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  BigInteger = require('../bn').BigInteger;\n\n  base = require('keybase-ecurve');\n\n  uint_to_buffer = require('../util').uint_to_buffer;\n\n  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;\n\n  SRF = require('../rand').SRF;\n\n  bn = require('../bn');\n\n  kbnacl = require('keybase-nacl');\n\n  exports.H = H = function(x) {\n    return BigInteger.fromHex(x.split(/\\s+/).join(''));\n  };\n\n  exports.Curve = Curve = (function(_super) {\n    __extends(Curve, _super);\n\n    function Curve(_arg) {\n      var Gx, Gy, a, b, h, n, p;\n      p = _arg.p, a = _arg.a, b = _arg.b, Gx = _arg.Gx, Gy = _arg.Gy, n = _arg.n, h = _arg.h, this.oid = _arg.oid;\n      h || (h = BigInteger.ONE);\n      Curve.__super__.constructor.call(this, p, a, b, Gx, Gy, n, h);\n    }\n\n    Curve.prototype.mkpoint = function(_arg) {\n      var x, y;\n      x = _arg.x, y = _arg.y;\n      return base.Point.fromAffine(this, x, y);\n    };\n\n    Curve.prototype.nbits = function() {\n      return this.p.bitLength();\n    };\n\n    Curve.prototype.mpi_bit_size = function() {\n      return 2 * this.mpi_coord_bit_size() + 3;\n    };\n\n    Curve.prototype.mpi_byte_size = function() {\n      return Math.ceil(this.mpi_bit_size() / 8);\n    };\n\n    Curve.prototype.mpi_coord_byte_size = function() {\n      return Math.ceil(this.nbits() / 8);\n    };\n\n    Curve.prototype.mpi_coord_bit_size = function() {\n      return this.mpi_coord_byte_size() * 8;\n    };\n\n    Curve.prototype._mpi_point_from_slicer_buffer = function(sb) {\n      var b, bits, coord_bytes, n_bits, n_bytes, point, x, y, _ref;\n      n_bits = sb.read_uint16();\n      n_bytes = Math.ceil(n_bits / 8);\n      if (n_bytes !== (b = this.mpi_byte_size())) {\n        bits = this.mpi_bit_size();\n        throw new Error(\"Need \" + b + \" bytes (\" + bits + \" bits) for this curve; got \" + n_bytes + \" (\" + n_bits + \" bits)\");\n      }\n      if (sb.read_uint8() !== 0x4) {\n        throw new Error(\"Can only handle 0x4 prefix for MPI representations\");\n      }\n      coord_bytes = this.mpi_coord_byte_size();\n      _ref = [BigInteger.fromBuffer(sb.read_buffer(coord_bytes)), BigInteger.fromBuffer(sb.read_buffer(coord_bytes))], x = _ref[0], y = _ref[1];\n      point = this.mkpoint({\n        x: x,\n        y: y\n      });\n      if (!this.isOnCurve(point)) {\n        throw new Error(\"Given ECC point isn't on the given curve; data corruption detected.\");\n      }\n      return [null, point];\n    };\n\n    Curve.prototype.mpi_point_from_buffer = function(b) {\n      return this.mpi_point_from_slicer_buffer(new SlicerBuffer(b));\n    };\n\n    Curve.prototype.mpi_point_from_slicer_buffer = function(sb) {\n      var e, err, point, _ref;\n      err = point = null;\n      try {\n        _ref = this._mpi_point_from_slicer_buffer(sb), err = _ref[0], point = _ref[1];\n      } catch (_error) {\n        e = _error;\n        err = e;\n      }\n      return [err, point];\n    };\n\n    Curve.prototype.point_to_mpi_buffer_compact = function(p) {\n      return p.affineX.toBuffer(this.mpi_coord_byte_size());\n    };\n\n    Curve.prototype.point_to_mpi_buffer = function(p) {\n      var ret, sz;\n      sz = this.mpi_coord_byte_size();\n      ret = Buffer.concat([uint_to_buffer(16, this.mpi_bit_size()), new Buffer([0x4]), p.affineX.toBuffer(sz), p.affineY.toBuffer(sz)]);\n      return ret;\n    };\n\n    Curve.prototype.random_scalar = function(cb) {\n      var k, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/curves.iced\",\n            funcname: \"Curve.random_scalar\"\n          });\n          SRF().random_zn(_this.n.subtract(bn.nbv(2)), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return k = arguments[0];\n              };\n            })(),\n            lineno: 103\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          k = k.add(bn.BigInteger.ONE);\n          return cb(k);\n        };\n      })(this));\n    };\n\n    Curve.prototype.coord_to_mpi_buffer = function(p) {\n      var byte_size;\n      byte_size = this.mpi_coord_byte_size();\n      return Buffer.concat([uint_to_buffer(16, byte_size * 8), p.toBuffer(byte_size)]);\n    };\n\n    Curve.prototype.mpi_from_buffer = function(raw) {\n      return bn.mpi_from_buffer(raw);\n    };\n\n    Curve.prototype.encrypt = function(R, cb) {\n      var G, S, V, n, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      n = this.n, G = this.G;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/curves.iced\",\n            funcname: \"Curve.encrypt\"\n          });\n          _this.random_scalar(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return v = arguments[0];\n              };\n            })(),\n            lineno: 134\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          V = G.multiply(v);\n          S = R.multiply(v);\n          return cb({\n            V: V,\n            S: S\n          });\n        };\n      })(this));\n    };\n\n    Curve.prototype.decrypt = function(x, V) {\n      return V.multiply(x);\n    };\n\n    Curve.prototype.generate = function(cb) {\n      var R, x, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/curves.iced\",\n            funcname: \"Curve.generate\"\n          });\n          _this.random_scalar(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return x = arguments[0];\n              };\n            })(),\n            lineno: 157\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          R = _this.G.multiply(x);\n          return cb({\n            x: x,\n            R: R\n          });\n        };\n      })(this));\n    };\n\n    return Curve;\n\n  })(base.Curve);\n\n  exports.Curve25519 = Curve25519 = (function(_super) {\n    __extends(Curve25519, _super);\n\n    function Curve25519(_arg) {\n      this.oid = _arg.oid;\n    }\n\n    Curve25519.prototype.nbits = function() {\n      return 256;\n    };\n\n    Curve25519.prototype.mpi_bit_size = function() {\n      return 263;\n    };\n\n    Curve25519.prototype._mpi_point_from_slicer_buffer = function(sb) {\n      var b, bits, n_bits, n_bytes, point;\n      n_bits = sb.read_uint16();\n      n_bytes = Math.ceil(n_bits / 8);\n      if (n_bytes !== (b = this.mpi_byte_size())) {\n        bits = this.mpi_bit_size();\n        throw new Error(\"Need \" + b + \" bytes (\" + bits + \" bits) for this curve; got \" + n_bytes + \" (\" + n_bits + \" bits)\");\n      }\n      if (sb.read_uint8() !== 0x40) {\n        throw new Error(\"Can only handle 0x40 prefix for 25519 MPI representations\");\n      }\n      n_bytes = this.mpi_coord_byte_size();\n      point = sb.read_buffer(n_bytes);\n      return [null, point];\n    };\n\n    Curve25519.prototype.point_to_mpi_buffer_compact = function(p) {\n      return p;\n    };\n\n    Curve25519.prototype.point_to_mpi_buffer = function(p) {\n      var ret, sz;\n      sz = this.mpi_coord_byte_size();\n      ret = Buffer.concat([uint_to_buffer(16, this.mpi_bit_size()), new Buffer([0x40]), p]);\n      return ret;\n    };\n\n    Curve25519.prototype.random_scalar = function(cb) {\n      return SRF().random_bytes(this.mpi_coord_byte_size(), cb);\n    };\n\n    Curve25519.prototype.coord_to_mpi_buffer = function(p) {\n      var byte_size;\n      byte_size = this.mpi_coord_byte_size();\n      return Buffer.concat([uint_to_buffer(16, byte_size * 8), p]);\n    };\n\n    Curve25519.prototype.mpi_from_buffer = function(raw) {\n      var err, hdr, i, n_bits, n_bytes;\n      err = i = null;\n      if (raw.length < 2) {\n        err = new Error(\"need at least 2 bytes; got \" + raw.length);\n      } else {\n        hdr = new Buffer(raw.slice(0, 2));\n        raw = raw.slice(2);\n        n_bits = hdr.readUInt16BE(0);\n        n_bytes = Math.ceil(n_bits / 8);\n        if (raw.length < n_bytes) {\n          err = new Error(\"MPI said \" + n_bytes + \" bytes but only got \" + raw.length);\n        } else {\n          i = raw.slice(0, n_bytes);\n          raw = raw.slice(n_bytes);\n        }\n      }\n      return [err, i, raw, n_bytes + 2];\n    };\n\n    Curve25519.prototype.encrypt = function(R, cb) {\n      var S, V, nacl, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/curves.iced\",\n            funcname: \"Curve25519.encrypt\"\n          });\n          _this.random_scalar(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return v = arguments[0];\n              };\n            })(),\n            lineno: 257\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          nacl = kbnacl.alloc({});\n          V = nacl.scalarmult_base(v);\n          S = nacl.scalarmult(v, R);\n          return cb({\n            V: V,\n            S: S\n          });\n        };\n      })(this));\n    };\n\n    Curve25519.reverse_buf = function(buf) {\n      var X, i, _i, _ref;\n      X = new Buffer(buf.length);\n      for (i = _i = 0, _ref = buf.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        X[buf.length - 1 - i] = buf[i];\n      }\n      return X;\n    };\n\n    Curve25519.prototype.decrypt = function(x, V) {\n      var S;\n      x = Curve25519.reverse_buf(x);\n      S = kbnacl.alloc({}).scalarmult(x, V);\n      return S;\n    };\n\n    Curve25519.prototype.generate = function(cb) {\n      var R, x, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/curves.iced\",\n            funcname: \"Curve25519.generate\"\n          });\n          _this.random_scalar(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return x = arguments[0];\n              };\n            })(),\n            lineno: 291\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          R = kbnacl.alloc({}).scalarmult_base(x);\n          x = Curve25519.reverse_buf(x);\n          return cb({\n            x: x,\n            R: R\n          });\n        };\n      })(this));\n    };\n\n    return Curve25519;\n\n  })(Curve);\n\n  exports.nist_p256 = nist_p256 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H(\"FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF\");\n    a = H(\"FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFC\");\n    b = H(\"5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B\");\n    n = H(\"FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551\");\n    Gx = H(\"6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296\");\n    Gy = H(\"4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5\");\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.nist_p256\n    });\n  };\n\n  exports.nist_p384 = nist_p384 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff');\n    a = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc');\n    b = H('b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef');\n    n = H('ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973');\n    Gx = H('aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7');\n    Gy = H('3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f');\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.nist_p384\n    });\n  };\n\n  exports.nist_p521 = nist_p521 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff');\n    a = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc');\n    b = H('00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00');\n    n = H('000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409');\n    Gx = H('000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66');\n    Gy = H('00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650');\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.nist_p521\n    });\n  };\n\n  exports.brainpool_p256 = brainpool_p256 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H('a9fb57db a1eea9bc 3e660a90 9d838d72 6e3bf623 d5262028 2013481d 1f6e5377');\n    a = H('7d5a0975 fc2c3057 eef67530 417affe7 fb8055c1 26dc5c6c e94a4b44 f330b5d9');\n    b = H('26dc5c6c e94a4b44 f330b5d9 bbd77cbf 95841629 5cf7e1ce 6bccdc18 ff8c07b6');\n    n = H('a9fb57db a1eea9bc 3e660a90 9d838d71 8c397aa3 b561a6f7 901e0e82 974856a7');\n    Gx = H('8bd2aeb9 cb7e57cb 2c4b482f fc81b7af b9de27e1 e3bd23c2 3a4453bd 9ace3262');\n    Gy = H('547ef835 c3dac4fd 97f8461a 14611dc9 c2774513 2ded8e54 5c1d54c7 2f046997');\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.brainpool_p256\n    });\n  };\n\n  exports.brainpool_p384 = brainpool_p384 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H('8cb91e82 a3386d28 0f5d6f7e 50e641df 152f7109 ed5456b4 12b1da19 7fb71123 acd3a729 901d1a71 87470013 3107ec53');\n    a = H('7bc382c6 3d8c150c 3c72080a ce05afa0 c2bea28e 4fb22787 139165ef ba91f90f 8aa5814a 503ad4eb 04a8c7dd 22ce2826');\n    b = H('04a8c7dd 22ce2826 8b39b554 16f0447c 2fb77de1 07dcd2a6 2e880ea5 3eeb62d5 7cb43902 95dbc994 3ab78696 fa504c11');\n    n = H('8cb91e82 a3386d28 0f5d6f7e 50e641df 152f7109 ed5456b3 1f166e6c ac0425a7 cf3ab6af 6b7fc310 3b883202 e9046565');\n    Gx = H('1d1c64f0 68cf45ff a2a63a81 b7c13f6b 8847a3e7 7ef14fe3 db7fcafe 0cbd10e8 e826e034 36d646aa ef87b2e2 47d4af1e');\n    Gy = H('8abe1d75 20f9c2a4 5cb1eb8e 95cfd552 62b70b29 feec5864 e19c054f f9912928 0e464621 77918111 42820341 263c5315');\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.brainpool_p384\n    });\n  };\n\n  exports.brainpool_p512 = brainpool_p512 = function() {\n    var Gx, Gy, a, b, n, p;\n    p = H('aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07 cb308db3 b3c9d20e d6639cca 70330871 7d4d9b00 9bc66842 aecda12a e6a380e6 2881ff2f 2d82c685 28aa6056 583a48f3');\n    a = H('7830a331 8b603b89 e2327145 ac234cc5 94cbdd8d 3df91610 a83441ca ea9863bc 2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca');\n    b = H('3df91610 a83441ca ea9863bc 2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca dc083e67 984050b7 5ebae5dd 2809bd63 8016f723');\n    n = H('aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07 cb308db3 b3c9d20e d6639cca 70330870 553e5c41 4ca92619 41866119 7fac1047 1db1d381 085ddadd b5879682 9ca90069');\n    Gx = H('81aee4bd d82ed964 5a21322e 9c4c6a93 85ed9f70 b5d916c1 b43b62ee f4d0098e ff3b1f78 e2d0d48d 50d1687b 93b97d5f 7c6d5047 406a5e68 8b352209 bcb9f822');\n    Gy = H('7dde385d 566332ec c0eabfa9 cf7822fd f209f700 24a57b1a a000c55b 881f8111 b2dcde49 4a5f485e 5bca4bd8 8a2763ae d1ca2b2f a8f05406 78cd1e0f 3ad80892');\n    return new Curve({\n      p: p,\n      a: a,\n      b: b,\n      Gx: Gx,\n      Gy: Gy,\n      n: n,\n      oid: OIDS.brainpool_p512\n    });\n  };\n\n  exports.cv25519 = cv25519 = function() {\n    return new Curve25519({\n      oid: OIDS.cv25519\n    });\n  };\n\n  OIDS = {\n    nist_p256: new Buffer([0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]),\n    nist_p384: new Buffer([0x2b, 0x81, 0x04, 0x00, 0x22]),\n    nist_p521: new Buffer([0x2b, 0x81, 0x04, 0x00, 0x23]),\n    brainpool_p256: new Buffer([0x2b, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07]),\n    brainpool_p384: new Buffer([0x2b, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B]),\n    brainpool_p512: new Buffer([0x2b, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D]),\n    cv25519: new Buffer([0x2b, 0x06, 0x01, 0x04, 0x01, 0x97, 0x55, 0x01, 0x05, 0x01])\n  };\n\n  OID_LOOKUP = {};\n\n  for (k in OIDS) {\n    v = OIDS[k];\n    OID_LOOKUP[v.toString('hex')] = exports[k];\n  }\n\n  OID_NAMES = {\n    'Curve25519': cv25519,\n    'NIST P-256': nist_p256,\n    'NIST P-384': nist_p384,\n    'brainpoolP256r1': brainpool_p256,\n    'brainpoolP384r1': brainpool_p384,\n    'brainpoolP512r1': brainpool_p512\n  };\n\n  for (k in OIDS) {\n    OID_NAMES[k] = exports[k];\n  }\n\n  exports.alloc_by_oid = function(oid) {\n    var curve, err, f;\n    if (Buffer.isBuffer(oid)) {\n      oid = oid.toString('hex');\n    }\n    err = curve = null;\n    if ((f = OID_LOOKUP[oid.toLowerCase()]) != null) {\n      curve = f();\n    } else {\n      err = new Error(\"Unknown curve OID: \" + oid);\n    }\n    return [err, curve];\n  };\n\n  exports.alloc_by_nbits = function(nbits) {\n    var err, f, ret;\n    ret = err = null;\n    nbits || (nbits = 256);\n    f = (function() {\n      switch (nbits) {\n        case 256:\n          return nist_p256;\n        case 384:\n          return nist_p384;\n        case 521:\n          return nist_p521;\n        default:\n          return null;\n      }\n    })();\n    if (f != null) {\n      ret = f();\n    } else {\n      err = new Error(\"No curve for \" + nbits + \" bits\");\n    }\n    return [err, ret];\n  };\n\n  exports.alloc_by_name = function(name) {\n    var a, curve, err;\n    err = curve = null;\n    if ((a = OID_NAMES[name]) != null) {\n      curve = a();\n    } else {\n      err = new Error(\"Unknown curve name: \" + name);\n    }\n    return [err, curve];\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/ecc/ecdh.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, BaseEccKey, BaseKey, BaseKeyPair, Const, Output, Pair, Priv, Pub, SlicerBuffer, bufeq_secure, ecc_pkcs5_pad_data, generate, hashmod, iced, konst, make_esc, sym, uint_to_buffer, unwrap, wrap, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  _ref = require('../util'), uint_to_buffer = _ref.uint_to_buffer, bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('../const');\n\n  Const = konst.openpgp;\n\n  _ref1 = require('../basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;\n\n  ecc_pkcs5_pad_data = require('../pad').ecc_pkcs5_pad_data;\n\n  _ref2 = require('./base'), generate = _ref2.generate, BaseEccKey = _ref2.BaseEccKey;\n\n  hashmod = require('../hash');\n\n  sym = require('../symmetric');\n\n  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;\n\n  _ref3 = require('../rfc3394'), wrap = _ref3.wrap, unwrap = _ref3.unwrap;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    function Pub() {\n      return Pub.__super__.constructor.apply(this, arguments);\n    }\n\n    Pub.type = Const.public_key_algorithms.ECDH;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.prototype.apply_defaults = function() {\n      this.cipher || (this.cipher = sym.get_cipher());\n      return this.hasher || (this.hasher = hashmod.SHA512);\n    };\n\n    Pub.prototype.read_params = function(sb) {\n      var n, size, v, val;\n      if ((size = sb.read_uint8()) < (n = Const.ecdh.param_bytes)) {\n        throw new Error(\"Need at least \" + n + \" bytes of params; got \" + size);\n      }\n      if ((val = sb.read_uint8()) !== (v = Const.ecdh.version)) {\n        throw new Error(\"Cannot deal with future extensions, byte=\" + val + \"; wanted \" + v);\n      }\n      this.hasher = hashmod.alloc_or_throw(sb.read_uint8());\n      this.cipher = sym.get_cipher(sb.read_uint8());\n      return sb.advance(size - 3);\n    };\n\n    Pub.alloc = function(raw) {\n      return BaseEccKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.serialize_params = function() {\n      return Buffer.concat([uint_to_buffer(8, Const.ecdh.param_bytes), uint_to_buffer(8, Const.ecdh.version), uint_to_buffer(8, this.hasher.type), uint_to_buffer(8, this.cipher.type)]);\n    };\n\n    Pub.prototype.serialize = function() {\n      return Buffer.concat([Pub.__super__.serialize.call(this), this.serialize_params()]);\n    };\n\n    Pub.prototype.format_params = function(_arg) {\n      var fingerprint;\n      fingerprint = _arg.fingerprint;\n      return Buffer.concat([uint_to_buffer(8, this.curve.oid.length), this.curve.oid, uint_to_buffer(8, this.type), this.serialize_params(), new Buffer(\"Anonymous Sender    \", \"utf8\"), fingerprint]);\n    };\n\n    Pub.prototype.kdf = function(_arg) {\n      var X, X_compact, buf, hash, o_bytes, params;\n      X = _arg.X, params = _arg.params;\n      o_bytes = this.cipher.key_size;\n      X_compact = this.curve.point_to_mpi_buffer_compact(X);\n      buf = Buffer.concat([new Buffer([0, 0, 0, 1]), X_compact, params]);\n      hash = this.hasher(buf);\n      return hash.slice(0, o_bytes);\n    };\n\n    Pub.prototype.encrypt = function(m, _arg, cb) {\n      var C, S, V, fingerprint, key, params, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      fingerprint = _arg.fingerprint;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n            funcname: \"Pub.encrypt\"\n          });\n          _this.curve.encrypt(_this.R, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                V = arguments[0].V;\n                return S = arguments[0].S;\n              };\n            })(),\n            lineno: 97\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          params = _this.format_params({\n            fingerprint: fingerprint\n          });\n          key = _this.kdf({\n            X: S,\n            params: params\n          });\n          C = wrap({\n            key: key,\n            plaintext: m,\n            cipher: _this.cipher\n          });\n          return cb({\n            V: V,\n            C: C\n          });\n        };\n      })(this));\n    };\n\n    return Pub;\n\n  })(BaseEccKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = ['x'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(_arg) {\n      this.x = _arg.x, this.pub = _arg.pub;\n    }\n\n    Priv.prototype.serialize = function() {\n      var curve;\n      curve = this.pub.curve;\n      return curve.coord_to_mpi_buffer(this.x);\n    };\n\n    Priv.alloc = function(raw, pub) {\n      var curve, d, err, o, orig_len, _i, _len, _ref4, _ref5;\n      orig_len = raw.length;\n      err = null;\n      curve = pub.curve;\n      d = {\n        pub: pub\n      };\n      _ref4 = Priv.ORDER;\n      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n        o = _ref4[_i];\n        if (err == null) {\n          _ref5 = curve.mpi_from_buffer(raw), err = _ref5[0], d[o] = _ref5[1], raw = _ref5[2];\n        }\n      }\n      if (err) {\n        return [err, null];\n      } else {\n        return [null, new Priv(d), orig_len - raw.length];\n      }\n    };\n\n    Priv.prototype.decrypt = function(c, _arg, cb) {\n      var S, V, curve, err, esc, fingerprint, key, params, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      fingerprint = _arg.fingerprint;\n      esc = make_esc(cb, \"Priv::decrypt\");\n      curve = this.pub.curve;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n            funcname: \"Priv.decrypt\"\n          });\n          c.load_V(curve, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return V = arguments[0];\n              };\n            })(),\n            lineno: 144\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref4;\n          S = curve.decrypt(_this.x, V);\n          params = _this.pub.format_params({\n            fingerprint: fingerprint\n          });\n          key = _this.pub.kdf({\n            X: S,\n            params: params\n          });\n          _ref4 = unwrap({\n            key: key,\n            ciphertext: c.C,\n            cipher: _this.pub.cipher\n          }), err = _ref4[0], ret = _ref4[1];\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    function Pair() {\n      return Pair.__super__.constructor.apply(this, arguments);\n    }\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = Const.public_key_algorithms.ECDH;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.klass_name = \"ECDH\";\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = Const.key_flags.encrypt_comm | Const.key_flags.encrypt_storage;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.can_sign = function() {\n      return false;\n    };\n\n    Pair.parse = function(pub_raw) {\n      var ret;\n      ret = BaseKeyPair.parse(Pair, pub_raw);\n      return ret;\n    };\n\n    Pair.prototype.max_value = function() {\n      return this.pub.p;\n    };\n\n    Pair.prototype.pad_and_encrypt = function(data, _arg, cb) {\n      var C, V, err, fingerprint, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      fingerprint = _arg.fingerprint;\n      err = ret = null;\n      _ref4 = ecc_pkcs5_pad_data(data), err = _ref4[0], m = _ref4[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n                funcname: \"Pair.pad_and_encrypt\"\n              });\n              _this.pub.encrypt(m, {\n                fingerprint: fingerprint\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    C = arguments[0].C;\n                    return V = arguments[0].V;\n                  };\n                })(),\n                lineno: 199\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(ret = _this.export_output({\n                C: C,\n                V: V,\n                curve: _this.pub.curve\n              }));\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Pair.prototype.decrypt_and_unpad = function(ciphertext, _arg, cb) {\n      var err, fingerprint, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      fingerprint = _arg.fingerprint;\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n            funcname: \"Pair.decrypt_and_unpad\"\n          });\n          _this.priv.decrypt(ciphertext, {\n            fingerprint: fingerprint\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return m = arguments[1];\n              };\n            })(),\n            lineno: 207\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, m, true);\n        };\n      })(this));\n    };\n\n    Pair.parse_output = function(buf) {\n      return Output.parse(buf);\n    };\n\n    Pair.prototype.export_output = function(args) {\n      return new Output(args);\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var asp, curve_name, err, nbits, pair, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      nbits = _arg.nbits, curve_name = _arg.curve_name, asp = _arg.asp;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced\",\n            funcname: \"Pair.generate\"\n          });\n          generate({\n            nbits: nbits,\n            asp: asp,\n            curve_name: curve_name,\n            Pair: Pair\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return pair = arguments[1];\n              };\n            })(),\n            lineno: 218\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            pair.pub.apply_defaults();\n          }\n          return cb(err, pair);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  Output = (function() {\n    function Output(_arg) {\n      this.V_buf = _arg.V_buf, this.C = _arg.C, this.V = _arg.V, this.curve = _arg.curve;\n    }\n\n    Output.prototype.load_V = function(curve, cb) {\n      var err, _ref4;\n      this.curve = curve;\n      _ref4 = curve.mpi_point_from_buffer(this.V_buf), err = _ref4[0], this.V = _ref4[1];\n      return cb(err, this.V);\n    };\n\n    Output.parse = function(buf) {\n      var C, V_buf, a, n_bits, n_bytes, ret, sb;\n      sb = new SlicerBuffer(buf);\n      n_bits = sb.read_uint16();\n      n_bytes = Math.ceil(n_bits / 8);\n      V_buf = Buffer.concat([buf.slice(0, 2), sb.read_buffer(n_bytes)]);\n      n_bytes = sb.read_uint8();\n      C = sb.consume_rest_to_buffer();\n      if ((a = C.length) !== n_bytes) {\n        throw new Error(\"bad C input: wanted \" + n_bytes + \" bytes, but got \" + a);\n      }\n      ret = new Output({\n        V_buf: V_buf,\n        C: C\n      });\n      return ret;\n    };\n\n    Output.prototype.get_V_buf = function() {\n      if (this.V_buf == null) {\n        this.V_buf = this.curve.point_to_mpi_buffer(this.V);\n      }\n      return this.V_buf;\n    };\n\n    Output.prototype.hide = function(_arg, cb) {\n      var key, max, slosh;\n      key = _arg.key, max = _arg.max, slosh = _arg.slosh;\n      return cb(null);\n    };\n\n    Output.prototype.find = function(_arg) {\n      var key;\n      key = _arg.key;\n    };\n\n    Output.prototype.good_for_flags = function() {\n      return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;\n    };\n\n    Output.prototype.output = function() {\n      return Buffer.concat([this.get_V_buf(), uint_to_buffer(8, this.C.length), this.C]);\n    };\n\n    return Output;\n\n  })();\n\n  exports.ECDH = exports.Pair = Pair;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/symmetric.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var AES, C, CAST5, SlicerBuffer, WordArray, checksum2, ecc_pkcs5_unpad_data, export_key_pgp, get_cipher, import_key_pgp, triplesec, uint_to_buffer;\n\n  C = require('./const').openpgp.symmetric_key_algorithms;\n\n  triplesec = require('triplesec');\n\n  AES = triplesec.ciphers.AES;\n\n  CAST5 = require('./openpgp/cast5').CAST5;\n\n  SlicerBuffer = require('./openpgp/buffer').SlicerBuffer;\n\n  WordArray = triplesec.WordArray;\n\n  uint_to_buffer = require('./util').uint_to_buffer;\n\n  ecc_pkcs5_unpad_data = require('./pad').ecc_pkcs5_unpad_data;\n\n  exports.get_cipher = get_cipher = function(n) {\n    var ret;\n    n || (n = C.AES256);\n    ret = (function() {\n      switch (n) {\n        case C.AES128:\n          return {\n            klass: AES,\n            key_size: 16\n          };\n        case C.AES192:\n          return {\n            klass: AES,\n            key_size: 24\n          };\n        case C.AES256:\n          return {\n            klass: AES,\n            key_size: 32\n          };\n        case C.CAST5:\n          return {\n            klass: CAST5,\n            key_size: CAST5.keySize\n          };\n        default:\n          throw new Error(\"unknown cipher: \" + n);\n      }\n    })();\n    ret.type = n;\n    return ret;\n  };\n\n  exports.checksum2 = checksum2 = function(buf) {\n    var i, res, _i, _ref;\n    res = 0;\n    for (i = _i = 0, _ref = buf.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      res = (res + buf.readUInt8(i)) & 0xffff;\n    }\n    return res;\n  };\n\n  exports.import_key_pgp = import_key_pgp = function(msg, pkcs5_padding) {\n    var checksum, cipher, err, key, ret, sb;\n    if (pkcs5_padding == null) {\n      pkcs5_padding = false;\n    }\n    sb = new SlicerBuffer(msg);\n    ret = err = null;\n    cipher = get_cipher(sb.read_uint8());\n    key = sb.read_buffer(cipher.key_size);\n    checksum = sb.read_uint16();\n    err = checksum2(key) !== checksum ? new Error(\"Checksum mismatch\") : pkcs5_padding ? ecc_pkcs5_unpad_data(msg, sb.offset()) : !sb.rem() ? null : new Error(\"Junk at the end of input\");\n    if (err != null) {\n      throw err;\n    }\n    return new cipher.klass(WordArray.from_buffer(key));\n  };\n\n  exports.export_key_pgp = export_key_pgp = function(algo_id, key) {\n    var csum;\n    csum = checksum2(key);\n    return Buffer.concat([new Buffer([algo_id]), key, uint_to_buffer(16, csum)]);\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/cast5.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var CAST5, G, Global, WordArray, ui32a_to_ui8a, ui8a_to_ui32a, _ref;\n\n  WordArray = require('triplesec').WordArray;\n\n  _ref = require('../util'), ui8a_to_ui32a = _ref.ui8a_to_ui32a, ui32a_to_ui8a = _ref.ui32a_to_ui8a;\n\n  Global = (function() {\n    function Global() {\n      this.init_schedule();\n      this.init_sbox();\n    }\n\n    Global.prototype.init_schedule = function() {\n      var scheduleA, scheduleB;\n      scheduleA = new Array(4);\n      scheduleA[0] = new Array(4);\n      scheduleA[0][0] = new Uint8Array([4, 0, 0xd, 0xf, 0xc, 0xe, 0x8]);\n      scheduleA[0][1] = new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa]);\n      scheduleA[0][2] = new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]);\n      scheduleA[0][3] = new Uint8Array([7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb]);\n      scheduleA[1] = new Array(4);\n      scheduleA[1][0] = new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]);\n      scheduleA[1][1] = new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]);\n      scheduleA[1][2] = new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]);\n      scheduleA[1][3] = new Uint8Array([3, 7, 0xa, 9, 0xb, 8, 16 + 3]);\n      scheduleA[2] = new Array(4);\n      scheduleA[2][0] = new Uint8Array([4, 0, 0xd, 0xf, 0xc, 0xe, 8]);\n      scheduleA[2][1] = new Uint8Array([5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa]);\n      scheduleA[2][2] = new Uint8Array([6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9]);\n      scheduleA[2][3] = new Uint8Array([7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb]);\n      scheduleA[3] = new Array(4);\n      scheduleA[3][0] = new Uint8Array([0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0]);\n      scheduleA[3][1] = new Uint8Array([1, 4, 0, 2, 1, 3, 16 + 2]);\n      scheduleA[3][2] = new Uint8Array([2, 5, 7, 6, 5, 4, 16 + 1]);\n      scheduleA[3][3] = new Uint8Array([3, 7, 0xa, 9, 0xb, 8, 16 + 3]);\n      scheduleB = new Array(4);\n      scheduleB[0] = new Array(4);\n      scheduleB[0][0] = new Uint8Array([16 + 8, 16 + 9, 16 + 7, 16 + 6, 16 + 2]);\n      scheduleB[0][1] = new Uint8Array([16 + 0xa, 16 + 0xb, 16 + 5, 16 + 4, 16 + 6]);\n      scheduleB[0][2] = new Uint8Array([16 + 0xc, 16 + 0xd, 16 + 3, 16 + 2, 16 + 9]);\n      scheduleB[0][3] = new Uint8Array([16 + 0xe, 16 + 0xf, 16 + 1, 16 + 0, 16 + 0xc]);\n      scheduleB[1] = new Array(4);\n      scheduleB[1][0] = new Uint8Array([3, 2, 0xc, 0xd, 8]);\n      scheduleB[1][1] = new Uint8Array([1, 0, 0xe, 0xf, 0xd]);\n      scheduleB[1][2] = new Uint8Array([7, 6, 8, 9, 3]);\n      scheduleB[1][3] = new Uint8Array([5, 4, 0xa, 0xb, 7]);\n      scheduleB[2] = new Array(4);\n      scheduleB[2][0] = new Uint8Array([16 + 3, 16 + 2, 16 + 0xc, 16 + 0xd, 16 + 9]);\n      scheduleB[2][1] = new Uint8Array([16 + 1, 16 + 0, 16 + 0xe, 16 + 0xf, 16 + 0xc]);\n      scheduleB[2][2] = new Uint8Array([16 + 7, 16 + 6, 16 + 8, 16 + 9, 16 + 2]);\n      scheduleB[2][3] = new Uint8Array([16 + 5, 16 + 4, 16 + 0xa, 16 + 0xb, 16 + 6]);\n      scheduleB[3] = new Array(4);\n      scheduleB[3][0] = new Uint8Array([8, 9, 7, 6, 3]);\n      scheduleB[3][1] = new Uint8Array([0xa, 0xb, 5, 4, 7]);\n      scheduleB[3][2] = new Uint8Array([0xc, 0xd, 3, 2, 8]);\n      scheduleB[3][3] = new Uint8Array([0xe, 0xf, 1, 0, 0xd]);\n      this.scheduleA = scheduleA;\n      return this.scheduleB = scheduleB;\n    };\n\n    Global.prototype.init_sbox = function() {\n      var sBox;\n      sBox = new Array(8);\n      sBox[0] = new Uint32Array([0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a, 0x1e213f2f, 0x9c004dd3, 0x6003e540, 0xcf9fc949, 0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675, 0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e, 0x28683b6f, 0xc07fd059, 0xff2379c8, 0x775f50e2, 0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d, 0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f, 0x2abe32e1, 0xaa54166b, 0x22568e3a, 0xa2d341d0, 0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de, 0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7, 0xb82cbaef, 0xd751d159, 0x6ff7f0ed, 0x5a097a1f, 0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935, 0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d, 0xb7332290, 0xe93b159f, 0xb48ee411, 0x4bff345d, 0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165, 0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0c50, 0x882240f2, 0x0c6e4f38, 0xa4e4bfd7, 0x4f5ba272, 0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe, 0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d, 0x57538ad5, 0x6a390493, 0xe63d37e0, 0x2a54f6b3, 0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a, 0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167, 0x38901091, 0xc6b505eb, 0x84c7cb8c, 0x2ad75a0f, 0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291, 0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9, 0x6c00b32d, 0x73e2bb14, 0xa0bebc3c, 0x54623779, 0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6, 0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6c2, 0x81383f05, 0x6963c5c8, 0x76cb5ad6, 0xd49974c9, 0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511, 0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e, 0x31366241, 0x051ef495, 0xaa573b04, 0x4a805d8d, 0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e, 0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5, 0x6b54bfab, 0x2b0b1426, 0xab4cc9d7, 0x449ccd82, 0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324, 0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac, 0xeadf55b3, 0xd5bd9e98, 0xe31231b2, 0x2ad5ad6c, 0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f, 0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc, 0x7b5a41f0, 0xd37cfbad, 0x1b069505, 0x41ece491, 0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d, 0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de, 0xe01063da, 0x4736f464, 0x5ad328d8, 0xb347cc96, 0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a, 0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a, 0x3f04442f, 0x6188b153, 0xe0397a2e, 0x5727cb79, 0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d, 0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779, 0x4744ead4, 0xb11c3274, 0xdd24cb9e, 0x7e1c54bd, 0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755, 0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6, 0x580304f0, 0xca042cf1, 0x011a37ea, 0x8dbfaadb, 0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9, 0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0, 0x7c63b2cf, 0x700b45e1, 0xd5ea50f1, 0x85a92872, 0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79, 0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814c, 0x474d6ad7, 0x7c0c5e5c, 0xd1231959, 0x381b7298, 0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e, 0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571, 0x962bda1c, 0xe1e696ff, 0xb141ab08, 0x7cca89b9, 0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d, 0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf]);\n      sBox[1] = new Uint32Array([0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380, 0xfe61cf7a, 0xeec5207a, 0x55889c94, 0x72fc0651, 0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba, 0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3, 0xa0b52f7b, 0x59e83605, 0xee15b094, 0xe9ffd909, 0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb, 0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b, 0x01420ddb, 0xe4e7ef5b, 0x25a1ff41, 0xe180f806, 0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4, 0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b, 0xe113c85b, 0xacc40083, 0xd7503525, 0xf7ea615f, 0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359, 0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21, 0x071f6181, 0x39f7627f, 0x361e3084, 0xe4eb573b, 0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d, 0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c, 0x10843094, 0x2537a95e, 0xf46f6ffe, 0xa1ff3b1f, 0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34, 0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d, 0x8a45388c, 0x1d804366, 0x721d9bfd, 0xa58684bb, 0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4, 0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd, 0xc5d655dd, 0xeb667064, 0x77840b4d, 0xa1b6a801, 0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860, 0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755, 0xb5625dbf, 0x68561be6, 0x83ca6b94, 0x2d6ed23b, 0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709, 0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304, 0x81ed6f61, 0x20e74364, 0xb45e1378, 0xde18639b, 0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b, 0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c, 0x488cb402, 0x1ba4fe5b, 0xa4b09f6b, 0x1ca815cf, 0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9, 0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c, 0xee41e729, 0x6e1d2d7c, 0x50045286, 0x1e6685f3, 0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13, 0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9, 0xcdff33a6, 0xa02b1741, 0x7cbad9a2, 0x2180036f, 0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab, 0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6, 0xcdf0b680, 0x17844d3b, 0x31eef84d, 0x7e0824e4, 0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6, 0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43, 0xb3faec54, 0x157fd7fa, 0xef8579cc, 0xd152de58, 0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8, 0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906, 0xb8da230c, 0x80823028, 0xdcdef3c8, 0xd35fb171, 0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d, 0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89, 0x8b1c34bc, 0x301e16e6, 0x273be979, 0xb0ffeaa6, 0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b, 0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4, 0xdc8637a0, 0x16a7d3b1, 0x9fc393b7, 0xa7136eeb, 0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6, 0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e, 0xdb92f2fb, 0x5eea29cb, 0x145892f5, 0x91584f7f, 0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea, 0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249, 0xb284600c, 0xd835731d, 0xdcb1c647, 0xac4c56ea, 0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa, 0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd, 0x649da589, 0xa345415e, 0x5c038323, 0x3e5d3bb9, 0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef, 0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1]);\n      sBox[2] = new Uint32Array([0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907, 0x47607fff, 0x369fe44b, 0x8c1fc644, 0xaececa90, 0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae, 0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5, 0x11107d9f, 0x07647db9, 0xb2e3e4d4, 0x3d4f285e, 0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e, 0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc, 0x21fffcee, 0x825b1bfd, 0x9255c5ed, 0x1257a240, 0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e, 0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5, 0xa8c01db7, 0x579fc264, 0x67094f31, 0xf2bd3f5f, 0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b, 0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99, 0xa197c81c, 0x4a012d6e, 0xc5884a28, 0xccc36f71, 0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f, 0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04, 0xa747d2d0, 0x1651192e, 0xaf70bf3e, 0x58c31380, 0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82, 0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8, 0x8427f4a0, 0x1eac5790, 0x796fb449, 0x8252dc15, 0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504, 0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2, 0x23efe941, 0xa903f12e, 0x60270df2, 0x0276e4b6, 0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176, 0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e, 0x842f7d83, 0x340ce5c8, 0x96bbb682, 0x93b4b148, 0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d, 0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc, 0x8b907cee, 0xb51fd240, 0xe7c07ce3, 0xe566b4a1, 0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341, 0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c, 0xf76cedd9, 0xbda8229c, 0x127dadaa, 0x438a074e, 0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15, 0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51, 0x68cc7bfb, 0xd90f2788, 0x12490181, 0x5de5ffd4, 0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f, 0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b, 0x6d498623, 0x193cbcfa, 0x27627545, 0x825cf47a, 0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392, 0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b, 0x285ba1c8, 0x3c62f44f, 0x35c0eaa5, 0xe805d231, 0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b, 0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889, 0x694bcc11, 0x236a5cae, 0x12deca4d, 0x2c3f8cc5, 0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67, 0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45, 0x3a609437, 0xec00c9a9, 0x44715253, 0x0a874b49, 0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536, 0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d, 0x07478cd1, 0x006e1888, 0xa2e53f55, 0xb9e6d4bc, 0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d, 0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0, 0x947b0001, 0x570075d2, 0xf9bb88f8, 0x8942019e, 0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69, 0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767, 0xcf1febd2, 0x61efc8c2, 0xf1ac2571, 0xcc8239c2, 0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce, 0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49, 0x5727c148, 0x2be98a1d, 0x8ab41738, 0x20e1be24, 0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d, 0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0, 0x642b1e31, 0x9c305a00, 0x52bce688, 0x1b03588a, 0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5, 0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783]);\n      sBox[3] = new Uint32Array([0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298, 0x4a4f7bdb, 0x64ad8c57, 0x85510443, 0xfa020ed1, 0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120, 0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf, 0x28147f5f, 0x4fa2b8cd, 0xc9430040, 0x0cc32220, 0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15, 0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe, 0x1a05645f, 0x0c13fefe, 0x081b08ca, 0x05170121, 0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701, 0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25, 0xce84ffdf, 0xf5718801, 0x3dd64b04, 0xa26f263b, 0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5, 0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93, 0xd3772061, 0x11b638e1, 0x72500e03, 0xf80eb2bb, 0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746, 0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5, 0x4d351805, 0x7f3d5ce3, 0xa6c866c6, 0x5d5bcca9, 0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d, 0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb, 0x022083b8, 0x3fb6180c, 0x18f8931e, 0x281658e6, 0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c, 0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23, 0x69dead38, 0x1574ca16, 0xdf871b62, 0x211c40b7, 0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003, 0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340, 0x557be8de, 0x00eae4a7, 0x0ce5c2ec, 0x4db4bba6, 0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327, 0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119, 0x6e85cb75, 0xbe07c002, 0xc2325577, 0x893ff4ec, 0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24, 0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205, 0xaac9548a, 0xeca1d7c7, 0x041afa32, 0x1d16625a, 0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031, 0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79, 0x026a4ceb, 0x52437eff, 0x2f8f76b4, 0x0df980a5, 0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df, 0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c, 0x1741a254, 0xe5b6a035, 0x213d42f6, 0x2c1c7c26, 0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69, 0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab, 0x63315c21, 0x5e0a72ec, 0x49bafefd, 0x187908d9, 0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7, 0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff, 0x71eae2a1, 0x1f9af36e, 0xcfcbd12f, 0xc1de8417, 0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3, 0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2, 0x6f7de532, 0x58fd7eb6, 0xd01ee900, 0x24adffc2, 0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2, 0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff, 0x29908415, 0x7fbb977f, 0xaf9eb3db, 0x29c9ed2a, 0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091, 0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919, 0x77079103, 0xdea03af6, 0x78a8565e, 0xdee356df, 0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef, 0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf, 0xafe67afb, 0xf470c4b2, 0xf3e0eb5b, 0xd6cc9876, 0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367, 0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab, 0xb5676e69, 0x9bd3ddda, 0xdf7e052f, 0xdb25701c, 0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04, 0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43, 0x41823979, 0x932bcdf6, 0xb657c34d, 0x4edfd282, 0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e, 0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2]);\n      sBox[4] = new Uint32Array([0x7ec90c04, 0x2c6e74b9, 0x9b0e66df, 0xa6337911, 0xb86a7fff, 0x1dd358f5, 0x44dd9d44, 0x1731167f, 0x08fbf1fa, 0xe7f511cc, 0xd2051b00, 0x735aba00, 0x2ab722d8, 0x386381cb, 0xacf6243a, 0x69befd7a, 0xe6a2e77f, 0xf0c720cd, 0xc4494816, 0xccf5c180, 0x38851640, 0x15b0a848, 0xe68b18cb, 0x4caadeff, 0x5f480a01, 0x0412b2aa, 0x259814fc, 0x41d0efe2, 0x4e40b48d, 0x248eb6fb, 0x8dba1cfe, 0x41a99b02, 0x1a550a04, 0xba8f65cb, 0x7251f4e7, 0x95a51725, 0xc106ecd7, 0x97a5980a, 0xc539b9aa, 0x4d79fe6a, 0xf2f3f763, 0x68af8040, 0xed0c9e56, 0x11b4958b, 0xe1eb5a88, 0x8709e6b0, 0xd7e07156, 0x4e29fea7, 0x6366e52d, 0x02d1c000, 0xc4ac8e05, 0x9377f571, 0x0c05372a, 0x578535f2, 0x2261be02, 0xd642a0c9, 0xdf13a280, 0x74b55bd2, 0x682199c0, 0xd421e5ec, 0x53fb3ce8, 0xc8adedb3, 0x28a87fc9, 0x3d959981, 0x5c1ff900, 0xfe38d399, 0x0c4eff0b, 0x062407ea, 0xaa2f4fb1, 0x4fb96976, 0x90c79505, 0xb0a8a774, 0xef55a1ff, 0xe59ca2c2, 0xa6b62d27, 0xe66a4263, 0xdf65001f, 0x0ec50966, 0xdfdd55bc, 0x29de0655, 0x911e739a, 0x17af8975, 0x32c7911c, 0x89f89468, 0x0d01e980, 0x524755f4, 0x03b63cc9, 0x0cc844b2, 0xbcf3f0aa, 0x87ac36e9, 0xe53a7426, 0x01b3d82b, 0x1a9e7449, 0x64ee2d7e, 0xcddbb1da, 0x01c94910, 0xb868bf80, 0x0d26f3fd, 0x9342ede7, 0x04a5c284, 0x636737b6, 0x50f5b616, 0xf24766e3, 0x8eca36c1, 0x136e05db, 0xfef18391, 0xfb887a37, 0xd6e7f7d4, 0xc7fb7dc9, 0x3063fcdf, 0xb6f589de, 0xec2941da, 0x26e46695, 0xb7566419, 0xf654efc5, 0xd08d58b7, 0x48925401, 0xc1bacb7f, 0xe5ff550f, 0xb6083049, 0x5bb5d0e8, 0x87d72e5a, 0xab6a6ee1, 0x223a66ce, 0xc62bf3cd, 0x9e0885f9, 0x68cb3e47, 0x086c010f, 0xa21de820, 0xd18b69de, 0xf3f65777, 0xfa02c3f6, 0x407edac3, 0xcbb3d550, 0x1793084d, 0xb0d70eba, 0x0ab378d5, 0xd951fb0c, 0xded7da56, 0x4124bbe4, 0x94ca0b56, 0x0f5755d1, 0xe0e1e56e, 0x6184b5be, 0x580a249f, 0x94f74bc0, 0xe327888e, 0x9f7b5561, 0xc3dc0280, 0x05687715, 0x646c6bd7, 0x44904db3, 0x66b4f0a3, 0xc0f1648a, 0x697ed5af, 0x49e92ff6, 0x309e374f, 0x2cb6356a, 0x85808573, 0x4991f840, 0x76f0ae02, 0x083be84d, 0x28421c9a, 0x44489406, 0x736e4cb8, 0xc1092910, 0x8bc95fc6, 0x7d869cf4, 0x134f616f, 0x2e77118d, 0xb31b2be1, 0xaa90b472, 0x3ca5d717, 0x7d161bba, 0x9cad9010, 0xaf462ba2, 0x9fe459d2, 0x45d34559, 0xd9f2da13, 0xdbc65487, 0xf3e4f94e, 0x176d486f, 0x097c13ea, 0x631da5c7, 0x445f7382, 0x175683f4, 0xcdc66a97, 0x70be0288, 0xb3cdcf72, 0x6e5dd2f3, 0x20936079, 0x459b80a5, 0xbe60e2db, 0xa9c23101, 0xeba5315c, 0x224e42f2, 0x1c5c1572, 0xf6721b2c, 0x1ad2fff3, 0x8c25404e, 0x324ed72f, 0x4067b7fd, 0x0523138e, 0x5ca3bc78, 0xdc0fd66e, 0x75922283, 0x784d6b17, 0x58ebb16e, 0x44094f85, 0x3f481d87, 0xfcfeae7b, 0x77b5ff76, 0x8c2302bf, 0xaaf47556, 0x5f46b02a, 0x2b092801, 0x3d38f5f7, 0x0ca81f36, 0x52af4a8a, 0x66d5e7c0, 0xdf3b0874, 0x95055110, 0x1b5ad7a8, 0xf61ed5ad, 0x6cf6e479, 0x20758184, 0xd0cefa65, 0x88f7be58, 0x4a046826, 0x0ff6f8f3, 0xa09c7f70, 0x5346aba0, 0x5ce96c28, 0xe176eda3, 0x6bac307f, 0x376829d2, 0x85360fa9, 0x17e3fe2a, 0x24b79767, 0xf5a96b20, 0xd6cd2595, 0x68ff1ebf, 0x7555442c, 0xf19f06be, 0xf9e0659a, 0xeeb9491d, 0x34010718, 0xbb30cab8, 0xe822fe15, 0x88570983, 0x750e6249, 0xda627e55, 0x5e76ffa8, 0xb1534546, 0x6d47de08, 0xefe9e7d4]);\n      sBox[5] = new Uint32Array([0xf6fa8f9d, 0x2cac6ce1, 0x4ca34867, 0xe2337f7c, 0x95db08e7, 0x016843b4, 0xeced5cbc, 0x325553ac, 0xbf9f0960, 0xdfa1e2ed, 0x83f0579d, 0x63ed86b9, 0x1ab6a6b8, 0xde5ebe39, 0xf38ff732, 0x8989b138, 0x33f14961, 0xc01937bd, 0xf506c6da, 0xe4625e7e, 0xa308ea99, 0x4e23e33c, 0x79cbd7cc, 0x48a14367, 0xa3149619, 0xfec94bd5, 0xa114174a, 0xeaa01866, 0xa084db2d, 0x09a8486f, 0xa888614a, 0x2900af98, 0x01665991, 0xe1992863, 0xc8f30c60, 0x2e78ef3c, 0xd0d51932, 0xcf0fec14, 0xf7ca07d2, 0xd0a82072, 0xfd41197e, 0x9305a6b0, 0xe86be3da, 0x74bed3cd, 0x372da53c, 0x4c7f4448, 0xdab5d440, 0x6dba0ec3, 0x083919a7, 0x9fbaeed9, 0x49dbcfb0, 0x4e670c53, 0x5c3d9c01, 0x64bdb941, 0x2c0e636a, 0xba7dd9cd, 0xea6f7388, 0xe70bc762, 0x35f29adb, 0x5c4cdd8d, 0xf0d48d8c, 0xb88153e2, 0x08a19866, 0x1ae2eac8, 0x284caf89, 0xaa928223, 0x9334be53, 0x3b3a21bf, 0x16434be3, 0x9aea3906, 0xefe8c36e, 0xf890cdd9, 0x80226dae, 0xc340a4a3, 0xdf7e9c09, 0xa694a807, 0x5b7c5ecc, 0x221db3a6, 0x9a69a02f, 0x68818a54, 0xceb2296f, 0x53c0843a, 0xfe893655, 0x25bfe68a, 0xb4628abc, 0xcf222ebf, 0x25ac6f48, 0xa9a99387, 0x53bddb65, 0xe76ffbe7, 0xe967fd78, 0x0ba93563, 0x8e342bc1, 0xe8a11be9, 0x4980740d, 0xc8087dfc, 0x8de4bf99, 0xa11101a0, 0x7fd37975, 0xda5a26c0, 0xe81f994f, 0x9528cd89, 0xfd339fed, 0xb87834bf, 0x5f04456d, 0x22258698, 0xc9c4c83b, 0x2dc156be, 0x4f628daa, 0x57f55ec5, 0xe2220abe, 0xd2916ebf, 0x4ec75b95, 0x24f2c3c0, 0x42d15d99, 0xcd0d7fa0, 0x7b6e27ff, 0xa8dc8af0, 0x7345c106, 0xf41e232f, 0x35162386, 0xe6ea8926, 0x3333b094, 0x157ec6f2, 0x372b74af, 0x692573e4, 0xe9a9d848, 0xf3160289, 0x3a62ef1d, 0xa787e238, 0xf3a5f676, 0x74364853, 0x20951063, 0x4576698d, 0xb6fad407, 0x592af950, 0x36f73523, 0x4cfb6e87, 0x7da4cec0, 0x6c152daa, 0xcb0396a8, 0xc50dfe5d, 0xfcd707ab, 0x0921c42f, 0x89dff0bb, 0x5fe2be78, 0x448f4f33, 0x754613c9, 0x2b05d08d, 0x48b9d585, 0xdc049441, 0xc8098f9b, 0x7dede786, 0xc39a3373, 0x42410005, 0x6a091751, 0x0ef3c8a6, 0x890072d6, 0x28207682, 0xa9a9f7be, 0xbf32679d, 0xd45b5b75, 0xb353fd00, 0xcbb0e358, 0x830f220a, 0x1f8fb214, 0xd372cf08, 0xcc3c4a13, 0x8cf63166, 0x061c87be, 0x88c98f88, 0x6062e397, 0x47cf8e7a, 0xb6c85283, 0x3cc2acfb, 0x3fc06976, 0x4e8f0252, 0x64d8314d, 0xda3870e3, 0x1e665459, 0xc10908f0, 0x513021a5, 0x6c5b68b7, 0x822f8aa0, 0x3007cd3e, 0x74719eef, 0xdc872681, 0x073340d4, 0x7e432fd9, 0x0c5ec241, 0x8809286c, 0xf592d891, 0x08a930f6, 0x957ef305, 0xb7fbffbd, 0xc266e96f, 0x6fe4ac98, 0xb173ecc0, 0xbc60b42a, 0x953498da, 0xfba1ae12, 0x2d4bd736, 0x0f25faab, 0xa4f3fceb, 0xe2969123, 0x257f0c3d, 0x9348af49, 0x361400bc, 0xe8816f4a, 0x3814f200, 0xa3f94043, 0x9c7a54c2, 0xbc704f57, 0xda41e7f9, 0xc25ad33a, 0x54f4a084, 0xb17f5505, 0x59357cbe, 0xedbd15c8, 0x7f97c5ab, 0xba5ac7b5, 0xb6f6deaf, 0x3a479c3a, 0x5302da25, 0x653d7e6a, 0x54268d49, 0x51a477ea, 0x5017d55b, 0xd7d25d88, 0x44136c76, 0x0404a8c8, 0xb8e5a121, 0xb81a928a, 0x60ed5869, 0x97c55b96, 0xeaec991b, 0x29935913, 0x01fdb7f1, 0x088e8dfa, 0x9ab6f6f5, 0x3b4cbf9f, 0x4a5de3ab, 0xe6051d35, 0xa0e1d855, 0xd36b4cf1, 0xf544edeb, 0xb0e93524, 0xbebb8fbd, 0xa2d762cf, 0x49c92f54, 0x38b5f331, 0x7128a454, 0x48392905, 0xa65b1db8, 0x851c97bd, 0xd675cf2f]);\n      sBox[6] = new Uint32Array([0x85e04019, 0x332bf567, 0x662dbfff, 0xcfc65693, 0x2a8d7f6f, 0xab9bc912, 0xde6008a1, 0x2028da1f, 0x0227bce7, 0x4d642916, 0x18fac300, 0x50f18b82, 0x2cb2cb11, 0xb232e75c, 0x4b3695f2, 0xb28707de, 0xa05fbcf6, 0xcd4181e9, 0xe150210c, 0xe24ef1bd, 0xb168c381, 0xfde4e789, 0x5c79b0d8, 0x1e8bfd43, 0x4d495001, 0x38be4341, 0x913cee1d, 0x92a79c3f, 0x089766be, 0xbaeeadf4, 0x1286becf, 0xb6eacb19, 0x2660c200, 0x7565bde4, 0x64241f7a, 0x8248dca9, 0xc3b3ad66, 0x28136086, 0x0bd8dfa8, 0x356d1cf2, 0x107789be, 0xb3b2e9ce, 0x0502aa8f, 0x0bc0351e, 0x166bf52a, 0xeb12ff82, 0xe3486911, 0xd34d7516, 0x4e7b3aff, 0x5f43671b, 0x9cf6e037, 0x4981ac83, 0x334266ce, 0x8c9341b7, 0xd0d854c0, 0xcb3a6c88, 0x47bc2829, 0x4725ba37, 0xa66ad22b, 0x7ad61f1e, 0x0c5cbafa, 0x4437f107, 0xb6e79962, 0x42d2d816, 0x0a961288, 0xe1a5c06e, 0x13749e67, 0x72fc081a, 0xb1d139f7, 0xf9583745, 0xcf19df58, 0xbec3f756, 0xc06eba30, 0x07211b24, 0x45c28829, 0xc95e317f, 0xbc8ec511, 0x38bc46e9, 0xc6e6fa14, 0xbae8584a, 0xad4ebc46, 0x468f508b, 0x7829435f, 0xf124183b, 0x821dba9f, 0xaff60ff4, 0xea2c4e6d, 0x16e39264, 0x92544a8b, 0x009b4fc3, 0xaba68ced, 0x9ac96f78, 0x06a5b79a, 0xb2856e6e, 0x1aec3ca9, 0xbe838688, 0x0e0804e9, 0x55f1be56, 0xe7e5363b, 0xb3a1f25d, 0xf7debb85, 0x61fe033c, 0x16746233, 0x3c034c28, 0xda6d0c74, 0x79aac56c, 0x3ce4e1ad, 0x51f0c802, 0x98f8f35a, 0x1626a49f, 0xeed82b29, 0x1d382fe3, 0x0c4fb99a, 0xbb325778, 0x3ec6d97b, 0x6e77a6a9, 0xcb658b5c, 0xd45230c7, 0x2bd1408b, 0x60c03eb7, 0xb9068d78, 0xa33754f4, 0xf430c87d, 0xc8a71302, 0xb96d8c32, 0xebd4e7be, 0xbe8b9d2d, 0x7979fb06, 0xe7225308, 0x8b75cf77, 0x11ef8da4, 0xe083c858, 0x8d6b786f, 0x5a6317a6, 0xfa5cf7a0, 0x5dda0033, 0xf28ebfb0, 0xf5b9c310, 0xa0eac280, 0x08b9767a, 0xa3d9d2b0, 0x79d34217, 0x021a718d, 0x9ac6336a, 0x2711fd60, 0x438050e3, 0x069908a8, 0x3d7fedc4, 0x826d2bef, 0x4eeb8476, 0x488dcf25, 0x36c9d566, 0x28e74e41, 0xc2610aca, 0x3d49a9cf, 0xbae3b9df, 0xb65f8de6, 0x92aeaf64, 0x3ac7d5e6, 0x9ea80509, 0xf22b017d, 0xa4173f70, 0xdd1e16c3, 0x15e0d7f9, 0x50b1b887, 0x2b9f4fd5, 0x625aba82, 0x6a017962, 0x2ec01b9c, 0x15488aa9, 0xd716e740, 0x40055a2c, 0x93d29a22, 0xe32dbf9a, 0x058745b9, 0x3453dc1e, 0xd699296e, 0x496cff6f, 0x1c9f4986, 0xdfe2ed07, 0xb87242d1, 0x19de7eae, 0x053e561a, 0x15ad6f8c, 0x66626c1c, 0x7154c24c, 0xea082b2a, 0x93eb2939, 0x17dcb0f0, 0x58d4f2ae, 0x9ea294fb, 0x52cf564c, 0x9883fe66, 0x2ec40581, 0x763953c3, 0x01d6692e, 0xd3a0c108, 0xa1e7160e, 0xe4f2dfa6, 0x693ed285, 0x74904698, 0x4c2b0edd, 0x4f757656, 0x5d393378, 0xa132234f, 0x3d321c5d, 0xc3f5e194, 0x4b269301, 0xc79f022f, 0x3c997e7e, 0x5e4f9504, 0x3ffafbbd, 0x76f7ad0e, 0x296693f4, 0x3d1fce6f, 0xc61e45be, 0xd3b5ab34, 0xf72bf9b7, 0x1b0434c0, 0x4e72b567, 0x5592a33d, 0xb5229301, 0xcfd2a87f, 0x60aeb767, 0x1814386b, 0x30bcc33d, 0x38a0c07d, 0xfd1606f2, 0xc363519b, 0x589dd390, 0x5479f8e6, 0x1cb8d647, 0x97fd61a9, 0xea7759f4, 0x2d57539d, 0x569a58cf, 0xe84e63ad, 0x462e1b78, 0x6580f87e, 0xf3817914, 0x91da55f4, 0x40a230f3, 0xd1988f35, 0xb6e318d2, 0x3ffa50bc, 0x3d40f021, 0xc3c0bdae, 0x4958c24c, 0x518f36b2, 0x84b1d370, 0x0fedce83, 0x878ddada, 0xf2a279c7, 0x94e01be8, 0x90716f4b, 0x954b8aa3]);\n      sBox[7] = new Uint32Array([0xe216300d, 0xbbddfffc, 0xa7ebdabd, 0x35648095, 0x7789f8b7, 0xe6c1121b, 0x0e241600, 0x052ce8b5, 0x11a9cfb0, 0xe5952f11, 0xece7990a, 0x9386d174, 0x2a42931c, 0x76e38111, 0xb12def3a, 0x37ddddfc, 0xde9adeb1, 0x0a0cc32c, 0xbe197029, 0x84a00940, 0xbb243a0f, 0xb4d137cf, 0xb44e79f0, 0x049eedfd, 0x0b15a15d, 0x480d3168, 0x8bbbde5a, 0x669ded42, 0xc7ece831, 0x3f8f95e7, 0x72df191b, 0x7580330d, 0x94074251, 0x5c7dcdfa, 0xabbe6d63, 0xaa402164, 0xb301d40a, 0x02e7d1ca, 0x53571dae, 0x7a3182a2, 0x12a8ddec, 0xfdaa335d, 0x176f43e8, 0x71fb46d4, 0x38129022, 0xce949ad4, 0xb84769ad, 0x965bd862, 0x82f3d055, 0x66fb9767, 0x15b80b4e, 0x1d5b47a0, 0x4cfde06f, 0xc28ec4b8, 0x57e8726e, 0x647a78fc, 0x99865d44, 0x608bd593, 0x6c200e03, 0x39dc5ff6, 0x5d0b00a3, 0xae63aff2, 0x7e8bd632, 0x70108c0c, 0xbbd35049, 0x2998df04, 0x980cf42a, 0x9b6df491, 0x9e7edd53, 0x06918548, 0x58cb7e07, 0x3b74ef2e, 0x522fffb1, 0xd24708cc, 0x1c7e27cd, 0xa4eb215b, 0x3cf1d2e2, 0x19b47a38, 0x424f7618, 0x35856039, 0x9d17dee7, 0x27eb35e6, 0xc9aff67b, 0x36baf5b8, 0x09c467cd, 0xc18910b1, 0xe11dbf7b, 0x06cd1af8, 0x7170c608, 0x2d5e3354, 0xd4de495a, 0x64c6d006, 0xbcc0c62c, 0x3dd00db3, 0x708f8f34, 0x77d51b42, 0x264f620f, 0x24b8d2bf, 0x15c1b79e, 0x46a52564, 0xf8d7e54e, 0x3e378160, 0x7895cda5, 0x859c15a5, 0xe6459788, 0xc37bc75f, 0xdb07ba0c, 0x0676a3ab, 0x7f229b1e, 0x31842e7b, 0x24259fd7, 0xf8bef472, 0x835ffcb8, 0x6df4c1f2, 0x96f5b195, 0xfd0af0fc, 0xb0fe134c, 0xe2506d3d, 0x4f9b12ea, 0xf215f225, 0xa223736f, 0x9fb4c428, 0x25d04979, 0x34c713f8, 0xc4618187, 0xea7a6e98, 0x7cd16efc, 0x1436876c, 0xf1544107, 0xbedeee14, 0x56e9af27, 0xa04aa441, 0x3cf7c899, 0x92ecbae6, 0xdd67016d, 0x151682eb, 0xa842eedf, 0xfdba60b4, 0xf1907b75, 0x20e3030f, 0x24d8c29e, 0xe139673b, 0xefa63fb8, 0x71873054, 0xb6f2cf3b, 0x9f326442, 0xcb15a4cc, 0xb01a4504, 0xf1e47d8d, 0x844a1be5, 0xbae7dfdc, 0x42cbda70, 0xcd7dae0a, 0x57e85b7a, 0xd53f5af6, 0x20cf4d8c, 0xcea4d428, 0x79d130a4, 0x3486ebfb, 0x33d3cddc, 0x77853b53, 0x37effcb5, 0xc5068778, 0xe580b3e6, 0x4e68b8f4, 0xc5c8b37e, 0x0d809ea2, 0x398feb7c, 0x132a4f94, 0x43b7950e, 0x2fee7d1c, 0x223613bd, 0xdd06caa2, 0x37df932b, 0xc4248289, 0xacf3ebc3, 0x5715f6b7, 0xef3478dd, 0xf267616f, 0xc148cbe4, 0x9052815e, 0x5e410fab, 0xb48a2465, 0x2eda7fa4, 0xe87b40e4, 0xe98ea084, 0x5889e9e1, 0xefd390fc, 0xdd07d35b, 0xdb485694, 0x38d7e5b2, 0x57720101, 0x730edebc, 0x5b643113, 0x94917e4f, 0x503c2fba, 0x646f1282, 0x7523d24a, 0xe0779695, 0xf9c17a8f, 0x7a5b2121, 0xd187b896, 0x29263a4d, 0xba510cdf, 0x81f47c9f, 0xad1163ed, 0xea7b5965, 0x1a00726e, 0x11403092, 0x00da6d77, 0x4a0cdd61, 0xad1f4603, 0x605bdfb0, 0x9eedc364, 0x22ebe6a8, 0xcee7d28a, 0xa0e736a0, 0x5564a6b9, 0x10853209, 0xc7eb8f37, 0x2de705ca, 0x8951570f, 0xdf09822b, 0xbd691a6c, 0xaa12e4f2, 0x87451c0f, 0xe0f6a27a, 0x3ada4819, 0x4cf1764f, 0x0d771c2b, 0x67cdb156, 0x350d8384, 0x5938fa0f, 0x42399ef3, 0x36997b07, 0x0e84093d, 0x4aa93e61, 0x8360d87b, 0x1fa98b0c, 0x1149382c, 0xe97625a5, 0x0614d1b7, 0x0e25244b, 0x0c768347, 0x589e8d82, 0x0d2059d1, 0xa466bb1e, 0xf8da0a82, 0x04f19130, 0xba6e4ec0, 0x99265164, 0x1ee7230d, 0x50b2ad80, 0xeaee6801, 0x8db2a283, 0xea8bf59e]);\n      return this.sBox = sBox;\n    };\n\n    return Global;\n\n  })();\n\n  G = new Global();\n\n  CAST5 = (function() {\n    CAST5.blockSize = 8;\n\n    CAST5.prototype.blockSize = CAST5.blockSize;\n\n    CAST5.keySize = 16;\n\n    CAST5.prototype.keySize = CAST5.keySize;\n\n    function CAST5(key) {\n      var n;\n      this.masking = new Array(16);\n      this.rotate = new Array(16);\n      this.reset();\n      if (key.sigBytes !== (n = this.keySize)) {\n        throw new Error(\"key must be \" + n + \" bytes\");\n      }\n      this.keySchedule(key);\n    }\n\n    CAST5.prototype.reset = function() {\n      var i, _i, _results;\n      _results = [];\n      for (i = _i = 0; _i < 16; i = ++_i) {\n        this.masking[i] = 0;\n        _results.push(this.rotate[i] = 0);\n      }\n      return _results;\n    };\n\n    CAST5.prototype.encryptBlock = function(words, offset) {\n      var bytes, res;\n      if (offset == null) {\n        offset = 0;\n      }\n      bytes = ui32a_to_ui8a(words);\n      res = this._encrypt_ui8a(bytes);\n      return ui8a_to_ui32a(res, words);\n    };\n\n    CAST5.prototype.decryptBlock = function(words, offset) {\n      var bytes, res;\n      if (offset == null) {\n        offset = 0;\n      }\n      bytes = ui32a_to_ui8a(words);\n      res = this._decrypt_ui8a(bytes);\n      return ui8a_to_ui32a(res, words);\n    };\n\n    CAST5.prototype._encrypt_ui8a = function(src) {\n      var dst, i, l, len, r, t, _i;\n      len = src.length;\n      dst = new Uint8Array(len);\n      for (i = _i = 0; _i < len; i = _i += 8) {\n        l = src[i] << 24 | src[i + 1] << 16 | src[i + 2] << 8 | src[i + 3];\n        r = src[i + 4] << 24 | src[i + 5] << 16 | src[i + 6] << 8 | src[i + 7];\n        t = r;\n        r = l ^ this.f1(r, this.masking[0], this.rotate[0]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[1], this.rotate[1]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[2], this.rotate[2]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[3], this.rotate[3]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[4], this.rotate[4]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[5], this.rotate[5]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[6], this.rotate[6]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[7], this.rotate[7]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[8], this.rotate[8]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[9], this.rotate[9]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[10], this.rotate[10]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[11], this.rotate[11]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[12], this.rotate[12]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[13], this.rotate[13]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[14], this.rotate[14]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[15], this.rotate[15]);\n        l = t;\n        dst[i] = (r >>> 24) & 255;\n        dst[i + 1] = (r >>> 16) & 255;\n        dst[i + 2] = (r >>> 8) & 255;\n        dst[i + 3] = r & 255;\n        dst[i + 4] = (l >>> 24) & 255;\n        dst[i + 5] = (l >>> 16) & 255;\n        dst[i + 6] = (l >>> 8) & 255;\n        dst[i + 7] = l & 255;\n      }\n      return dst;\n    };\n\n    CAST5.prototype._decrypt_ui8a = function(src) {\n      var dst, i, l, len, r, t, _i;\n      len = src.length;\n      dst = new Uint8Array(len);\n      for (i = _i = 0; _i < len; i = _i += 8) {\n        l = src[i] << 24 | src[i + 1] << 16 | src[i + 2] << 8 | src[i + 3];\n        r = src[i + 4] << 24 | src[i + 5] << 16 | src[i + 6] << 8 | src[i + 7];\n        t = r;\n        r = l ^ this.f1(r, this.masking[15], this.rotate[15]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[14], this.rotate[14]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[13], this.rotate[13]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[12], this.rotate[12]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[11], this.rotate[11]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[10], this.rotate[10]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[9], this.rotate[9]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[8], this.rotate[8]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[7], this.rotate[7]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[6], this.rotate[6]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[5], this.rotate[5]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[4], this.rotate[4]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[3], this.rotate[3]);\n        l = t;\n        t = r;\n        r = l ^ this.f3(r, this.masking[2], this.rotate[2]);\n        l = t;\n        t = r;\n        r = l ^ this.f2(r, this.masking[1], this.rotate[1]);\n        l = t;\n        t = r;\n        r = l ^ this.f1(r, this.masking[0], this.rotate[0]);\n        l = t;\n        dst[i] = (r >>> 24) & 255;\n        dst[i + 1] = (r >>> 16) & 255;\n        dst[i + 2] = (r >>> 8) & 255;\n        dst[i + 3] = r & 255;\n        dst[i + 4] = (l >>> 24) & 255;\n        dst[i + 5] = (l >> 16) & 255;\n        dst[i + 6] = (l >> 8) & 255;\n        dst[i + 7] = l & 255;\n      }\n      return dst;\n    };\n\n    CAST5.prototype.keySchedule = function(key) {\n      var a, b, half, i, j, k, ki, kw, round, t, w, x, _i, _j, _k, _l, _m, _results;\n      t = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = key.words;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          kw = _ref1[_i];\n          _results.push(kw);\n        }\n        return _results;\n      })();\n      k = new Array(32);\n      x = [6, 7, 4, 5];\n      ki = 0;\n      for (half = _i = 0; _i < 2; half = ++_i) {\n        for (round = _j = 0; _j < 4; round = ++_j) {\n          for (j = _k = 0; _k < 4; j = ++_k) {\n            a = G.scheduleA[round][j];\n            w = t[a[1]];\n            w ^= G.sBox[4][(t[a[2] >>> 2] >>> (24 - 8 * (a[2] & 3))) & 0xff];\n            w ^= G.sBox[5][(t[a[3] >>> 2] >>> (24 - 8 * (a[3] & 3))) & 0xff];\n            w ^= G.sBox[6][(t[a[4] >>> 2] >>> (24 - 8 * (a[4] & 3))) & 0xff];\n            w ^= G.sBox[7][(t[a[5] >>> 2] >>> (24 - 8 * (a[5] & 3))) & 0xff];\n            w ^= G.sBox[x[j]][(t[a[6] >>> 2] >>> (24 - 8 * (a[6] & 3))) & 0xff];\n            t[a[0]] = w;\n          }\n          for (j = _l = 0; _l < 4; j = ++_l) {\n            b = G.scheduleB[round][j];\n            w = G.sBox[4][(t[b[0] >>> 2] >>> (24 - 8 * (b[0] & 3))) & 0xff];\n            w ^= G.sBox[5][(t[b[1] >>> 2] >>> (24 - 8 * (b[1] & 3))) & 0xff];\n            w ^= G.sBox[6][(t[b[2] >>> 2] >>> (24 - 8 * (b[2] & 3))) & 0xff];\n            w ^= G.sBox[7][(t[b[3] >>> 2] >>> (24 - 8 * (b[3] & 3))) & 0xff];\n            w ^= G.sBox[4 + j][(t[b[4] >>> 2] >>> (24 - 8 * (b[4] & 3))) & 0xff];\n            k[ki] = w;\n            ki++;\n          }\n        }\n      }\n      _results = [];\n      for (i = _m = 0; _m < 16; i = ++_m) {\n        this.masking[i] = k[i];\n        _results.push(this.rotate[i] = k[16 + i] & 0x1f);\n      }\n      return _results;\n    };\n\n    CAST5.prototype.f1 = function(d, m, r) {\n      var I, t;\n      t = m + d;\n      I = (t << r) | (t >>> (32 - r));\n      return ((G.sBox[0][I >>> 24] ^ G.sBox[1][(I >>> 16) & 255]) - G.sBox[2][(I >>> 8) & 255]) + G.sBox[3][I & 255];\n    };\n\n    CAST5.prototype.f2 = function(d, m, r) {\n      var I, t;\n      t = m ^ d;\n      I = (t << r) | (t >>> (32 - r));\n      return ((G.sBox[0][I >>> 24] - G.sBox[1][(I >>> 16) & 255]) + G.sBox[2][(I >>> 8) & 255]) ^ G.sBox[3][I & 255];\n    };\n\n    CAST5.prototype.f3 = function(d, m, r) {\n      var I, t;\n      t = m - d;\n      I = (t << r) | (t >>> (32 - r));\n      return ((G.sBox[0][I >>> 24] + G.sBox[1][(I >>> 16) & 255]) ^ G.sBox[2][(I >>> 8) & 255]) - G.sBox[3][I & 255];\n    };\n\n    return CAST5;\n\n  })();\n\n  exports.CAST5 = CAST5;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/rfc3394.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var IV, WordArray, bufeq_secure, setup, split64, unwrap, wrap;\n\n  WordArray = require('triplesec').WordArray;\n\n  bufeq_secure = require('./util').bufeq_secure;\n\n  IV = WordArray.from_hex(\"A6A6A6A6A6A6A6A6\");\n\n  split64 = function(wa) {\n    return wa.split(wa.words.length >> 1);\n  };\n\n  exports.wrap = wrap = function(_arg) {\n    var A, AES, B, C, P, R, cipher, err, i, j, key, plaintext, r, t, _i, _j, _k, _len, _len1, _ref;\n    plaintext = _arg.plaintext, key = _arg.key, cipher = _arg.cipher;\n    _ref = setup({\n      input: plaintext,\n      key: key,\n      cipher: cipher\n    }), err = _ref[0], P = _ref[1], AES = _ref[2];\n    if (err != null) {\n      throw err;\n    }\n    A = IV;\n    R = P;\n    t = new WordArray([0, 0]);\n    for (j = _i = 0; _i < 6; j = ++_i) {\n      for (i = _j = 0, _len = R.length; _j < _len; i = ++_j) {\n        r = R[i];\n        t.words[1]++;\n        B = A.clone().concat(r);\n        AES.encryptBlock(B.words);\n        A = B.slice(0, 2);\n        R[i] = B.slice(2, 4);\n        A.xor(t, {});\n      }\n    }\n    C = A;\n    for (_k = 0, _len1 = R.length; _k < _len1; _k++) {\n      r = R[_k];\n      C.concat(r);\n    }\n    return C.to_buffer();\n  };\n\n  setup = function(_arg) {\n    var AES, K, P, a, b, cipher, err, input, key, klass;\n    input = _arg.input, key = _arg.key, cipher = _arg.cipher;\n    P = split64(WordArray.from_buffer(input));\n    K = WordArray.from_buffer(key);\n    klass = cipher.klass;\n    AES = new klass(K);\n    err = null;\n    if ((a = cipher.key_size) !== (b = key.length)) {\n      err = new Error(\"Bad key, needed \" + a + \" bytes, but got \" + b);\n    }\n    return [err, P, AES];\n  };\n\n  exports.unwrap = unwrap = function(_arg) {\n    var A, AES, B, C, P, R, cipher, ciphertext, err, i, j, key, n, r, t, _i, _j, _k, _len, _ref;\n    ciphertext = _arg.ciphertext, key = _arg.key, cipher = _arg.cipher;\n    _ref = setup({\n      input: ciphertext,\n      key: key,\n      cipher: cipher\n    }), err = _ref[0], C = _ref[1], AES = _ref[2], n = _ref[3];\n    if (err != null) {\n      return [err, null];\n    }\n    A = C[0];\n    R = C.slice(1);\n    t = new WordArray([0, 6 * R.length]);\n    for (j = _i = 0; _i < 6; j = ++_i) {\n      for (i = _j = R.length - 1; _j >= 0; i = _j += -1) {\n        r = R[i];\n        A.xor(t, {});\n        B = A.clone().concat(r);\n        AES.decryptBlock(B.words);\n        A = B.slice(0, 2);\n        R[i] = B.slice(2, 4);\n        t.words[1]--;\n      }\n    }\n    if (A.equal(IV)) {\n      P = new WordArray([]);\n      for (_k = 0, _len = R.length; _k < _len; _k++) {\n        r = R[_k];\n        P.concat(r);\n      }\n      return [null, P.to_buffer()];\n    } else {\n      return [new Error(\"integrity check failure; got bad IV in decryption\"), null];\n    }\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/errors.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var make_errors;\n\n  make_errors = require('iced-error').make_errors;\n\n  exports.errors = make_errors({\n    WRONG_SIGNING_KEY: \"wrong signing key specified\",\n    REVOKED_KEY: \"key is revoked\"\n  });\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keywrapper.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, KeyWrapper, Lifespan, Primary, Subkey,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  C = require('./const');\n\n  Lifespan = (function() {\n    function Lifespan(_arg) {\n      this.generated = _arg.generated, this.expire_in = _arg.expire_in;\n      if (this.expire_in === void 0) {\n        this.expire_in = C.default_key_expire_in;\n      }\n    }\n\n    Lifespan.prototype.expires_earlier_than = function(l2) {\n      if (!l2.expire_in && this.expire_in) {\n        return true;\n      } else if (this.expire_in && !l2.expire_in) {\n        return false;\n      } else if (!this.expire_in && !l2.expire_in) {\n        return false;\n      } else {\n        return (this.generated + this.expire_in) < (l2.generated + l2.expire_in);\n      }\n    };\n\n    Lifespan.prototype.copy = function() {\n      return new Lifespan({\n        generated: this.generated,\n        expire_in: this.expire_in\n      });\n    };\n\n    return Lifespan;\n\n  })();\n\n  KeyWrapper = (function() {\n    function KeyWrapper(_arg) {\n      this.key = _arg.key, this.lifespan = _arg.lifespan, this._pgp = _arg._pgp, this._keybase = _arg._keybase, this.flags = _arg.flags;\n    }\n\n    KeyWrapper.prototype.ekid = function() {\n      return this.key.ekid();\n    };\n\n    KeyWrapper.prototype.overwrite_with_omitting_revokes = function(kw2) {\n      if (kw2._pgp.is_revoked()) {\n        return;\n      }\n      if (this._pgp.is_revoked() || this.lifespan.expires_earlier_than(kw2.lifespan)) {\n        return this.key = kw2.key, this.lifespan = kw2.lifespan, this._pgp = kw2._pgp, this._keybase = kw2._keybase, this.flags = kw2.flags, kw2;\n      }\n    };\n\n    return KeyWrapper;\n\n  })();\n\n  Subkey = (function(_super) {\n    __extends(Subkey, _super);\n\n    function Subkey(_arg) {\n      var flags, key, lifespan, _keybase, _pgp;\n      key = _arg.key, flags = _arg.flags, _pgp = _arg._pgp, _keybase = _arg._keybase, this.desc = _arg.desc, lifespan = _arg.lifespan, this.primary = _arg.primary;\n      Subkey.__super__.constructor.call(this, {\n        key: key,\n        lifespan: lifespan,\n        flags: flags,\n        _pgp: _pgp,\n        _keybase: _keybase\n      });\n    }\n\n    return Subkey;\n\n  })(KeyWrapper);\n\n  Primary = (function(_super) {\n    __extends(Primary, _super);\n\n    function Primary(_arg) {\n      var flags, key, lifespan, _keybase, _pgp;\n      key = _arg.key, lifespan = _arg.lifespan, flags = _arg.flags, _pgp = _arg._pgp, _keybase = _arg._keybase;\n      Primary.__super__.constructor.call(this, {\n        key: key,\n        lifespan: lifespan,\n        flags: flags,\n        _pgp: _pgp,\n        _keybase: _keybase\n      });\n    }\n\n    return Primary;\n\n  })(KeyWrapper);\n\n  exports.Lifespan = Lifespan;\n\n  exports.Subkey = Subkey;\n\n  exports.Primary = Primary;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/armor.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, Ch, Parser, armor, bufeq_fast, decode, katch, uint_to_buffer, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  _ref = require('../util'), katch = _ref.katch, bufeq_fast = _ref.bufeq_fast, uint_to_buffer = _ref.uint_to_buffer;\n\n  C = require('../const');\n\n  Ch = require('../header');\n\n  armor = require('pgp-utils').armor;\n\n  exports.encode = function(type, data) {\n    var mt;\n    mt = C.openpgp.message_types;\n    type = (function() {\n      switch (type) {\n        case mt.public_key:\n          return \"PUBLIC KEY BLOCK\";\n        case mt.private_key:\n          return \"PRIVATE KEY BLOCK\";\n        case mt.signature:\n          return \"SIGNATURE\";\n        case mt.generic:\n          return \"MESSAGE\";\n        default:\n          throw new Error(\"Cannot encode tag type \" + type);\n      }\n    })();\n    return armor.encode(Ch, type, data);\n  };\n\n  Parser = (function(_super) {\n    __extends(Parser, _super);\n\n    function Parser() {\n      return Parser.__super__.constructor.apply(this, arguments);\n    }\n\n    Parser.prototype.parse_type = function() {\n      var mt;\n      mt = C.openpgp.message_types;\n      this.ret.type = (function() {\n        switch (this.type) {\n          case \"PUBLIC KEY BLOCK\":\n            return mt.public_key;\n          case \"PRIVATE KEY BLOCK\":\n            return mt.private_key;\n          case \"SIGNED MESSAGE\":\n            if (this.ret.clearsign) {\n              return mt.clearsign;\n            } else {\n              throw new Error(\"Signed message, but not clear-signed\");\n            }\n            break;\n          case \"SIGNATURE\":\n            return mt.signature;\n          case \"MESSAGE\":\n            return mt.generic;\n          default:\n            throw new Error(\"Unknown message type: \" + this.type);\n        }\n      }).call(this);\n      return this.ret.fields.type = this.type;\n    };\n\n    return Parser;\n\n  })(armor.Parser);\n\n  exports.Message = armor.Message;\n\n  exports.decode = decode = function(data) {\n    return katch(function() {\n      return (new Parser(data)).parse();\n    });\n  };\n\n  exports.mdecode = decode = function(data) {\n    return katch(function() {\n      return (new Parser(data)).mparse();\n    });\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/header.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, pjs;\n\n  C = require('./const');\n\n  pjs = require('../package.json');\n\n  exports.header = {\n    version: C.header.version + (\" v\" + pjs.version),\n    comment: C.header.comment\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/parser.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, Compressed, Generic, KeyMaterial, Literal, MessageParser, OnePassSignature, PKESK, PacketParser, SEIPD, Signature, SlicerBuffer, UserAttribute, UserID, inspect, parse, util, _ref;\n\n  util = require('../util');\n\n  SlicerBuffer = require('./buffer').SlicerBuffer;\n\n  C = require('../const').openpgp;\n\n  KeyMaterial = require('./packet/keymaterial').KeyMaterial;\n\n  Signature = require('./packet/signature').Signature;\n\n  _ref = require('./packet/sess'), SEIPD = _ref.SEIPD, PKESK = _ref.PKESK;\n\n  UserID = require('./packet/userid').UserID;\n\n  UserAttribute = require('./packet/user_attribute').UserAttribute;\n\n  Compressed = require('./packet/compressed').Compressed;\n\n  Generic = require('./packet/generic').Generic;\n\n  OnePassSignature = require('./packet/one_pass_sig').OnePassSignature;\n\n  Literal = require('./packet/literal').Literal;\n\n  inspect = require('util').inspect;\n\n  MessageParser = (function() {\n    function MessageParser(slice) {\n      this.slice = slice;\n    }\n\n    MessageParser.prototype.parse = function() {\n      var _results;\n      _results = [];\n      while (this.slice.rem()) {\n        _results.push(this.parse_packet());\n      }\n      return _results;\n    };\n\n    MessageParser.prototype.parse_packet = function() {\n      return (new PacketParser(this.slice)).parse();\n    };\n\n    return MessageParser;\n\n  })();\n\n  PacketParser = (function() {\n    function PacketParser(slice) {\n      this.slice = slice;\n      this.body = null;\n      this.real_packet_len = null;\n      this.tag = null;\n      this.len = null;\n      this.header_len = null;\n    }\n\n    PacketParser.prototype.parse_header = function() {\n      this.parse_tag_and_len();\n      this.header_len || (this.header_len = this.slice.offset());\n      this.body || (this.body = new SlicerBuffer(this.slice.read_buffer(this.len)));\n      this.real_packet_len || (this.real_packet_len = this.len);\n      return this.slice.unclamp();\n    };\n\n    PacketParser.prototype.parse = function() {\n      var ret;\n      this.parse_header();\n      ret = this.parse_body();\n      return ret;\n    };\n\n    PacketParser.prototype.parse_body = function() {\n      var packet, pt, raw, sb;\n      pt = C.packet_tags;\n      sb = this.body;\n      raw = sb.peek_rest_to_buffer();\n      packet = (function() {\n        switch (this.tag) {\n          case pt.PKESK:\n            return PKESK.parse(sb);\n          case pt.one_pass_sig:\n            return OnePassSignature.parse(sb);\n          case pt.secret_key:\n            return KeyMaterial.parse_private_key(sb, {\n              subkey: false\n            });\n          case pt.secret_subkey:\n            return KeyMaterial.parse_private_key(sb, {\n              subkey: true\n            });\n          case pt.public_key:\n            return KeyMaterial.parse_public_key(sb, {\n              subkey: false\n            });\n          case pt.public_subkey:\n            return KeyMaterial.parse_public_key(sb, {\n              subkey: true\n            });\n          case pt.signature:\n            return Signature.parse(sb);\n          case pt.userid:\n            return UserID.parse(sb);\n          case pt.user_attribute:\n            return UserAttribute.parse(sb);\n          case pt.SEIPD:\n            return SEIPD.parse(sb);\n          case pt.literal:\n            return Literal.parse(sb);\n          case pt.compressed:\n            return Compressed.parse(sb);\n          default:\n            return new Generic(this.tag, sb);\n        }\n      }).call(this);\n      packet.set({\n        tag: this.tag,\n        real_packet_len: this.real_packet_len,\n        header_len: this.header_len,\n        raw: raw\n      });\n      return packet;\n    };\n\n    PacketParser.prototype.parse_tag_and_len = function() {\n      var c;\n      if (this.slice.len() < 2 || ((c = this.slice.read_uint8()) & 0x80) === 0) {\n        throw new Error(\"This doesn't look like a binary PGP packet (c=\" + c + \")\");\n      }\n      if ((c & 0x40) === 0) {\n        return this.parse_tag_and_len_old(c);\n      } else {\n        return this.parse_tag_and_len_new(c);\n      }\n    };\n\n    PacketParser.prototype.parse_tag_and_len_old = function(c) {\n      this.tag = (c & 0x3f) >> 2;\n      return this.len = (function() {\n        switch (c & 0x03) {\n          case 0:\n            return this.slice.read_uint8();\n          case 1:\n            return this.slice.read_uint16();\n          case 2:\n            return this.slice.read_uint32();\n          case 3:\n            return this.slice.rem();\n        }\n      }).call(this);\n    };\n\n    PacketParser.prototype.parse_tag_and_len_new = function(c) {\n      var ret;\n      this.tag = c & 0x3f;\n      ret = this.parse_tag_len_new();\n      return ret;\n    };\n\n    PacketParser.prototype.parse_tag_len_new = function() {\n      var c, d, go, lastlen, packet_length, segments;\n      go = true;\n      segments = [];\n      this.len = 0;\n      lastlen = 0;\n      while (go) {\n        go = false;\n        c = this.slice.read_uint8();\n        lastlen = c < 192 ? c : c === 255 ? this.slice.read_uint32() : c < 224 ? (d = this.slice.read_uint8(), ((c - 192) << 8) + (d + 192)) : (this.header_len || (this.header_len = this.slice.offset()), packet_length = 1 << (c & 0x1f), segments.push(this.slice.read_buffer(packet_length)), go = true, packet_length);\n        this.len += lastlen;\n      }\n      if (segments.length) {\n        segments.push(this.slice.read_buffer(lastlen));\n        this.body = new SlicerBuffer(Buffer.concat(segments));\n        this.len = this.body.length;\n        return this.real_packet_len = this.slice.offset();\n      }\n    };\n\n    return PacketParser;\n\n  })();\n\n  exports.parse = parse = function(buf) {\n    return util.katch(function() {\n      return (new MessageParser(new SlicerBuffer(buf))).parse();\n    });\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/keymaterial.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var AES, C, DSA, ECDH, ECDSA, EDDSA, ElGamal, ElGamalSE, KeyMaterial, Packet, Parser, RSA, S, S2K, SHA1, SHA256, SecretKeyMaterial, Signature, bufeq_secure, bufferify, calc_checksum, decrypt, encode, encrypt, iced, katch, make_time_packet, native_rng, packetsigs, symmetric, triplesec, uint_to_buffer, unix_time, util, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  C = require('../../const').openpgp;\n\n  triplesec = require('triplesec');\n\n  _ref = triplesec.hash, SHA1 = _ref.SHA1, SHA256 = _ref.SHA256;\n\n  RSA = require('../../rsa').Pair;\n\n  DSA = require('../../dsa').Pair;\n\n  ElGamal = require('../../elgamal').Pair;\n\n  ElGamalSE = require('../../elgamalse').Pair;\n\n  ECDSA = require('../../ecc/ecdsa').Pair;\n\n  ECDH = require('../../ecc/ecdh').Pair;\n\n  EDDSA = require('../../ecc/eddsa').Pair;\n\n  AES = triplesec.ciphers.AES;\n\n  native_rng = triplesec.prng.native_rng;\n\n  calc_checksum = require('../util').calc_checksum;\n\n  _ref1 = require('../../util'), bufferify = _ref1.bufferify, unix_time = _ref1.unix_time, bufeq_secure = _ref1.bufeq_secure, katch = _ref1.katch, make_time_packet = _ref1.make_time_packet, uint_to_buffer = _ref1.uint_to_buffer;\n\n  _ref2 = require('../cfb'), decrypt = _ref2.decrypt, encrypt = _ref2.encrypt;\n\n  Packet = require('./base').Packet;\n\n  S = require('./signature');\n\n  Signature = S.Signature;\n\n  encode = require('../armor').encode;\n\n  _ref3 = require('../s2k'), S2K = _ref3.S2K, SecretKeyMaterial = _ref3.SecretKeyMaterial;\n\n  symmetric = require('../../symmetric');\n\n  util = require('util');\n\n  packetsigs = require('./packetsigs');\n\n  KeyMaterial = (function(_super) {\n    __extends(KeyMaterial, _super);\n\n    function KeyMaterial(_arg) {\n      this.key = _arg.key, this.timestamp = _arg.timestamp, this.passphrase = _arg.passphrase, this.skm = _arg.skm, this.opts = _arg.opts, this.flags = _arg.flags;\n      this.opts || (this.opts = {});\n      this.flags || (this.flags = 0);\n      this._is_duplicate_primary = false;\n      KeyMaterial.__super__.constructor.call(this);\n    }\n\n    KeyMaterial.prototype._write_private_enc = function(bufs, priv, pp) {\n      var c, ct, iv, ivlen, k, ks, plaintext, salt, sha1hash;\n      bufs.push(new Buffer([C.s2k_convention.sha1, C.symmetric_key_algorithms.AES256, C.s2k.salt_iter, C.hash_algorithms.SHA256]));\n      sha1hash = (new SHA1).bufhash(priv);\n      salt = native_rng(8);\n      bufs.push(salt);\n      c = 96;\n      bufs.push(new Buffer([c]));\n      ks = AES.keySize;\n      k = (new S2K).write(pp, salt, c, ks);\n      ivlen = AES.blockSize;\n      iv = native_rng(ivlen);\n      bufs.push(iv);\n      plaintext = Buffer.concat([priv, sha1hash]);\n      ct = encrypt({\n        block_cipher_class: AES,\n        key: k,\n        plaintext: plaintext,\n        iv: iv\n      });\n      return bufs.push(ct);\n    };\n\n    KeyMaterial.prototype._write_private_clear = function(bufs, priv) {\n      return bufs.push(new Buffer([C.s2k_convention.none]), priv, uint_to_buffer(16, calc_checksum(priv)));\n    };\n\n    KeyMaterial.prototype._write_public = function(bufs) {\n      var pub;\n      pub = this.key.serialize();\n      return bufs.push(new Buffer([C.versions.keymaterial.V4]), uint_to_buffer(32, this.timestamp), new Buffer([this.key.type]), pub);\n    };\n\n    KeyMaterial.prototype._write_dummy = function(bufs) {\n      return bufs.push(new Buffer([C.s2k_convention.sha1, C.symmetric_key_algorithms.AES256, C.s2k.gnu, 0x2]), new Buffer(\"GNU\", \"utf8\"), new Buffer([0x1]));\n    };\n\n    KeyMaterial.prototype.add_flags = function(v) {\n      return this.flags |= v;\n    };\n\n    KeyMaterial.prototype.private_body = function(opts) {\n      var bufs, p, pp, priv, ret;\n      bufs = [];\n      this._write_public(bufs);\n      priv = (p = this.key.priv) != null ? p.serialize() : null;\n      pp = opts.passphrase || this.passphrase;\n      if (priv == null) {\n        this._write_dummy(bufs);\n      } else if (pp != null) {\n        this._write_private_enc(bufs, priv, pp);\n      } else {\n        this._write_private_clear(bufs, priv);\n      }\n      ret = Buffer.concat(bufs);\n      return ret;\n    };\n\n    KeyMaterial.prototype.private_framed = function(opts) {\n      var T, body, tag;\n      body = this.private_body(opts);\n      T = C.packet_tags;\n      tag = opts.subkey ? T.secret_subkey : T.secret_key;\n      return this.frame_packet(tag, body);\n    };\n\n    KeyMaterial.prototype.public_body = function() {\n      var bufs;\n      bufs = [];\n      this._write_public(bufs);\n      return Buffer.concat(bufs);\n    };\n\n    KeyMaterial.prototype.get_fingerprint = function() {\n      var data;\n      data = this.public_body();\n      return (new SHA1).bufhash(Buffer.concat([new Buffer([C.signatures.key]), uint_to_buffer(16, data.length), data]));\n    };\n\n    KeyMaterial.prototype.get_key_id = function() {\n      return this.get_fingerprint().slice(12, 20);\n    };\n\n    KeyMaterial.prototype.get_short_key_id = function() {\n      return this.get_key_id().slice(-4).toString('hex').toUpperCase();\n    };\n\n    KeyMaterial.prototype.get_klass = function() {\n      return this.key.constructor;\n    };\n\n    KeyMaterial.prototype.export_framed = function(opts) {\n      if (opts == null) {\n        opts = {};\n      }\n      if (opts[\"private\"]) {\n        return this.private_framed(opts);\n      } else {\n        return this.public_framed(opts);\n      }\n    };\n\n    KeyMaterial.prototype.public_framed = function(opts) {\n      var T, body, tag;\n      if (opts == null) {\n        opts = {};\n      }\n      body = this.public_body();\n      T = C.packet_tags;\n      tag = opts.subkey ? T.public_subkey : T.public_key;\n      return this.frame_packet(tag, body);\n    };\n\n    KeyMaterial.prototype.to_signature_payload = function() {\n      var pk;\n      pk = this.public_body();\n      return Buffer.concat([new Buffer([C.signatures.key]), uint_to_buffer(16, pk.length), pk]);\n    };\n\n    KeyMaterial.prototype.self_sign_key = function(_arg, cb) {\n      var err, lifespan, primary, raw_payload, sig, sigs, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      userids = _arg.userids, lifespan = _arg.lifespan, raw_payload = _arg.raw_payload;\n      err = null;\n      sigs = [];\n      primary = true;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref4, _results, _while;\n          _ref4 = userids;\n          _len = _ref4.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              userid = _ref4[_i];\n              if (err == null) {\n                sig = null;\n                (function(__iced_k) {\n                  if (_this.key.can_sign() || raw_payload) {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                        funcname: \"KeyMaterial.self_sign_key\"\n                      });\n                      _this._self_sign_key({\n                        userid: userid,\n                        lifespan: lifespan,\n                        raw_payload: raw_payload,\n                        primary: primary\n                      }, __iced_deferrals.defer({\n                        assign_fn: (function() {\n                          return function() {\n                            err = arguments[0];\n                            return sig = arguments[1];\n                          };\n                        })(),\n                        lineno: 194\n                      }));\n                      __iced_deferrals._fulfill();\n                    })(__iced_k);\n                  } else {\n                    return __iced_k((sig = userid.get_framed_signature_output()) == null ? err = new Error(\"Cannot sign key --- don't have a private key, and can't replay\") : void 0);\n                  }\n                })(function() {\n                  primary = false;\n                  return _next(sigs.push(sig));\n                });\n              } else {\n                return _continue();\n              }\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype._self_sign_key = function(_arg, cb) {\n      var err, hsp, lifespan, payload, primary, ps, raw_payload, sig, type, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      userid = _arg.userid, lifespan = _arg.lifespan, raw_payload = _arg.raw_payload, primary = _arg.primary;\n      payload = Buffer.concat([this.to_signature_payload(), userid.to_signature_payload()]);\n      type = C.sig_types.positive;\n      hsp = [new S.CreationTime(lifespan.generated), new S.KeyFlags([this.flags]), new S.PreferredSymmetricAlgorithms([C.symmetric_key_algorithms.AES256, C.symmetric_key_algorithms.AES128]), new S.PreferredHashAlgorithms([C.hash_algorithms.SHA512, C.hash_algorithms.SHA256]), new S.Features([C.features.modification_detection]), new S.KeyServerPreferences([C.key_server_preferences.no_modify]), new S.PreferredCompressionAlgorithms([C.compression.zlib, C.compression.zip])];\n      if (primary) {\n        hsp.push(new S.PrimaryUserId(1));\n      }\n      if (lifespan.expire_in) {\n        hsp.push(new S.KeyExpirationTime(lifespan.expire_in));\n      }\n      sig = new Signature({\n        type: type,\n        key: this.key,\n        hashed_subpackets: hsp,\n        unhashed_subpackets: [new S.Issuer(this.get_key_id())]\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          if (raw_payload) {\n            return __iced_k(sig = payload);\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                funcname: \"KeyMaterial._self_sign_key\"\n              });\n              sig.write(payload, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 237\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              ps = new packetsigs.SelfSig({\n                userid: userid,\n                type: type,\n                sig: sig,\n                options: _this.flags\n              });\n              userid.push_sig(ps);\n              return __iced_k(_this.push_sig(ps));\n            });\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype.sign_subkey = function(_arg, cb) {\n      var err, lifespan, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      subkey = _arg.subkey, lifespan = _arg.lifespan;\n      err = sig = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _ref4, _ref5;\n          if (_this.key.can_sign()) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                funcname: \"KeyMaterial.sign_subkey\"\n              });\n              _this._sign_subkey({\n                subkey: subkey,\n                lifespan: lifespan\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 250\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(!((_ref4 = subkey.get_subkey_binding()) != null ? (_ref5 = _ref4.sig) != null ? _ref5.get_framed_output() : void 0 : void 0) ? err = new Error(\"Cannot sign with subkey --- don't have private key and can't replay\") : void 0);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype._sign_subkey = function(_arg, cb) {\n      var SKB, err, lifespan, primary_binding, ps, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      subkey = _arg.subkey, lifespan = _arg.lifespan;\n      sig = err = primary_binding = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (subkey.can_sign()) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                funcname: \"KeyMaterial._sign_subkey\"\n              });\n              subkey._sign_primary_with_subkey({\n                primary: _this,\n                lifespan: lifespan\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return primary_binding = arguments[1];\n                  };\n                })(),\n                lineno: 262\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n                  funcname: \"KeyMaterial._sign_subkey\"\n                });\n                _this._sign_subkey_with_primary({\n                  subkey: subkey,\n                  lifespan: lifespan,\n                  primary_binding: primary_binding\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return sig = arguments[1];\n                    };\n                  })(),\n                  lineno: 264\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            if (err == null) {\n              SKB = packetsigs.SubkeyBinding;\n              ps = new SKB({\n                primary: _this,\n                sig: sig,\n                direction: SKB.DOWN\n              });\n              subkey.push_sig(ps);\n            }\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype._sign_primary_with_subkey = function(_arg, cb) {\n      var err, lifespan, payload, primary, sig, sig_unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      primary = _arg.primary, lifespan = _arg.lifespan;\n      payload = Buffer.concat([primary.to_signature_payload(), this.to_signature_payload()]);\n      sig = new Signature({\n        type: C.sig_types.primary_binding,\n        key: this.key,\n        hashed_subpackets: [new S.CreationTime(lifespan.generated)],\n        unhashed_subpackets: [new S.Issuer(this.get_key_id())]\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n            funcname: \"KeyMaterial._sign_primary_with_subkey\"\n          });\n          sig.write_unframed(payload, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return sig_unframed = arguments[1];\n              };\n            })(),\n            lineno: 288\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig_unframed);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype._sign_subkey_with_primary = function(_arg, cb) {\n      var err, lifespan, payload, primary_binding, sig, subkey, unhashed_subpackets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      subkey = _arg.subkey, lifespan = _arg.lifespan, primary_binding = _arg.primary_binding;\n      payload = Buffer.concat([this.to_signature_payload(), subkey.to_signature_payload()]);\n      unhashed_subpackets = [new S.Issuer(this.get_key_id())];\n      if (primary_binding != null) {\n        unhashed_subpackets.push(new S.EmbeddedSignature({\n          rawsig: primary_binding\n        }));\n      }\n      sig = new Signature({\n        type: C.sig_types.subkey_binding,\n        key: this.key,\n        hashed_subpackets: [new S.CreationTime(lifespan.generated), new S.KeyExpirationTime(lifespan.expire_in), new S.KeyFlags([subkey.flags])],\n        unhashed_subpackets: unhashed_subpackets\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n            funcname: \"KeyMaterial._sign_subkey_with_primary\"\n          });\n          sig.write(payload, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 312\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype.merge_private = function(k2) {\n      return this.skm = k2.skm;\n    };\n\n    KeyMaterial.parse_public_key = function(slice, opts) {\n      return (new Parser(slice)).parse_public_key(opts);\n    };\n\n    KeyMaterial.parse_private_key = function(slice, opts) {\n      return (new Parser(slice)).parse_private_key(opts);\n    };\n\n    KeyMaterial.prototype.is_key_material = function() {\n      return true;\n    };\n\n    KeyMaterial.prototype.is_primary = function() {\n      var _ref4;\n      return !((_ref4 = this.opts) != null ? _ref4.subkey : void 0);\n    };\n\n    KeyMaterial.prototype.is_duplicate_primary = function() {\n      return this._is_duplicate_primary;\n    };\n\n    KeyMaterial.prototype.set_duplicate_primary = function() {\n      return this._is_duplicate_primary = true;\n    };\n\n    KeyMaterial.prototype.ekid = function() {\n      return this.key.ekid();\n    };\n\n    KeyMaterial.prototype.can_sign = function() {\n      return this.key.can_sign();\n    };\n\n    KeyMaterial.prototype.is_locked = function() {\n      return (!this.key.has_private()) && (this.skm != null) && this.skm.is_locked();\n    };\n\n    KeyMaterial.prototype.has_private = function() {\n      return this.has_unlocked_private() || this.has_locked_private();\n    };\n\n    KeyMaterial.prototype.has_locked_private = function() {\n      return this.skm && this.skm.has_private();\n    };\n\n    KeyMaterial.prototype.has_unlocked_private = function() {\n      return this.key.has_private();\n    };\n\n    KeyMaterial.prototype.has_secret_key_material = function() {\n      return this.skm != null;\n    };\n\n    KeyMaterial.prototype.validity_check = function(cb) {\n      var err, msg, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/keymaterial.iced\",\n            funcname: \"KeyMaterial.validity_check\"\n          });\n          _this.key.validity_check(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 346\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err !== \"undefined\" && err !== null) {\n            msg = \"In key \" + (_this.get_fingerprint().toString('hex')) + \": \" + err.message;\n            err = new Error(err);\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyMaterial.prototype.is_signed_subkey_of = function(primary, opts) {\n      var need_upwards_sig;\n      if (this.primary_flag) {\n        return false;\n      }\n      need_upwards_sig = (opts != null ? opts.strict : void 0) && this.fulfills_flags(C.key_flags.sign_data);\n      return this.get_psc().is_signed_subkey_of(primary, need_upwards_sig);\n    };\n\n    KeyMaterial.prototype.get_subkey_binding = function() {\n      if (this.opts.subkey) {\n        return this.get_psc().get_subkey_binding();\n      } else {\n        return null;\n      }\n    };\n\n    KeyMaterial.prototype.get_subkey_binding_signature_output = function() {\n      var _ref4, _ref5;\n      return (_ref4 = this.get_subkey_binding()) != null ? (_ref5 = _ref4.sig) != null ? _ref5.get_framed_output() : void 0 : void 0;\n    };\n\n    KeyMaterial.prototype.equal = function(k2) {\n      return bufeq_secure(this.ekid(), k2.ekid());\n    };\n\n    KeyMaterial.prototype.unlock = function(_arg, cb) {\n      var c1, c2, end, err, h1, h2, key, passphrase, pt;\n      passphrase = _arg.passphrase;\n      if (passphrase != null) {\n        passphrase = bufferify(passphrase);\n      }\n      err = null;\n      if (this.skm == null) {\n        err = new Error(\"Cannot unlock secret key -- no material!\");\n        return cb(err);\n      }\n      pt = this.skm.s2k_convention === C.s2k_convention.none ? this.skm.payload : this.skm.s2k.type === C.s2k.gnu_dummy ? null : passphrase == null ? (err = new Error(\"Key was locked, but no passphrase given\"), null) : (key = this.skm.s2k.produce_key(passphrase, this.skm.cipher.key_size), decrypt({\n        ciphertext: this.skm.payload,\n        block_cipher_class: this.skm.cipher.klass,\n        iv: this.skm.iv,\n        key: key\n      }));\n      if (pt) {\n        switch (this.skm.s2k_convention) {\n          case C.s2k_convention.sha1:\n            end = pt.length - SHA1.output_size;\n            h1 = pt.slice(end);\n            pt = pt.slice(0, end);\n            h2 = (new SHA1).bufhash(pt);\n            if (!bufeq_secure(h1, h2)) {\n              err = new Error(\"bad private key passphrase (hash mismatch)\");\n            }\n            break;\n          case C.s2k_convention.checksum:\n          case C.s2k_convention.none:\n            end = pt.length - 2;\n            c1 = pt.readUInt16BE(end);\n            pt = pt.slice(0, end);\n            c2 = calc_checksum(pt);\n            if (c1 !== c2) {\n              err = new Error(\"bad private key passphrase (checksum mismatch)\");\n            }\n        }\n        if (err == null) {\n          err = this.key.read_priv(pt);\n        }\n      }\n      return cb(err);\n    };\n\n    KeyMaterial.prototype.get_all_key_flags = function() {\n      return this._psc.get_all_key_flags();\n    };\n\n    KeyMaterial.prototype.add_flags = function(v) {\n      return this.flags |= v;\n    };\n\n    KeyMaterial.prototype.fulfills_flags = function(flags) {\n      var akf, ret;\n      if (this.is_revoked()) {\n        return false;\n      }\n      akf = this.get_all_key_flags();\n      ret = ((akf & flags) === flags) || this.key.fulfills_flags(flags) || (this.is_primary() && (akf === 0) && ((this.key.good_for_flags() & flags) === flags));\n      return ret;\n    };\n\n    KeyMaterial.prototype.get_signed_userids = function() {\n      return this.get_psc().get_signed_userids();\n    };\n\n    KeyMaterial.prototype.get_signed_user_attributes = function() {\n      return this.get_psc().get_signed_user_attributes();\n    };\n\n    KeyMaterial.prototype.is_self_signed = function() {\n      return this.get_psc().is_self_signed();\n    };\n\n    KeyMaterial.prototype.push_sig = function(packetsig) {\n      this.add_flags(packetsig.sig.get_key_flags());\n      return KeyMaterial.__super__.push_sig.call(this, packetsig);\n    };\n\n    KeyMaterial.prototype.mark_revoked = function(sig) {\n      return this.revocation = sig;\n    };\n\n    KeyMaterial.prototype.is_revoked = function() {\n      return this.revocation != null;\n    };\n\n    KeyMaterial.prototype.check_not_expired = function(_arg) {\n      var e, err, now, _ref4;\n      now = _arg.now;\n      err = null;\n      if ((e = (_ref4 = this.get_expire_time()) != null ? _ref4.expire_at : void 0) && e < now) {\n        err = new Error(\"PGP key \" + (this.get_fingerprint().toString('hex')) + \" expired at \" + e + \" but we checked for time \" + now);\n      }\n      return err;\n    };\n\n    KeyMaterial.prototype.is_preferable_to = function(k2) {\n      var e1, e2, ret;\n      e1 = this.get_expire_time();\n      e2 = k2.get_expire_time();\n      if (e1.expire_at == null) {\n        e1.expire_at = Infinity;\n      }\n      if (e2.expire_at == null) {\n        e2.expire_at = Infinity;\n      }\n      ret = e1.expire_at > e2.expire_at ? true : e1.expire_at < e2.expire_at ? false : e1.generated >= e2.generated ? true : false;\n      return ret;\n    };\n\n    KeyMaterial.prototype.get_expire_time = function() {\n      var psc;\n      if ((psc = this.get_psc()) == null) {\n        return null;\n      } else if (this.is_primary()) {\n        return this._get_expire_time_on_primary();\n      } else {\n        return this._get_expire_time_on_subkey();\n      }\n    };\n\n    KeyMaterial.prototype._get_expire_time_on_primary = function() {\n      var expire_in, key_generated, list, packetsig, ret, sig, sig_generated, table, uid, uid_expire_in, uid_winner, winner, _i, _len;\n      table = this.get_psc().lookup.self_sigs_by_uid;\n      winner = null;\n      key_generated = this.timestamp;\n      for (uid in table) {\n        list = table[uid];\n        uid_winner = null;\n        for (_i = 0, _len = list.length; _i < _len; _i++) {\n          packetsig = list[_i];\n          if (!((sig = packetsig.sig) != null)) {\n            continue;\n          }\n          expire_in = sig.get_key_expires();\n          sig_generated = sig.when_generated();\n          if ((uid_winner == null) || uid_winner.sig_generated < sig_generated) {\n            uid_winner = {\n              expire_in: expire_in,\n              sig_generated: sig_generated\n            };\n          }\n        }\n        if (uid_winner != null) {\n          uid_expire_in = uid_winner.expire_in || 0;\n          if ((winner == null) || (uid_expire_in === 0) || ((0 < winner && winner < uid_expire_in))) {\n            winner = uid_expire_in;\n          }\n        }\n      }\n      ret = {\n        generated: this.timestamp,\n        expire_at: null,\n        expire_in: null\n      };\n      if (winner) {\n        ret.expire_at = this.timestamp + winner;\n        ret.expire_in = winner;\n      }\n      return ret;\n    };\n\n    KeyMaterial.prototype._get_expire_time_on_subkey = function() {\n      var expire_at, expire_in, generated, list, packetsig, sig, winner, _i, _len;\n      list = this.get_psc().lookup.subkey_binding;\n      if (!(list != null ? list.length : void 0)) {\n        return null;\n      }\n      winner = null;\n      for (_i = 0, _len = list.length; _i < _len; _i++) {\n        packetsig = list[_i];\n        if (!((packetsig.sig != null) && packetsig.is_down())) {\n          continue;\n        }\n        sig = packetsig.sig;\n        expire_in = sig.get_key_expires();\n        generated = this.timestamp;\n        if (expire_in && generated) {\n          expire_at = generated + expire_in;\n          if ((winner == null) || ((winner.expire_at != null) && (winner.expire_at < expire_at))) {\n            winner = {\n              expire_at: expire_at,\n              generated: generated,\n              expire_in: expire_in\n            };\n          }\n        } else if (((expire_in != null) && expire_in === 0) || (expire_in == null)) {\n          winner = {\n            generated: generated,\n            expire_in: null,\n            expire_at: null\n          };\n        }\n      }\n      if (winner == null) {\n        winner = {\n          generated: 0,\n          expire_at: null,\n          expire_in: null\n        };\n      }\n      return winner;\n    };\n\n    return KeyMaterial;\n\n  })(Packet);\n\n  Parser = (function() {\n    function Parser(slice) {\n      this.slice = slice;\n      this.key = null;\n    }\n\n    Parser.prototype.parse_public_key_v3 = function() {\n      this.timestamp = this.slice.read_uint32();\n      this.expiration = this.slice.read_uint16();\n      return this.parse_public_key_mpis();\n    };\n\n    Parser.prototype.parse_public_key_v4 = function() {\n      this.timestamp = this.slice.read_uint32();\n      return this.parse_public_key_mpis();\n    };\n\n    Parser.prototype.parse_public_key_mpis = function() {\n      var A, err, key, klass, len, _ref4;\n      this.algorithm = this.slice.read_uint8();\n      A = C.public_key_algorithms;\n      klass = (function() {\n        switch (this.algorithm) {\n          case A.RSA:\n          case A.RSA_ENCRYPT_ONLY:\n          case A.RSA_SIGN_ONLY:\n            return RSA;\n          case A.DSA:\n            return DSA;\n          case A.ELGAMAL:\n            return ElGamal;\n          case A.ELGAMAL_SIGN_AND_ENCRYPT:\n            return ElGamalSE;\n          case A.ECDSA:\n            return ECDSA;\n          case A.ECDH:\n            return ECDH;\n          case A.EDDSA:\n            return EDDSA;\n          default:\n            throw new Error(\"Unknown key type: \" + this.algorithm);\n        }\n      }).call(this);\n      _ref4 = klass.parse(this.slice.peek_rest_to_buffer()), err = _ref4[0], key = _ref4[1], len = _ref4[2];\n      if (err != null) {\n        throw err;\n      }\n      this.slice.advance(len);\n      return key;\n    };\n\n    Parser.prototype._parse_public_key = function() {\n      var version;\n      switch ((version = this.slice.read_uint8())) {\n        case C.versions.keymaterial.V3:\n          return this.parse_public_key_v3();\n        case C.versions.keymaterial.V4:\n          return this.parse_public_key_v4();\n        default:\n          throw new Error(\"Unknown public key version: \" + version);\n      }\n    };\n\n    Parser.prototype.parse_public_key = function(opts) {\n      var key;\n      key = this._parse_public_key();\n      return new KeyMaterial({\n        key: key,\n        timestamp: this.timestamp,\n        opts: opts\n      });\n    };\n\n    Parser.prototype.parse_private_key = function(opts) {\n      var encrypted_private_key, iv_len, key, skm, sym_enc_alg, _ref4;\n      skm = new SecretKeyMaterial();\n      key = this._parse_public_key();\n      encrypted_private_key = true;\n      sym_enc_alg = null;\n      if ((skm.s2k_convention = this.slice.read_uint8()) === C.s2k_convention.none) {\n        encrypted_private_key = false;\n      } else {\n        if ((_ref4 = skm.s2k_convention) === C.s2k_convention.sha1 || _ref4 === C.s2k_convention.checksum) {\n          sym_enc_alg = this.slice.read_uint8();\n          skm.s2k = (new S2K).read(this.slice);\n        } else {\n          sym_enc_alg = skm.s2k_convention;\n        }\n      }\n      if ((skm.s2k_convention !== C.s2k_convention.none) && (skm.s2k.type === C.s2k.gnu_dummy)) {\n        skm.payload = null;\n      } else {\n        if (sym_enc_alg) {\n          skm.cipher = symmetric.get_cipher(sym_enc_alg);\n          iv_len = skm.cipher.klass.blockSize;\n          skm.iv = this.slice.read_buffer(iv_len);\n        }\n        skm.payload = this.slice.consume_rest_to_buffer();\n      }\n      return new KeyMaterial({\n        key: key,\n        skm: skm,\n        timestamp: this.timestamp,\n        opts: opts\n      });\n    };\n\n    return Parser;\n\n  })();\n\n  exports.KeyMaterial = KeyMaterial;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/dsa.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, BaseKey, BaseKeyPair, BigInteger, C, K, MRF, Pair, Priv, Pub, SRF, bn, bufeq_secure, iced, konst, make_esc, nbits, nbv, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  bn = require('./bn');\n\n  nbits = bn.nbits, nbv = bn.nbv, BigInteger = bn.BigInteger;\n\n  _ref = require('./rand'), SRF = _ref.SRF, MRF = _ref.MRF;\n\n  _ref1 = require('./util'), bufeq_secure = _ref1.bufeq_secure, ASP = _ref1.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref2 = require('./basekeypair'), BaseKey = _ref2.BaseKey, BaseKeyPair = _ref2.BaseKeyPair;\n\n  _ref3 = require('./rand'), SRF = _ref3.SRF, MRF = _ref3.MRF;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.DSA;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.ORDER = ['p', 'q', 'g', 'y'];\n\n    Pub.prototype.ORDER = Pub.ORDER;\n\n    function Pub(_arg) {\n      this.p = _arg.p, this.q = _arg.q, this.g = _arg.g, this.y = _arg.y;\n    }\n\n    Pub.alloc = function(raw) {\n      return BaseKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.trunc_hash = function(h) {\n      return bn.bn_from_left_n_bits(h, this.q.bitLength());\n    };\n\n    Pub.prototype.nbits = function() {\n      var _ref4;\n      return (_ref4 = this.p) != null ? _ref4.bitLength() : void 0;\n    };\n\n    Pub.prototype.verify = function(_arg, h, cb) {\n      var err, hi, r, s, u1, u2, v, w;\n      r = _arg[0], s = _arg[1];\n      err = null;\n      hi = this.trunc_hash(h);\n      w = s.modInverse(this.q);\n      u1 = hi.multiply(w).mod(this.q);\n      u2 = r.multiply(w).mod(this.q);\n      v = this.g.modPow(u1, this.p).multiply(this.y.modPow(u2, this.p)).mod(this.p).mod(this.q);\n      if (!v.equals(r)) {\n        err = new Error(\"verification failed\");\n      }\n      return cb(err);\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = ['x'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(_arg) {\n      this.x = _arg.x, this.pub = _arg.pub;\n    }\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.sign = function(h, cb) {\n      var err, g, hi, k, p, q, r, s, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      _ref4 = this.pub, p = _ref4.p, q = _ref4.q, g = _ref4.g;\n      hi = this.pub.trunc_hash(h);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/dsa.iced\",\n            funcname: \"Priv.sign\"\n          });\n          SRF().random_zn(q.subtract(bn.nbv(2)), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return k = arguments[0];\n              };\n            })(),\n            lineno: 76\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          k = k.add(bn.BigInteger.ONE);\n          r = g.modPow(k, p).mod(q);\n          s = (k.modInverse(q).multiply(hi.add(_this.x.multiply(r)))).mod(q);\n          return cb([r, s]);\n        };\n      })(this));\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.DSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.klass_name = \"DSA\";\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.parse = function(pub_raw) {\n      return BaseKeyPair.parse(Pair, pub_raw);\n    };\n\n    Pair.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = this.good_for_flags();\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.good_for_flags = function() {\n      return C.key_flags.certify_keys | C.key_flags.sign_data;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, hash, hasher, sig;\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      return this._dsa_verify_update_and_check_hash({\n        sig: sig,\n        data: data,\n        hasher: hasher,\n        hash: hash,\n        klass: Pair\n      }, cb);\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var h, hasher, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hasher = _arg.hasher;\n      hasher || (hasher = SHA512);\n      h = hasher(data);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/dsa.iced\",\n            funcname: \"Pair.pad_and_sign\"\n          });\n          _this.priv.sign(h, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 128\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null, Buffer.concat((function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = sig.length; _i < _len; _i++) {\n              s = sig[_i];\n              _results.push(s.to_mpi_buffer());\n            }\n            return _results;\n          })()));\n        };\n      })(this));\n    };\n\n    Pair.parse_sig = function(slice) {\n      var buf, err, n, ret, _ref4;\n      buf = slice.peek_rest_to_buffer();\n      _ref4 = Pair.read_sig_from_buf(buf), err = _ref4[0], ret = _ref4[1], n = _ref4[2];\n      if (err != null) {\n        throw err;\n      }\n      slice.advance(n);\n      return ret;\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var err, n, o, order, orig_len, ret, x;\n      orig_len = buf.length;\n      order = ['r', 's'];\n      err = null;\n      ret = (function() {\n        var _i, _len, _ref4, _results;\n        _results = [];\n        for (_i = 0, _len = order.length; _i < _len; _i++) {\n          o = order[_i];\n          if (!(err == null)) {\n            continue;\n          }\n          _ref4 = bn.mpi_from_buffer(buf), err = _ref4[0], x = _ref4[1], buf = _ref4[2];\n          _results.push(x);\n        }\n        return _results;\n      })();\n      n = orig_len - buf.length;\n      return [err, ret, n];\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.DSA = exports.Pair = Pair;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/elgamal.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, BaseKey, BaseKeyPair, C, K, MRF, Output, Pair, Priv, Pub, SRF, bn, bufeq_secure, eme_pkcs1_decode, eme_pkcs1_encode, iced, konst, make_esc, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  bn = require('./bn');\n\n  _ref = require('./util'), bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref1 = require('./basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;\n\n  _ref2 = require('./rand'), SRF = _ref2.SRF, MRF = _ref2.MRF;\n\n  _ref3 = require('./pad'), eme_pkcs1_encode = _ref3.eme_pkcs1_encode, eme_pkcs1_decode = _ref3.eme_pkcs1_decode;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.ELGAMAL;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.ORDER = ['p', 'g', 'y'];\n\n    Pub.prototype.ORDER = Pub.ORDER;\n\n    function Pub(_arg) {\n      this.p = _arg.p, this.g = _arg.g, this.y = _arg.y;\n    }\n\n    Pub.alloc = function(raw) {\n      return BaseKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.encrypt = function(m, cb) {\n      var c, k, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n            funcname: \"Pub.encrypt\"\n          });\n          SRF().random_zn(_this.p.subtract(bn.nbv(2)), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return k = arguments[0];\n              };\n            })(),\n            lineno: 35\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          k = k.add(bn.BigInteger.ONE);\n          c = [_this.g.modPow(k, _this.p), _this.y.modPow(k, _this.p).multiply(m).mod(_this.p)];\n          return cb(c);\n        };\n      })(this));\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = ['x'];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(_arg) {\n      this.x = _arg.x, this.pub = _arg.pub;\n    }\n\n    Priv.prototype.serialize = function() {\n      return this.x.to_mpi_buffer();\n    };\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.decrypt = function(c, cb) {\n      var p, ret;\n      p = this.pub.p;\n      ret = c[0].modPow(this.x, p).modInverse(p).multiply(c[1]).mod(p);\n      return cb(null, ret);\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.ELGAMAL;\n\n    Pair.klass_name = \"ELGAMAL\";\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = this.good_for_flags();\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.good_for_flags = function() {\n      return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;\n    };\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.prototype.can_sign = function() {\n      return false;\n    };\n\n    Pair.parse = function(pub_raw) {\n      var ret;\n      ret = BaseKeyPair.parse(Pair, pub_raw);\n      return ret;\n    };\n\n    Pair.prototype.max_value = function() {\n      return this.pub.p;\n    };\n\n    Pair.prototype.pad_and_encrypt = function(data, params, cb) {\n      var c_mpis, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n            funcname: \"Pair.pad_and_encrypt\"\n          });\n          eme_pkcs1_encode(data, _this.pub.p.mpi_byte_length(), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return m = arguments[1];\n              };\n            })(),\n            lineno: 112\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n                  funcname: \"Pair.pad_and_encrypt\"\n                });\n                _this.pub.encrypt(m, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return c_mpis = arguments[0];\n                    };\n                  })(),\n                  lineno: 114\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return __iced_k(ret = _this.export_output({\n                  c_mpis: c_mpis\n                }));\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err, ret);\n          });\n        };\n      })(this));\n    };\n\n    Pair.prototype.decrypt_and_unpad = function(ciphertext, params, cb) {\n      var b, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n            funcname: \"Pair.decrypt_and_unpad\"\n          });\n          _this.priv.decrypt(ciphertext.c(), __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return m = arguments[1];\n              };\n            })(),\n            lineno: 122\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref4;\n          if (err == null) {\n            b = m.to_padded_octets(_this.pub.p);\n            _ref4 = eme_pkcs1_decode(b), err = _ref4[0], ret = _ref4[1];\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Pair.parse_output = function(buf) {\n      return Output.parse(buf);\n    };\n\n    Pair.prototype.export_output = function(args) {\n      return new Output(args);\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  Output = (function() {\n    function Output(_arg) {\n      this.c_mpis = _arg.c_mpis, this.c_bufs = _arg.c_bufs;\n    }\n\n    Output.parse = function(buf) {\n      var c_mpis, err, i, n, ret;\n      c_mpis = (function() {\n        var _i, _ref4, _results;\n        _results = [];\n        for (i = _i = 0; _i < 2; i = ++_i) {\n          _ref4 = bn.mpi_from_buffer(buf), err = _ref4[0], ret = _ref4[1], buf = _ref4[2], n = _ref4[3];\n          if (err != null) {\n            throw err;\n          }\n          _results.push(ret);\n        }\n        return _results;\n      })();\n      if (buf.length !== 0) {\n        throw new Error(\"junk at the end of input\");\n      }\n      return new Output({\n        c_mpis: c_mpis\n      });\n    };\n\n    Output.prototype.c = function() {\n      return this.c_mpis;\n    };\n\n    Output.prototype.hide = function(_arg, cb) {\n      var c_mpi, err, key, max, new_c_mpis, slosh, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, max = _arg.max, slosh = _arg.slosh;\n      max || (max = 4096);\n      slosh || (slosh = 128);\n      err = null;\n      this.c_bufs = null;\n      new_c_mpis = [];\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref4, _results, _while;\n          _ref4 = _this.c_mpis;\n          _len = _ref4.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              c_mpi = _ref4[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/elgamal.iced\",\n                  funcname: \"Output.hide\"\n                });\n                key.hide({\n                  i: c_mpi,\n                  max: max,\n                  slosh: slosh\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return tmp = arguments[1];\n                    };\n                  })(),\n                  lineno: 164\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                new_c_mpis.push(tmp);\n                (function(__iced_k) {\n                  if (err != null) {\n                    (function(__iced_k) {\n_break()\n                    })(__iced_k);\n                  } else {\n                    return __iced_k();\n                  }\n                })(_next);\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            _this.c_mpis = new_c_mpis;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Output.prototype.find = function(_arg) {\n      var j, key;\n      key = _arg.key;\n      return this.c_mpis = (function() {\n        var _i, _len, _ref4, _results;\n        _ref4 = this.c_mpis;\n        _results = [];\n        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n          j = _ref4[_i];\n          _results.push(key.find(j));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Output.prototype.get_c_bufs = function() {\n      var i;\n      if (this.c_bufs != null) {\n        return this.c_bufs;\n      } else {\n        return this.c_bufs = (function() {\n          var _i, _len, _ref4, _results;\n          _ref4 = this.c_mpis;\n          _results = [];\n          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n            i = _ref4[_i];\n            _results.push(i.to_mpi_buffer());\n          }\n          return _results;\n        }).call(this);\n      }\n    };\n\n    Output.prototype.output = function() {\n      return Buffer.concat(this.get_c_bufs());\n    };\n\n    return Output;\n\n  })();\n\n  exports.ElGamal = exports.Pair = Pair;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/elgamalse.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, BaseKey, BaseKeyPair, C, K, MRF, Pair, Priv, Pub, SRF, bn, bufeq_secure, eme_pkcs1_decode, eme_pkcs1_encode, konst, make_esc, _ref, _ref1, _ref2, _ref3,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  bn = require('./bn');\n\n  _ref = require('./util'), bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  konst = require('./const');\n\n  C = konst.openpgp;\n\n  K = konst.kb;\n\n  _ref1 = require('./basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;\n\n  _ref2 = require('./rand'), SRF = _ref2.SRF, MRF = _ref2.MRF;\n\n  _ref3 = require('./pad'), eme_pkcs1_encode = _ref3.eme_pkcs1_encode, eme_pkcs1_decode = _ref3.eme_pkcs1_decode;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.ELGAMAL_SIGN_AND_ENCRYPT;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.ORDER = [];\n\n    Pub.prototype.ORDER = Pub.ORDER;\n\n    function Pub(raw) {\n      this.raw = raw;\n    }\n\n    Pub.alloc = function(raw) {\n      return BaseKey.alloc(Pub, raw);\n    };\n\n    Pub.prototype.encrypt = function(m, cb) {\n      return cb(null);\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    Priv.ORDER = [];\n\n    Priv.prototype.ORDER = Priv.ORDER;\n\n    function Priv(raw) {\n      this.raw = raw;\n    }\n\n    Priv.prototype.serialize = function() {\n      return null;\n    };\n\n    Priv.alloc = function(raw, pub) {\n      return BaseKey.alloc(Priv, raw, {\n        pub: pub\n      });\n    };\n\n    Priv.prototype.decrypt = function(c, cb) {\n      return cb(null);\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.ELGAMAL_SIGN_AND_ENCRYPT;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      return false;\n    };\n\n    Pair.prototype.is_toxic = function() {\n      return true;\n    };\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.prototype.can_sign = function() {\n      return false;\n    };\n\n    Pair.prototype.can_decrypt = function() {\n      return false;\n    };\n\n    Pair.prototype.err = function() {\n      return new Error(\"refusing to use ElGamal Sign+Encrypt\");\n    };\n\n    Pair.parse = function(pub_raw) {\n      var ret;\n      ret = BaseKeyPair.parse(Pair, pub_raw);\n      return ret;\n    };\n\n    Pair.prototype.pad_and_encrypt = function(data, cb) {\n      return cb(this.err(), null);\n    };\n\n    Pair.prototype.decrypt_and_unpad = function(ciphertext, params, cb) {\n      return cb(this.err(), null);\n    };\n\n    Pair.parse_output = function(buf) {\n      return null;\n    };\n\n    Pair.prototype.export_output = function(args) {\n      return null;\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.ElGamalSignEncrypt = exports.Pair = Pair;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/ecc/eddsa.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BaseKey, BaseKeyPair, C, Pair, Priv, Pub, SRF, SlicerBuffer, iced, kbnacl, konst, uint_to_buffer, util, __iced_k, __iced_k_noop, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  kbnacl = require('keybase-nacl');\n\n  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;\n\n  uint_to_buffer = require('../util').uint_to_buffer;\n\n  _ref = require('../basekeypair'), BaseKeyPair = _ref.BaseKeyPair, BaseKey = _ref.BaseKey;\n\n  SRF = require('../rand').SRF;\n\n  util = require('../util');\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  Pub = (function(_super) {\n    __extends(Pub, _super);\n\n    Pub.type = C.public_key_algorithms.EDDSA;\n\n    Pub.prototype.type = Pub.type;\n\n    Pub.OID = new Buffer([0x2B, 0x06, 0x01, 0x04, 0x01, 0xDA, 0x47, 0x0F, 0x01]);\n\n    Pub.prototype.OID = Pub.OID;\n\n    Pub.MPI_LENGTH_HEADERS = new Buffer([0x1, 0x7, 0x40]);\n\n    Pub.prototype.MPI_LENGTH_HEADERS = Pub.MPI_LENGTH_HEADERS;\n\n    function Pub(_arg) {\n      this.key = _arg.key;\n    }\n\n    Pub.prototype.nbits = function() {\n      return 255;\n    };\n\n    Pub.prototype.read_params = function(sb) {};\n\n    Pub.prototype.trunc_hash = function(h) {\n      return bn.bn_from_left_n_bits(h, this.nbits());\n    };\n\n    Pub.prototype.serialize = function() {\n      var ret;\n      ret = Buffer.concat([new Buffer([this.OID.length]), this.OID, this.MPI_LENGTH_HEADERS, this.key]);\n      return ret;\n    };\n\n    Pub._alloc = function(raw) {\n      var expected, key, l, len, mpi_length_headers, oid, pre, pub, sb;\n      sb = new SlicerBuffer(raw);\n      pre = sb.rem();\n      l = sb.read_uint8();\n      oid = sb.read_buffer(l);\n      expected = Pub.OID;\n      if (!util.bufeq_secure(oid, expected)) {\n        throw new Error(\"Wrong OID in EdDSA key\");\n      }\n      mpi_length_headers = sb.read_buffer(Pub.MPI_LENGTH_HEADERS.length);\n      if (!util.bufeq_secure(mpi_length_headers, Pub.MPI_LENGTH_HEADERS)) {\n        throw new Error(\"Wrong MPI length headers\");\n      }\n      key = sb.read_buffer(kbnacl.sign.publicKeyLength);\n      pub = new Pub({\n        key: key\n      });\n      len = pre - sb.rem();\n      return [pub, len];\n    };\n\n    Pub.alloc = function(raw) {\n      var e, err, len, pub, _ref1;\n      pub = len = err = null;\n      try {\n        _ref1 = Pub._alloc(raw), pub = _ref1[0], len = _ref1[1];\n      } catch (_error) {\n        e = _error;\n        err = e;\n      }\n      return [err, pub, len];\n    };\n\n    Pub.prototype.verify = function(_arg, payload, cb) {\n      var err, naclw, r, s, sig, _, _ref1;\n      r = _arg[0], s = _arg[1];\n      naclw = kbnacl.alloc({\n        publicKey: this.key\n      });\n      sig = util.fit_to_size(kbnacl.sign.signatureLength, Buffer.concat([r, s]));\n      _ref1 = naclw.verify({\n        payload: payload,\n        sig: sig,\n        detached: true\n      }), err = _ref1[0], _ = _ref1[1];\n      return cb(err);\n    };\n\n    return Pub;\n\n  })(BaseKey);\n\n  Priv = (function(_super) {\n    __extends(Priv, _super);\n\n    function Priv(_arg) {\n      this.seed = _arg.seed, this.key = _arg.key, this.pub = _arg.pub;\n    }\n\n    Priv._alloc = function(raw, pub) {\n      var key_len, len, m, n, pre, priv, publicKey, sb, secretKey, seed, _ref1;\n      sb = new SlicerBuffer(raw);\n      pre = sb.rem();\n      key_len = Math.ceil(sb.read_uint16() / 8);\n      if ((n = key_len) !== (m = kbnacl.sign.seedLength)) {\n        throw new Error(\"Expected \" + m + \" bytes for EDDSA priv key, got \" + n + \".\");\n      }\n      seed = sb.read_buffer(key_len);\n      _ref1 = kbnacl.alloc({}).genFromSeed({\n        seed: seed\n      }), publicKey = _ref1.publicKey, secretKey = _ref1.secretKey;\n      if (!util.bufeq_secure(pub.key, publicKey)) {\n        throw new Error('Loaded EDDSA private key but it does not match the public key.');\n      }\n      priv = new Priv({\n        seed: seed,\n        key: new Buffer(secretKey),\n        pub: pub\n      });\n      len = pre - sb.rem();\n      return [priv, len];\n    };\n\n    Priv.alloc = function(raw, pub) {\n      var e, err, len, priv, _ref1;\n      priv = len = err = null;\n      try {\n        _ref1 = Priv._alloc(raw, pub), priv = _ref1[0], len = _ref1[1];\n      } catch (_error) {\n        e = _error;\n        err = e;\n      }\n      return [err, priv, len];\n    };\n\n    Priv.prototype.sign = function(h, cb) {\n      var len, nacl, ret;\n      nacl = kbnacl.alloc({\n        secretKey: this.key\n      });\n      ret = nacl.sign({\n        payload: h\n      });\n      len = kbnacl.sign.signatureLength / 2;\n      return cb([new Buffer(ret.slice(0, len)), new Buffer(ret.slice(len, len * 2))]);\n    };\n\n    Priv.prototype.serialize = function() {\n      return Buffer.concat([uint_to_buffer(16, kbnacl.sign.seedLength * 8), this.seed]);\n    };\n\n    return Priv;\n\n  })(BaseKey);\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = C.public_key_algorithms.EDDSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.klass_name = \"EDDSA\";\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.parse = function(pub_raw) {\n      return BaseKeyPair.parse(Pair, pub_raw);\n    };\n\n    Pair.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    Pair.subkey_algo = function(flags) {\n      if (flags & (C.key_flags.certify_keys | C.key_flags.sign_data)) {\n        return Pair;\n      } else {\n        return ECDH;\n      }\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = C.key_flags.certify_keys | C.key_flags.sign_data;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, hash, hasher, sig;\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      return this._dsa_verify_update_and_check_hash({\n        sig: sig,\n        data: data,\n        hasher: hasher,\n        hash: hash,\n        klass: Pair\n      }, cb);\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var h, hasher, r, s, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hasher = _arg.hasher;\n      hasher || (hasher = SHA512);\n      h = hasher(data);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/ecc/eddsa.iced\",\n            funcname: \"Pair.pad_and_sign\"\n          });\n          _this.priv.sign(h, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 208\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          r = sig[0], s = sig[1];\n          return cb(null, Buffer.concat([uint_to_buffer(16, r.length * 8), r, uint_to_buffer(16, s.length * 8), s]));\n        };\n      })(this));\n    };\n\n    Pair.parse_sig = function(slice) {\n      var buf, err, n, ret, _ref1;\n      buf = slice.peek_rest_to_buffer();\n      _ref1 = Pair.read_sig_from_buf(buf), err = _ref1[0], ret = _ref1[1], n = _ref1[2];\n      if (err != null) {\n        throw err;\n      }\n      slice.advance(n);\n      return ret;\n    };\n\n    Pair.eddsa_value_from_buffer = function(buf) {\n      var bits, bytes_len, err, ret;\n      err = ret = null;\n      if ((bits = buf.readUInt16BE(0)) > 0x100 || bits < (0x100 - 40)) {\n        err = new Error(\"Got an unexpected number of Bits for an EdDSA value: \" + bits);\n      } else {\n        bytes_len = 2 + Math.ceil(bits / 8);\n        ret = buf.slice(2, bytes_len);\n        buf = buf.slice(bytes_len);\n      }\n      return [err, ret, buf];\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var bufs, err, n, o, order, orig_len, ret, x;\n      orig_len = buf.length;\n      order = ['r', 's'];\n      err = null;\n      bufs = (function() {\n        var _i, _len, _ref1, _results;\n        _results = [];\n        for (_i = 0, _len = order.length; _i < _len; _i++) {\n          o = order[_i];\n          if (!(err == null)) {\n            continue;\n          }\n          _ref1 = Pair.eddsa_value_from_buffer(buf), err = _ref1[0], x = _ref1[1], buf = _ref1[2];\n          _results.push(x);\n        }\n        return _results;\n      })();\n      n = orig_len - buf.length;\n      ret = err != null ? null : bufs;\n      return [err, ret, n];\n    };\n\n    Pair.alloc = function(klass, raw) {\n      var e, err, len, pub, _ref1;\n      pub = len = err = null;\n      try {\n        _ref1 = Pub.alloc(raw), pub = _ref1[0], len = _ref1[1];\n      } catch (_error) {\n        e = _error;\n        err = e;\n      }\n      return [err, pub, len];\n    };\n\n    Pair.prototype.good_for_flags = function() {\n      return C.key_flags.certify_keys | C.key_flags.sign_data;\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var asp, nbits, priv, pub, publicKey, ret, secretKey, seed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      nbits = _arg.nbits, asp = _arg.asp;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/ecc/eddsa.iced\",\n            funcname: \"Pair.generate\"\n          });\n          SRF().random_bytes(kbnacl.sign.seedLength, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return seed = arguments[0];\n              };\n            })(),\n            lineno: 280\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref1;\n          _ref1 = kbnacl.alloc({}).genFromSeed({\n            seed: seed\n          }), publicKey = _ref1.publicKey, secretKey = _ref1.secretKey;\n          pub = new Pub({\n            key: new Buffer(publicKey)\n          });\n          priv = new Priv({\n            seed: seed,\n            key: new Buffer(secretKey),\n            pub: pub\n          });\n          ret = new Pair({\n            pub: pub,\n            priv: priv\n          });\n          return cb(null, ret);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.EDDSA = exports.Pair = Pair;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/cfb.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var AES, WordArray, ciphers, decrypt, encrypt, _ref;\n\n  _ref = require('triplesec'), ciphers = _ref.ciphers, WordArray = _ref.WordArray;\n\n  AES = ciphers.AES;\n\n  encrypt = function(_arg) {\n    var block_cipher_class, block_size, c, cipher, e, iv, key, list, out, plaintext, pos;\n    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, plaintext = _arg.plaintext, iv = _arg.iv;\n    block_cipher_class || (block_cipher_class = AES);\n    cipher || (cipher = new block_cipher_class(WordArray.from_buffer(key)));\n    block_size = cipher.blockSize;\n    c = WordArray.from_buffer(iv.slice(0, block_size));\n    pos = 0;\n    list = (function() {\n      var _results;\n      _results = [];\n      while (plaintext.length > pos) {\n        cipher.encryptBlock(c.words, 0);\n        e = c;\n        c = WordArray.from_buffer(plaintext.slice(pos, pos + block_size));\n        e.xor(c, {\n          n_words: c.words.length\n        });\n        pos += block_size;\n        c = e;\n        _results.push(e.to_buffer());\n      }\n      return _results;\n    })();\n    out = Buffer.concat(list);\n    return out.slice(0, plaintext.length);\n  };\n\n  decrypt = function(_arg) {\n    var b, block_cipher_class, block_size, cipher, ciphertext, d, i, iv, key, list, out, pos;\n    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, ciphertext = _arg.ciphertext, iv = _arg.iv;\n    block_cipher_class || (block_cipher_class = AES);\n    cipher || (cipher = new block_cipher_class(WordArray.from_buffer(key)));\n    block_size = cipher.blockSize;\n    iv || (iv = new Buffer((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= block_size ? _i < block_size : _i > block_size; i = 0 <= block_size ? ++_i : --_i) {\n        _results.push(0);\n      }\n      return _results;\n    })()));\n    b = WordArray.from_buffer(iv.slice(0, block_size));\n    pos = 0;\n    list = (function() {\n      var _results;\n      _results = [];\n      while (ciphertext.length > pos) {\n        cipher.encryptBlock(b.words, 0);\n        d = b;\n        b = WordArray.from_buffer(ciphertext.slice(pos, pos + block_size));\n        d.xor(b, {});\n        pos += block_size;\n        _results.push(d.to_buffer());\n      }\n      return _results;\n    })();\n    out = Buffer.concat(list);\n    return out.slice(out, ciphertext.length);\n  };\n\n  exports.encrypt = encrypt;\n\n  exports.decrypt = decrypt;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/base.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, Packet, packetsigs, util;\n\n  util = require('../util');\n\n  C = require('../../const').openpgp;\n\n  packetsigs = require('./packetsigs');\n\n  Packet = (function() {\n    function Packet() {\n      this._psc = new packetsigs.Collection();\n    }\n\n    Packet.prototype.frame_packet = function(tag, body) {\n      var bufs;\n      bufs = [new Buffer([0xc0 | tag]), util.encode_length(body.length), body];\n      return Buffer.concat(bufs);\n    };\n\n    Packet.prototype.set = function(d) {\n      var k, v, _results;\n      _results = [];\n      for (k in d) {\n        v = d[k];\n        _results.push(this[k] = v);\n      }\n      return _results;\n    };\n\n    Packet.prototype.is_signature = function() {\n      return false;\n    };\n\n    Packet.prototype.is_key_material = function() {\n      return false;\n    };\n\n    Packet.prototype.is_duplicate_primary = function() {\n      return false;\n    };\n\n    Packet.prototype.to_userid = function() {\n      return null;\n    };\n\n    Packet.prototype.to_user_attribute = function() {\n      return null;\n    };\n\n    Packet.prototype.to_literal = function() {\n      return null;\n    };\n\n    Packet.prototype.to_esk_packet = function() {\n      return null;\n    };\n\n    Packet.prototype.to_enc_data_packet = function() {\n      return null;\n    };\n\n    Packet.prototype.replay = function() {\n      return this.frame_packet(this.tag, this.raw);\n    };\n\n    Packet.prototype.inflate = function(cb) {\n      return cb(null, null);\n    };\n\n    Packet.prototype.push_sig = function(packetsig) {\n      return this._psc.push(packetsig);\n    };\n\n    Packet.prototype.get_psc = function() {\n      return this._psc;\n    };\n\n    Packet.prototype.clear_psc = function() {\n      return this._psc.clear();\n    };\n\n    Packet.prototype.get_data_signer = function() {\n      return this.get_psc().get_data_signer();\n    };\n\n    Packet.prototype.get_data_signers = function() {\n      return this.get_psc().get_data_signers();\n    };\n\n    Packet.prototype.get_signed_userids = function() {\n      return [];\n    };\n\n    Packet.prototype.get_subkey_binding = function() {\n      return null;\n    };\n\n    Packet.prototype.is_self_signed = function() {\n      return false;\n    };\n\n    return Packet;\n\n  })();\n\n  exports.Packet = Packet;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/packetsigs.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var Base, Collection, Data, SelfSig, SubkeyBinding,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Base = (function() {\n    function Base(_arg) {\n      this.sig = _arg.sig, this.key_expiration = _arg.key_expiration;\n    }\n\n    Base.prototype.typ = function() {\n      return \"none\";\n    };\n\n    Base.prototype.get_key_flags = function() {\n      return this.sig.get_key_flags();\n    };\n\n    Base.prototype.push = function(lookup) {\n      return lookup[this.typ()].push(this);\n    };\n\n    return Base;\n\n  })();\n\n  SelfSig = (function(_super) {\n    __extends(SelfSig, _super);\n\n    function SelfSig(_arg) {\n      var key_expiration, sig, sig_expiration;\n      this.userid = _arg.userid, this.user_attribute = _arg.user_attribute, this.type = _arg.type, sig = _arg.sig, this.options = _arg.options, key_expiration = _arg.key_expiration, sig_expiration = _arg.sig_expiration;\n      SelfSig.__super__.constructor.call(this, {\n        sig: sig,\n        key_expiration: key_expiration,\n        sig_expiration: sig_expiration\n      });\n    }\n\n    SelfSig.prototype.typ = function() {\n      return \"self_sig\";\n    };\n\n    SelfSig.prototype.push = function(lookup) {\n      var key, v;\n      lookup.self_sig.push(this);\n      key = this.userid != null ? this.userid.utf8() || \"\" : void 0;\n      if ((v = lookup.self_sigs_by_uid[key]) == null) {\n        v = [];\n        lookup.self_sigs_by_uid[key] = v;\n      }\n      return v.push(this);\n    };\n\n    return SelfSig;\n\n  })(Base);\n\n  SubkeyBinding = (function(_super) {\n    __extends(SubkeyBinding, _super);\n\n    SubkeyBinding.UP = 1;\n\n    SubkeyBinding.DOWN = 2;\n\n    function SubkeyBinding(_arg) {\n      var key_expiration, sig, sig_expiration;\n      this.primary = _arg.primary, sig = _arg.sig, this.direction = _arg.direction, sig_expiration = _arg.sig_expiration, key_expiration = _arg.key_expiration;\n      SubkeyBinding.__super__.constructor.call(this, {\n        sig: sig,\n        key_expiration: key_expiration,\n        sig_expiration: sig_expiration\n      });\n    }\n\n    SubkeyBinding.prototype.typ = function() {\n      return \"subkey_binding\";\n    };\n\n    SubkeyBinding.prototype.is_down = function() {\n      return this.direction === SubkeyBinding.DOWN;\n    };\n\n    return SubkeyBinding;\n\n  })(Base);\n\n  Data = (function(_super) {\n    __extends(Data, _super);\n\n    function Data(_arg) {\n      var key_expiration, sig, sig_expiration;\n      this.key = _arg.key, sig = _arg.sig, key_expiration = _arg.key_expiration, sig_expiration = _arg.sig_expiration;\n      Data.__super__.constructor.call(this, {\n        sig: sig,\n        key_expiration: key_expiration,\n        sig_expiration: sig_expiration\n      });\n    }\n\n    Data.prototype.typ = function() {\n      return \"data\";\n    };\n\n    Data.prototype.get_key_manager = function() {\n      var _ref;\n      return (_ref = this.sig) != null ? _ref.key_manager : void 0;\n    };\n\n    return Data;\n\n  })(Base);\n\n  Collection = (function() {\n    function Collection() {\n      this.clear();\n    }\n\n    Collection.prototype.clear = function() {\n      this.all = [];\n      return this.lookup = {\n        self_sig: [],\n        self_sigs_by_uid: {},\n        subkey_binding: [],\n        data: []\n      };\n    };\n\n    Collection.prototype.push = function(ps) {\n      this.all.push(ps);\n      return ps.push(this.lookup);\n    };\n\n    Collection.prototype.is_signed_subkey_of = function(primary, need_upwards_sig) {\n      var down, skb, up, _i, _len, _ref;\n      up = down = false;\n      _ref = this.lookup.subkey_binding;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        skb = _ref[_i];\n        if (skb.primary.equal(primary)) {\n          if (skb.is_down()) {\n            down = true;\n          } else {\n            up = true;\n          }\n          if (down && (up || !need_upwards_sig)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    Collection.prototype.get_all_key_flags = function() {\n      var p, ret, _i, _len, _ref;\n      ret = 0;\n      _ref = this.all;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        p = _ref[_i];\n        ret |= p.get_key_flags();\n      }\n      return ret;\n    };\n\n    Collection.prototype.get_signed_userids = function() {\n      var p, u, _i, _len, _ref, _results;\n      _ref = this.lookup.self_sig;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        p = _ref[_i];\n        if ((u = p.userid) != null) {\n          _results.push(u);\n        }\n      }\n      return _results;\n    };\n\n    Collection.prototype.get_signed_user_attributes = function() {\n      var p, u, _i, _len, _ref, _results;\n      _ref = this.lookup.self_sig;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        p = _ref[_i];\n        if ((u = p.user_attribute) != null) {\n          _results.push(u);\n        }\n      }\n      return _results;\n    };\n\n    Collection.prototype.get_self_sig = function() {\n      if (this.lookup.self_sig.length) {\n        return this.lookup.self_sig[0];\n      } else {\n        return null;\n      }\n    };\n\n    Collection.prototype.get_self_sigs = function() {\n      return this.lookup.self_sig;\n    };\n\n    Collection.prototype.is_self_signed = function() {\n      return this.get_signed_userids().length > 0;\n    };\n\n    Collection.prototype.get_data_signer = function() {\n      if (this.lookup.data.length > 0) {\n        return this.lookup.data[0];\n      } else {\n        return null;\n      }\n    };\n\n    Collection.prototype.get_data_signers = function() {\n      return this.lookup.data;\n    };\n\n    Collection.prototype.get_subkey_binding = function() {\n      if (this.lookup.subkey_binding.length) {\n        return this.lookup.subkey_binding[0];\n      } else {\n        return null;\n      }\n    };\n\n    return Collection;\n\n  })();\n\n  exports.SelfSig = SelfSig;\n\n  exports.SubkeyBinding = SubkeyBinding;\n\n  exports.Data = Data;\n\n  exports.Collection = Collection;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/signature.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, CreationTime, EmbeddedSignature, Experimental, ExpirationTime, Exportable, Features, Issuer, IssuerFingerprint, KeyExpirationTime, KeyFlags, KeyServerPreferences, NotationData, Packet, Parser, PolicyURI, Preference, PreferredCompressionAlgorithms, PreferredHashAlgorithms, PreferredKeyServer, PreferredSymmetricAlgorithms, PrimaryUserId, ReasonForRevocation, RegularExpression, Revocable, RevocationKey, S, SHA1, SHA512, Signature, SignatureTarget, Signature_v2, Signature_v2_or_v3, Signature_v3, SignersUserID, SlicerBuffer, SubPacket, Time, Trust, alloc_or_throw, assert, asymmetric, bufeq_secure, encode_length, iced, make_esc, make_time_packet, packetsigs, uint_to_buffer, unix_time, util, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  S = C.sig_subpacket;\n\n  _ref = require('../util'), encode_length = _ref.encode_length, make_time_packet = _ref.make_time_packet;\n\n  _ref1 = require('../../util'), unix_time = _ref1.unix_time, uint_to_buffer = _ref1.uint_to_buffer, bufeq_secure = _ref1.bufeq_secure;\n\n  _ref2 = require('../../hash'), alloc_or_throw = _ref2.alloc_or_throw, SHA512 = _ref2.SHA512, SHA1 = _ref2.SHA1;\n\n  asymmetric = require('../../asymmetric');\n\n  util = require('util');\n\n  packetsigs = require('./packetsigs');\n\n  assert = require('assert');\n\n  SlicerBuffer = require('../buffer').SlicerBuffer;\n\n  make_esc = require('iced-error').make_esc;\n\n  Signature_v2_or_v3 = (function(_super) {\n    __extends(Signature_v2_or_v3, _super);\n\n    function Signature_v2_or_v3(_arg) {\n      this.key = _arg.key, this.hasher = _arg.hasher, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.time = _arg.time, this.sig = _arg.sig, this.type = _arg.type, this.version = _arg.version;\n      if (this.hasher == null) {\n        this.hasher = SHA512;\n      }\n      this._framed_output = null;\n    }\n\n    Signature_v2_or_v3.prototype.is_signature = function() {\n      return true;\n    };\n\n    Signature_v2_or_v3.prototype.get_key_id = function() {\n      return this.key_id;\n    };\n\n    Signature_v2_or_v3.prototype.get_key_flags = function() {\n      return 0;\n    };\n\n    Signature_v2_or_v3.prototype.get_key_expires = function() {\n      return 0;\n    };\n\n    Signature_v2_or_v3.prototype.get_issuer_key_id = function() {\n      return this.key_id;\n    };\n\n    Signature_v2_or_v3.prototype.get_issuer_fingerprint = function() {\n      return null;\n    };\n\n    Signature_v2_or_v3.prototype.when_generated = function() {\n      return this.time;\n    };\n\n    Signature_v2_or_v3.prototype.time_of_primary_uid_sig = function() {\n      return null;\n    };\n\n    Signature_v2_or_v3.prototype.gen_prefix = function() {\n      return Buffer.concat([new Buffer([C.versions.signature.V3, this.type], uint_to_buffer(32, this.time), this.key_id, new Buffer([this.key.type, this.hasher.type]))]);\n    };\n\n    Signature_v2_or_v3.prototype.prepare_payload = function(data_packets) {\n      var bufs, dp;\n      bufs = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = data_packets.length; _i < _len; _i++) {\n          dp = data_packets[_i];\n          _results.push(dp.to_signature_payload());\n        }\n        return _results;\n      })();\n      bufs.push(new Buffer([this.type]), uint_to_buffer(32, this.time));\n      return Buffer.concat(bufs);\n    };\n\n    Signature_v2_or_v3.prototype.verify = function(data_packets, cb) {\n      var SKB, T, b, d, err, hash, payload, s, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      T = C.sig_types;\n      SKB = packetsigs.SubkeyBinding;\n      if (this.type === T.subkey_binding) {\n        data_packets = [this.primary].concat(data_packets);\n      }\n      payload = this.prepare_payload(data_packets);\n      hash = this.hasher(payload);\n      s = new SlicerBuffer(hash);\n      v = s.read_uint16();\n      (function(_this) {\n        return (function(__iced_k) {\n          if (v !== (b = _this.signed_hash_value_hash)) {\n            return __iced_k(err = new Error(\"quick hash check failed: \" + v + \" != \" + b));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/packet/signature.iced\",\n                funcname: \"Signature_v2_or_v3.verify\"\n              });\n              _this.key.verify_unpad_and_check_hash({\n                hash: hash,\n                hasher: _this.hasher,\n                sig: _this.sig\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 86\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              var _i, _j, _len, _len1, _ref3, _ref4;\n              if (err != null) {\n\n              } else if ((_ref3 = _this.type) === T.binary_doc || _ref3 === T.canonical_text) {\n                for (_i = 0, _len = data_packets.length; _i < _len; _i++) {\n                  d = data_packets[_i];\n                  d.push_sig(new packetsigs.Data({\n                    sig: _this\n                  }));\n                }\n              } else if ((_ref4 = _this.type) === T.subkey_binding) {\n                for (_j = 0, _len1 = data_packets.length; _j < _len1; _j++) {\n                  d = data_packets[_j];\n                  d.push_sig(new SKB({\n                    primary: _this.primary,\n                    sig: _this,\n                    direction: SKB.DOWN\n                  }));\n                }\n              }\n              return __iced_k();\n            });\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return Signature_v2_or_v3;\n\n  })(Packet);\n\n  Signature_v2 = (function(_super) {\n    __extends(Signature_v2, _super);\n\n    function Signature_v2() {\n      return Signature_v2.__super__.constructor.apply(this, arguments);\n    }\n\n    return Signature_v2;\n\n  })(Signature_v2_or_v3);\n\n  Signature_v3 = (function(_super) {\n    __extends(Signature_v3, _super);\n\n    function Signature_v3() {\n      return Signature_v3.__super__.constructor.apply(this, arguments);\n    }\n\n    return Signature_v3;\n\n  })(Signature_v2_or_v3);\n\n  Signature = (function(_super) {\n    __extends(Signature, _super);\n\n    function Signature(_arg) {\n      this.key = _arg.key, this.hasher = _arg.hasher, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.hashed_subpackets = _arg.hashed_subpackets, this.time = _arg.time, this.sig = _arg.sig, this.type = _arg.type, this.unhashed_subpackets = _arg.unhashed_subpackets, this.version = _arg.version;\n      if (this.hasher == null) {\n        this.hasher = SHA512;\n      }\n      if (this.hashed_subpackets == null) {\n        this.hashed_subpackets = [];\n      }\n      if (this.unhashed_subpackets == null) {\n        this.unhashed_subpackets = [];\n      }\n      this.subpacket_index = this._make_subpacket_index();\n      this._framed_output = null;\n    }\n\n    Signature.prototype.get_key_id = function() {\n      var _ref3;\n      if (this.key_id) {\n        return this.key_id;\n      } else {\n        return (_ref3 = this.subpacket_index.all[S.issuer]) != null ? _ref3.id : void 0;\n      }\n    };\n\n    Signature.prototype._make_subpacket_index = function() {\n      var p, ret, _i, _j, _len, _len1, _ref3, _ref4;\n      ret = {\n        hashed: {},\n        unhashed: {},\n        all: {}\n      };\n      _ref3 = this.hashed_subpackets;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        p = _ref3[_i];\n        ret.hashed[p.type] = p;\n        ret.all[p.type] = p;\n      }\n      _ref4 = this.unhashed_subpackets;\n      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {\n        p = _ref4[_j];\n        ret.unhashed[p.type] = p;\n        ret.all[p.type] = p;\n      }\n      return ret;\n    };\n\n    Signature.prototype.prepare_payload = function(data) {\n      var flatsp, hvalue, payload, prefix, s, trailer;\n      flatsp = Buffer.concat((function() {\n        var _i, _len, _ref3, _results;\n        _ref3 = this.hashed_subpackets;\n        _results = [];\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          s = _ref3[_i];\n          _results.push(s.to_buffer());\n        }\n        return _results;\n      }).call(this));\n      prefix = Buffer.concat([new Buffer([C.versions.signature.V4, this.type, this.key.type, this.hasher.type]), uint_to_buffer(16, flatsp.length), flatsp]);\n      trailer = Buffer.concat([new Buffer([C.versions.signature.V4, 0xff]), uint_to_buffer(32, prefix.length)]);\n      payload = Buffer.concat([data, prefix, trailer]);\n      hvalue = this.hasher(payload);\n      return {\n        prefix: prefix,\n        payload: payload,\n        hvalue: hvalue\n      };\n    };\n\n    Signature.prototype.write_unframed = function(data, cb) {\n      var esc, hvalue, payload, prefix, result2, results, s, sig, uhsp, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref3;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"write_unframed\");\n      uhsp = Buffer.concat((function() {\n        var _i, _len, _ref3, _results;\n        _ref3 = this.unhashed_subpackets;\n        _results = [];\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          s = _ref3[_i];\n          _results.push(s.to_buffer());\n        }\n        return _results;\n      }).call(this));\n      _ref3 = this.prepare_payload(data), prefix = _ref3.prefix, payload = _ref3.payload, hvalue = _ref3.hvalue;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/packet/signature.iced\",\n            funcname: \"Signature.write_unframed\"\n          });\n          _this.key.pad_and_sign(payload, {\n            hasher: _this.hasher\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 168\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          result2 = Buffer.concat([uint_to_buffer(16, uhsp.length), uhsp, new Buffer([hvalue.readUInt8(0), hvalue.readUInt8(1)]), sig]);\n          results = Buffer.concat([prefix, result2]);\n          return cb(null, results);\n        };\n      })(this));\n    };\n\n    Signature.prototype.write = function(data, cb) {\n      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/packet/signature.iced\",\n            funcname: \"Signature.write\"\n          });\n          _this.write_unframed(data, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 181\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            _this._framed_output = ret = _this.frame_packet(C.packet_tags.signature, unframed);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Signature.prototype.get_framed_output = function() {\n      return this._framed_output || this.replay();\n    };\n\n    Signature.parse = function(slice) {\n      return (new Parser(slice)).parse();\n    };\n\n    Signature.prototype.extract_key = function(data_packets) {\n      var p, _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = data_packets.length; _i < _len; _i++) {\n        p = data_packets[_i];\n        if (p.key != null) {\n          this.key = p.key;\n          break;\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    Signature.prototype.verify = function(data_packets, cb, opts) {\n      var err, p, s, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/packet/signature.iced\",\n            funcname: \"Signature.verify\"\n          });\n          _this._verify(data_packets, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 210\n          }), opts);\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _i, _len, _ref3, _results, _while;\n            _ref3 = _this.unhashed_subpackets;\n            _len = _ref3.length;\n            _i = 0;\n            _while = function(__iced_k) {\n              var _break, _continue, _next;\n              _break = __iced_k;\n              _continue = function() {\n                return iced.trampoline(function() {\n                  ++_i;\n                  return _while(__iced_k);\n                });\n              };\n              _next = _continue;\n              if (!(_i < _len)) {\n                return _break();\n              } else {\n                p = _ref3[_i];\n                if ((typeof err === \"undefined\" || err === null) && ((s = p.to_sig()) != null)) {\n                  (function(__iced_k) {\n                    if (s.type !== C.sig_types.primary_binding) {\n                      return __iced_k(err = new Error(\"unknown subpacket signature type: \" + s.type));\n                    } else {\n                      (function(__iced_k) {\n                        if (data_packets.length !== 1) {\n                          return __iced_k(err = new Error(\"Needed 1 data packet for a primary_binding signature\"));\n                        } else {\n                          subkey = data_packets[0];\n                          s.primary = _this.primary;\n                          s.key = subkey.key;\n                          (function(__iced_k) {\n                            __iced_deferrals = new iced.Deferrals(__iced_k, {\n                              parent: ___iced_passed_deferral,\n                              filename: \"/home/michal/kbpgp/src/openpgp/packet/signature.iced\",\n                              funcname: \"Signature.verify\"\n                            });\n                            s._verify([subkey], __iced_deferrals.defer({\n                              assign_fn: (function() {\n                                return function() {\n                                  return err = arguments[0];\n                                };\n                              })(),\n                              lineno: 220\n                            }), opts);\n                            __iced_deferrals._fulfill();\n                          })(__iced_k);\n                        }\n                      })(__iced_k);\n                    }\n                  })(_next);\n                } else {\n                  return _continue();\n                }\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Signature.prototype._verify = function(data_packets, cb, opts) {\n      var SKB, T, buffers, d, data, dp, err, hvalue, iki, key_expiration, n, packets, payload, ps, sig, sig_expiration, subkey, user_attribute, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      T = C.sig_types;\n      subkey = null;\n      this.data_packets = (function() {\n        switch (this.type) {\n          case T.binary_doc:\n          case T.canonical_text:\n            return data_packets;\n          case T.issuer:\n          case T.persona:\n          case T.casual:\n          case T.positive:\n          case T.certificate_revocation:\n          case T.key_revocation:\n            if ((n = data_packets.length) > 1) {\n              err = new Error(\"Only expecting one (or no) UserID-style packet(s) in a self-sig (got \" + n + \")\");\n              return [];\n            } else {\n              return [this.primary].concat(data_packets);\n            }\n            break;\n          case T.subkey_binding:\n          case T.primary_binding:\n          case T.subkey_revocation:\n            packets = [];\n            if (data_packets.length !== 1) {\n              err = new Error(\"Wrong number of data packets; expected only 1\");\n            } else if (this.primary == null) {\n              err = new Error(\"Need a primary key for subkey signature\");\n            } else {\n              subkey = data_packets[0];\n              packets = [this.primary, subkey];\n            }\n            return packets;\n          case T.direct:\n            return [this.primary].concat(data_packets);\n          default:\n            err = new Error(\"cannot verify sigtype \" + this.type);\n            return [];\n        }\n      }).call(this);\n      (function(_this) {\n        return (function(__iced_k) {\n          var _ref3;\n          if (err == null) {\n            buffers = (function() {\n              var _i, _len, _ref3, _results;\n              _ref3 = this.data_packets;\n              _results = [];\n              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n                dp = _ref3[_i];\n                _results.push(dp.to_signature_payload());\n              }\n              return _results;\n            }).call(_this);\n            data = Buffer.concat(buffers);\n            _ref3 = _this.prepare_payload(data), payload = _ref3.payload, hvalue = _ref3.hvalue;\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/packet/signature.iced\",\n                funcname: \"Signature._verify\"\n              });\n              _this.key.verify_unpad_and_check_hash({\n                sig: _this.sig,\n                hash: hvalue,\n                hasher: _this.hasher\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 270\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _i, _len, _ref3, _ref4;\n          if ((err == null) && (_this.key_manager != null)) {\n            err = _this.key_manager.pgp_check_not_expired({\n              subkey_material: _this.subkey_material,\n              now: opts != null ? opts.now : void 0\n            });\n          }\n          if (err == null) {\n            opts || (opts = {});\n            opts.subkey = subkey;\n            _ref3 = _this._check_key_sig_expiration(opts), err = _ref3[0], key_expiration = _ref3[1], sig_expiration = _ref3[2];\n            opts.subkey = null;\n          }\n          sig = _this;\n          if (err == null) {\n            SKB = packetsigs.SubkeyBinding;\n            switch (_this.type) {\n              case T.binary_doc:\n              case T.canonical_text:\n                _ref4 = _this.data_packets;\n                for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n                  d = _ref4[_i];\n                  d.push_sig(new packetsigs.Data({\n                    sig: sig\n                  }));\n                }\n                break;\n              case T.issuer:\n              case T.persona:\n              case T.casual:\n              case T.positive:\n                ps = null;\n                if ((userid = _this.data_packets[1].to_userid()) != null) {\n                  ps = new packetsigs.SelfSig({\n                    type: _this.type,\n                    userid: userid,\n                    sig: sig\n                  });\n                  userid.push_sig(ps);\n                } else if ((user_attribute = _this.data_packets[1].to_user_attribute()) != null) {\n                  ps = new packetsigs.SelfSig({\n                    type: _this.type,\n                    user_attribute: user_attribute,\n                    sig: sig,\n                    key_expiration: key_expiration,\n                    sig_expiration: sig_expiration\n                  });\n                  user_attribute.push_sig(ps);\n                }\n                if (ps) {\n                  _this.primary.push_sig(ps);\n                }\n                break;\n              case T.subkey_binding:\n                subkey.push_sig(new SKB({\n                  primary: _this.primary,\n                  sig: sig,\n                  direction: SKB.DOWN,\n                  key_expiration: key_expiration,\n                  sig_expiration: sig_expiration\n                }));\n                break;\n              case T.primary_binding:\n                subkey.push_sig(new SKB({\n                  primary: _this.primary,\n                  sig: sig,\n                  direction: SKB.UP,\n                  key_expiration: key_expiration,\n                  sig_expiration: sig_expiration\n                }));\n                break;\n              case T.subkey_revocation:\n                subkey.mark_revoked(sig);\n                break;\n              case T.key_revocation:\n                if (_this.issuer_matches_key(_this.primary)) {\n                  _this.primary.mark_revoked(sig);\n                } else {\n                  iki = _this.get_issuer_key_id();\n                  err = new Error(\"can't revoke key ID \" + (iki.toString('hex')) + \" (!= \" + (_this.primary.get_key_id().toString('hex')) + \")\");\n                }\n            }\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Signature.prototype.is_signature = function() {\n      return true;\n    };\n\n    Signature.prototype.issuer_matches_key = function(key) {\n      var fp;\n      if ((fp = this.get_issuer_fingerprint()) != null) {\n        if (!bufeq_secure(fp, this.primary.get_fingerprint())) {\n          return false;\n        }\n      }\n      return bufeq_secure(this.get_issuer_key_id(), this.primary.get_key_id());\n    };\n\n    Signature.prototype.when_generated = function() {\n      var _ref3;\n      return (_ref3 = this.subpacket_index.hashed[S.creation_time]) != null ? _ref3.time : void 0;\n    };\n\n    Signature.prototype.get_key_expires = function() {\n      var _ref3;\n      return (_ref3 = this.subpacket_index.hashed[S.key_expiration_time]) != null ? _ref3.time : void 0;\n    };\n\n    Signature.prototype.get_sig_expires = function() {\n      var _ref3;\n      return (_ref3 = this.subpacket_index.hashed[S.expiration_time]) != null ? _ref3.time : void 0;\n    };\n\n    Signature.prototype.time_primary_pair = function() {\n      var T, _ref3, _ref4;\n      T = C.sig_types;\n      if ((_ref3 = this.type) === T.issuer || _ref3 === T.persona || _ref3 === T.casual || _ref3 === T.positive) {\n        return [this.when_generated(), !!((_ref4 = this.subpacket_index.hashed[S.primary_user_id]) != null ? _ref4.flag : void 0)];\n      } else {\n        return null;\n      }\n    };\n\n    Signature.prototype._check_key_sig_expiration = function(opts) {\n      var T, err, key_creation, key_expiration, key_expiration_packet, n, now, sig_creation_packet, sig_expiration, sig_expiration_packet, _ref3;\n      err = null;\n      T = C.sig_types;\n      key_expiration = 0;\n      sig_expiration = 0;\n      if ((_ref3 = this.type) === T.issuer || _ref3 === T.persona || _ref3 === T.casual || _ref3 === T.positive || _ref3 === T.subkey_binding || _ref3 === T.primary_binding) {\n        key_creation = (opts.subkey || this.primary).timestamp;\n        key_expiration_packet = this.subpacket_index.hashed[S.key_expiration_time];\n        sig_creation_packet = this.subpacket_index.hashed[S.creation_time];\n        sig_expiration_packet = this.subpacket_index.hashed[S.sig_expiration_time];\n        now = (n = opts != null ? opts.now : void 0) != null ? n : unix_time();\n        if ((key_creation != null) && (key_expiration_packet != null ? key_expiration_packet.time : void 0)) {\n          key_expiration = key_creation + key_expiration_packet.time;\n        }\n        if ((sig_creation_packet != null) && (sig_expiration_packet != null ? sig_expiration_packet.time : void 0)) {\n          sig_expiration = sig_creation_packet.time + sig_expiration_packet.time;\n        }\n        if (key_expiration && !opts.time_travel && now > key_expiration) {\n          err = new Error(\"Key expired \" + (now - key_expiration) + \"s ago\");\n        }\n        if (sig_expiration && !opts.time_travel && now > sig_expiration) {\n          err = new Error(\"Sig expired \" + (now - key_expiration) + \"s ago\");\n        }\n      }\n      return [err, key_expiration, sig_expiration];\n    };\n\n    Signature.prototype.get_key_flags = function() {\n      var _ref3, _ref4, _ref5;\n      return ((_ref3 = this.subpacket_index) != null ? (_ref4 = _ref3.hashed) != null ? (_ref5 = _ref4[C.sig_subpacket.key_flags]) != null ? _ref5.all_flags() : void 0 : void 0 : void 0) || 0;\n    };\n\n    Signature.prototype.get_issuer_key_id = function() {\n      var _ref3, _ref4;\n      return (_ref3 = this.subpacket_index) != null ? (_ref4 = _ref3.all[C.sig_subpacket.issuer]) != null ? _ref4.id : void 0 : void 0;\n    };\n\n    Signature.prototype.get_issuer_fingerprint = function() {\n      var _ref3;\n      return (_ref3 = this.subpacket_index.all[S.issuer_fingerprint]) != null ? _ref3.fingerprint : void 0;\n    };\n\n    return Signature;\n\n  })(Packet);\n\n  SubPacket = (function() {\n    function SubPacket(type) {\n      this.type = type;\n      this.critical = false;\n      this.five_byte_len = false;\n    }\n\n    SubPacket.prototype.set_opts = function(d) {\n      var k, v;\n      for (k in d) {\n        v = d[k];\n        this[k] = v;\n      }\n      return true;\n    };\n\n    SubPacket.prototype.to_buffer = function() {\n      var inner;\n      inner = this._v_to_buffer();\n      return Buffer.concat([encode_length(inner.length + 1, this.five_byte_len), uint_to_buffer(8, this.type | (this.critical ? 0x80 : 0x00)), inner]);\n    };\n\n    SubPacket.prototype.to_sig = function() {\n      return null;\n    };\n\n    SubPacket.prototype.export_to_option = function() {\n      return null;\n    };\n\n    return SubPacket;\n\n  })();\n\n  Experimental = (function(_super) {\n    __extends(Experimental, _super);\n\n    function Experimental(buf, type) {\n      this.buf = buf;\n      this.type = type;\n    }\n\n    Experimental.parse = function(slice, type) {\n      return new Experimental(slice.consume_rest_to_buffer(), type);\n    };\n\n    Experimental.prototype._v_to_buffer = function() {\n      return this.buf;\n    };\n\n    return Experimental;\n\n  })(SubPacket);\n\n  Time = (function(_super) {\n    __extends(Time, _super);\n\n    function Time(type, time) {\n      this.time = time;\n      this.never_expires = this.time === 0;\n      Time.__super__.constructor.call(this, type);\n    }\n\n    Time.parse = function(slice, klass) {\n      return new klass(slice.read_uint32());\n    };\n\n    Time.prototype._v_to_buffer = function() {\n      return uint_to_buffer(32, this.time);\n    };\n\n    return Time;\n\n  })(SubPacket);\n\n  Preference = (function(_super) {\n    __extends(Preference, _super);\n\n    function Preference(type, v) {\n      var e, _i, _len, _ref3;\n      this.v = v;\n      Preference.__super__.constructor.call(this, type);\n      _ref3 = this.v;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        e = _ref3[_i];\n        assert(e != null);\n      }\n    }\n\n    Preference.parse = function(slice, klass) {\n      var c, v;\n      v = (function() {\n        var _i, _len, _ref3, _results;\n        _ref3 = slice.consume_rest_to_buffer();\n        _results = [];\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          c = _ref3[_i];\n          _results.push(c);\n        }\n        return _results;\n      })();\n      return new klass(v);\n    };\n\n    Preference.prototype._v_to_buffer = function() {\n      var e;\n      return new Buffer((function() {\n        var _i, _len, _ref3, _results;\n        _ref3 = this.v;\n        _results = [];\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          e = _ref3[_i];\n          _results.push(e);\n        }\n        return _results;\n      }).call(this));\n    };\n\n    return Preference;\n\n  })(SubPacket);\n\n  CreationTime = (function(_super) {\n    __extends(CreationTime, _super);\n\n    function CreationTime(t) {\n      CreationTime.__super__.constructor.call(this, S.creation_time, t);\n    }\n\n    CreationTime.parse = function(slice) {\n      return Time.parse(slice, CreationTime);\n    };\n\n    return CreationTime;\n\n  })(Time);\n\n  ExpirationTime = (function(_super) {\n    __extends(ExpirationTime, _super);\n\n    function ExpirationTime(t) {\n      ExpirationTime.__super__.constructor.call(this, S.expiration_time, t);\n    }\n\n    ExpirationTime.parse = function(slice) {\n      return Time.parse(slice, ExpirationTime);\n    };\n\n    return ExpirationTime;\n\n  })(Time);\n\n  Exportable = (function(_super) {\n    __extends(Exportable, _super);\n\n    function Exportable(flag) {\n      this.flag = flag;\n      Exportable.__super__.constructor.call(this, S.exportable_certificate);\n    }\n\n    Exportable.parse = function(slice) {\n      return new Exportable(slice.read_uint8());\n    };\n\n    Exportable.prototype._v_to_buffer = function() {\n      return uint_to_buffer(8, this.flag);\n    };\n\n    return Exportable;\n\n  })(SubPacket);\n\n  Trust = (function(_super) {\n    __extends(Trust, _super);\n\n    function Trust(level, amount) {\n      this.level = level;\n      this.amount = amount;\n      Trust.__super__.constructor.call(this, S.trust_signature);\n    }\n\n    Trust.parse = function(slice) {\n      return new Trust(slice.read_uint8(), slice.read_uint8());\n    };\n\n    Trust.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.level), uint_to_buffer(8, this.amount)]);\n    };\n\n    return Trust;\n\n  })(SubPacket);\n\n  RegularExpression = (function(_super) {\n    __extends(RegularExpression, _super);\n\n    function RegularExpression(re) {\n      this.re = re;\n      RegularExpression.__super__.constructor.call(this, S.regular_expression);\n    }\n\n    RegularExpression.parse = function(slice) {\n      var ret;\n      ret = new RegularExpression(slice.consume_rest_to_buffer().toString('utf8'));\n      return ret;\n    };\n\n    RegularExpression.prototype._v_to_buffer = function() {\n      return new Buffer(this.re, 'utf8');\n    };\n\n    return RegularExpression;\n\n  })(SubPacket);\n\n  Revocable = (function(_super) {\n    __extends(Revocable, _super);\n\n    function Revocable(flag) {\n      this.flag = flag;\n      Revocable.__super__.constructor.call(this, S.revocable);\n    }\n\n    Revocable.parse = function(slice) {\n      return new Revocable(slice.read_uint8());\n    };\n\n    Revocable.prototype._v_to_buffer = function() {\n      return uint_to_buffer(8, this.flag);\n    };\n\n    return Revocable;\n\n  })(SubPacket);\n\n  KeyExpirationTime = (function(_super) {\n    __extends(KeyExpirationTime, _super);\n\n    function KeyExpirationTime(t) {\n      KeyExpirationTime.__super__.constructor.call(this, S.key_expiration_time, t);\n    }\n\n    KeyExpirationTime.parse = function(slice) {\n      return Time.parse(slice, KeyExpirationTime);\n    };\n\n    return KeyExpirationTime;\n\n  })(Time);\n\n  PreferredSymmetricAlgorithms = (function(_super) {\n    __extends(PreferredSymmetricAlgorithms, _super);\n\n    function PreferredSymmetricAlgorithms(v) {\n      PreferredSymmetricAlgorithms.__super__.constructor.call(this, S.preferred_symmetric_algorithms, v);\n    }\n\n    PreferredSymmetricAlgorithms.parse = function(slice) {\n      return Preference.parse(slice, PreferredSymmetricAlgorithms);\n    };\n\n    return PreferredSymmetricAlgorithms;\n\n  })(Preference);\n\n  RevocationKey = (function(_super) {\n    __extends(RevocationKey, _super);\n\n    function RevocationKey(key_class, alg, fingerprint) {\n      this.key_class = key_class;\n      this.alg = alg;\n      this.fingerprint = fingerprint;\n      RevocationKey.__super__.constructor.call(this, S.revocation_key);\n    }\n\n    RevocationKey.parse = function(slice) {\n      var fp, ka, kc;\n      kc = slice.read_uint8();\n      ka = slice.read_uint8();\n      fp = slice.read_buffer(SHA1.output_length);\n      return new RevocationKey(kc, ka, fp);\n    };\n\n    RevocationKey.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.key_class), uint_to_buffer(8, this.alg), new Buffer(this.fingerprint)]);\n    };\n\n    return RevocationKey;\n\n  })(SubPacket);\n\n  Issuer = (function(_super) {\n    __extends(Issuer, _super);\n\n    function Issuer(id) {\n      this.id = id;\n      Issuer.__super__.constructor.call(this, S.issuer);\n    }\n\n    Issuer.parse = function(slice) {\n      return new Issuer(slice.read_buffer(8));\n    };\n\n    Issuer.prototype._v_to_buffer = function() {\n      return new Buffer(this.id);\n    };\n\n    return Issuer;\n\n  })(SubPacket);\n\n  NotationData = (function(_super) {\n    __extends(NotationData, _super);\n\n    function NotationData(flags, name, value) {\n      this.flags = flags;\n      this.name = name;\n      this.value = value;\n      NotationData.__super__.constructor.call(this, S.notation_data);\n    }\n\n    NotationData.parse = function(slice) {\n      var flags, name, nl, value, vl;\n      flags = slice.read_uint32();\n      nl = slice.read_uint16();\n      vl = slice.read_uint16();\n      name = slice.read_buffer(nl);\n      value = slice.read_buffer(vl);\n      return new NotationData(flags, name, value);\n    };\n\n    NotationData.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(32, this.flags), uint_to_buffer(16, this.name.length), uint_to_buffer(16, this.value.length), new Buffer(this.name), new Buffer(this.value)]);\n    };\n\n    return NotationData;\n\n  })(SubPacket);\n\n  PreferredHashAlgorithms = (function(_super) {\n    __extends(PreferredHashAlgorithms, _super);\n\n    function PreferredHashAlgorithms(v) {\n      PreferredHashAlgorithms.__super__.constructor.call(this, S.preferred_hash_algorithms, v);\n    }\n\n    PreferredHashAlgorithms.parse = function(slice) {\n      return Preference.parse(slice, PreferredHashAlgorithms);\n    };\n\n    return PreferredHashAlgorithms;\n\n  })(Preference);\n\n  PreferredCompressionAlgorithms = (function(_super) {\n    __extends(PreferredCompressionAlgorithms, _super);\n\n    function PreferredCompressionAlgorithms(v) {\n      PreferredCompressionAlgorithms.__super__.constructor.call(this, S.preferred_compression_algorithms, v);\n    }\n\n    PreferredCompressionAlgorithms.parse = function(slice) {\n      return Preference.parse(slice, PreferredCompressionAlgorithms);\n    };\n\n    return PreferredCompressionAlgorithms;\n\n  })(Preference);\n\n  KeyServerPreferences = (function(_super) {\n    __extends(KeyServerPreferences, _super);\n\n    function KeyServerPreferences(v) {\n      KeyServerPreferences.__super__.constructor.call(this, S.key_server_preferences, v);\n    }\n\n    KeyServerPreferences.parse = function(slice) {\n      return Preference.parse(slice, KeyServerPreferences);\n    };\n\n    return KeyServerPreferences;\n\n  })(Preference);\n\n  Features = (function(_super) {\n    __extends(Features, _super);\n\n    function Features(v) {\n      Features.__super__.constructor.call(this, S.features, v);\n    }\n\n    Features.parse = function(slice) {\n      return Preference.parse(slice, Features);\n    };\n\n    return Features;\n\n  })(Preference);\n\n  PreferredKeyServer = (function(_super) {\n    __extends(PreferredKeyServer, _super);\n\n    function PreferredKeyServer(server) {\n      this.server = server;\n      PreferredKeyServer.__super__.constructor.call(this, S.preferred_key_server);\n    }\n\n    PreferredKeyServer.parse = function(slice) {\n      return new PreferredKeyServer(slice.consume_rest_to_buffer());\n    };\n\n    PreferredKeyServer.prototype._v_to_buffer = function() {\n      return this.server;\n    };\n\n    return PreferredKeyServer;\n\n  })(SubPacket);\n\n  PrimaryUserId = (function(_super) {\n    __extends(PrimaryUserId, _super);\n\n    function PrimaryUserId(flag) {\n      this.flag = flag;\n      PrimaryUserId.__super__.constructor.call(this, S.primary_user_id);\n    }\n\n    PrimaryUserId.parse = function(slice) {\n      return new PrimaryUserId(slice.read_uint8());\n    };\n\n    PrimaryUserId.prototype._v_to_buffer = function() {\n      return uint_to_buffer(8, this.flag);\n    };\n\n    return PrimaryUserId;\n\n  })(SubPacket);\n\n  PolicyURI = (function(_super) {\n    __extends(PolicyURI, _super);\n\n    function PolicyURI(flag) {\n      this.flag = flag;\n      PolicyURI.__super__.constructor.call(this, S.policy_uri);\n    }\n\n    PolicyURI.parse = function(slice) {\n      return new PolicyURI(slice.consume_rest_to_buffer());\n    };\n\n    PolicyURI.prototype._v_to_buffer = function() {\n      return this.flag;\n    };\n\n    return PolicyURI;\n\n  })(SubPacket);\n\n  KeyFlags = (function(_super) {\n    __extends(KeyFlags, _super);\n\n    function KeyFlags(v) {\n      KeyFlags.__super__.constructor.call(this, S.key_flags, v);\n    }\n\n    KeyFlags.parse = function(slice) {\n      return Preference.parse(slice, KeyFlags);\n    };\n\n    KeyFlags.prototype.all_flags = function() {\n      var e, ret, _i, _len, _ref3;\n      ret = 0;\n      _ref3 = this.v;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        e = _ref3[_i];\n        ret |= e;\n      }\n      return ret;\n    };\n\n    return KeyFlags;\n\n  })(Preference);\n\n  SignersUserID = (function(_super) {\n    __extends(SignersUserID, _super);\n\n    function SignersUserID(uid) {\n      this.uid = uid;\n      SignersUserID.__super__.constructor.call(this, S.signers_user_id);\n    }\n\n    SignersUserID.parse = function(slice) {\n      return new SignersUserID(slice.consume_rest_to_buffer());\n    };\n\n    SignersUserID.prototype._v_to_buffer = function() {\n      return this.uid;\n    };\n\n    return SignersUserID;\n\n  })(SubPacket);\n\n  ReasonForRevocation = (function(_super) {\n    __extends(ReasonForRevocation, _super);\n\n    function ReasonForRevocation(flag, reason) {\n      this.flag = flag;\n      this.reason = reason;\n      ReasonForRevocation.__super__.constructor.call(this, S.reason_for_revocation);\n    }\n\n    ReasonForRevocation.parse = function(slice) {\n      var flag, reason;\n      flag = slice.read_uint8();\n      reason = slice.consume_rest_to_buffer();\n      return new ReasonForRevocation(flag, reason);\n    };\n\n    ReasonForRevocation.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.flag), this.reason]);\n    };\n\n    return ReasonForRevocation;\n\n  })(SubPacket);\n\n  SignatureTarget = (function(_super) {\n    __extends(SignatureTarget, _super);\n\n    function SignatureTarget(pub_key_alg, hasher, hval) {\n      this.pub_key_alg = pub_key_alg;\n      this.hasher = hasher;\n      this.hval = hval;\n      SignatureTarget.__super__.constructor.call(this, S.signature_target);\n    }\n\n    SignatureTarget.parse = function(slice) {\n      var hasher, hval, pka;\n      pka = slice.read_uint8();\n      hasher = alloc_or_throw(slice.read_uint8());\n      hval = slice.read_buffer(hasher.output_length);\n      return new SignatureTarget(pka, hasher, hval);\n    };\n\n    SignatureTarget.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.pub_key_alg), uint_to_buffer(8, this.hasher.type), this.hval]);\n    };\n\n    return SignatureTarget;\n\n  })(SubPacket);\n\n  EmbeddedSignature = (function(_super) {\n    __extends(EmbeddedSignature, _super);\n\n    function EmbeddedSignature(_arg) {\n      this.sig = _arg.sig, this.rawsig = _arg.rawsig;\n      EmbeddedSignature.__super__.constructor.call(this, S.embedded_signature);\n    }\n\n    EmbeddedSignature.prototype._v_to_buffer = function() {\n      return this.rawsig;\n    };\n\n    EmbeddedSignature.prototype.to_sig = function() {\n      return this.sig;\n    };\n\n    EmbeddedSignature.parse = function(slice) {\n      var rawsig, sig;\n      rawsig = slice.peek_rest_to_buffer();\n      sig = Signature.parse(slice);\n      return new EmbeddedSignature({\n        sig: sig,\n        rawsig: rawsig\n      });\n    };\n\n    return EmbeddedSignature;\n\n  })(SubPacket);\n\n  IssuerFingerprint = (function(_super) {\n    __extends(IssuerFingerprint, _super);\n\n    function IssuerFingerprint(n, fingerprint) {\n      this.n = n;\n      this.fingerprint = fingerprint;\n      IssuerFingerprint.__super__.constructor.call(this, S.issuer_fingerprint);\n    }\n\n    IssuerFingerprint.parse = function(slice) {\n      var fp, n;\n      n = slice.read_uint8();\n      fp = slice.consume_rest_to_buffer();\n      return new IssuerFingerprint(n, fp);\n    };\n\n    IssuerFingerprint.prototype._v_to_buffer = function() {\n      return Buffer.concat([uint_to_buffer(8, this.n), this.fingerprint]);\n    };\n\n    return IssuerFingerprint;\n\n  })(SubPacket);\n\n  exports.Signature = Signature;\n\n  Parser = (function() {\n    function Parser(slice) {\n      this.slice = slice;\n    }\n\n    Parser.prototype.parse_v2_or_v3 = function(v, klass) {\n      var o;\n      if (this.slice.read_uint8() !== 5) {\n        throw new error(\"Bad one-octet length\");\n      }\n      o = {};\n      o.type = this.slice.read_uint8();\n      o.time = this.slice.read_uint32();\n      o.sig_data = this.slice.peek_rest_to_buffer();\n      o.key_id = this.slice.read_buffer(8);\n      o.public_key_class = asymmetric.get_class(this.slice.read_uint8());\n      o.hasher = alloc_or_throw(this.slice.read_uint8());\n      o.signed_hash_value_hash = this.slice.read_uint16();\n      o.sig = o.public_key_class.parse_sig(this.slice);\n      o.version = v;\n      return new klass(o);\n    };\n\n    Parser.prototype.parse_v4 = function() {\n      var end, hashed_subpacket_count, o, unhashed_subpacket_count;\n      o = {};\n      o.type = this.slice.read_uint8();\n      o.public_key_class = asymmetric.get_class(this.slice.read_uint8());\n      o.hasher = alloc_or_throw(this.slice.read_uint8());\n      hashed_subpacket_count = this.slice.read_uint16();\n      end = this.slice.i + hashed_subpacket_count;\n      o.sig_data = this.slice.peek_to_buffer(hashed_subpacket_count);\n      o.hashed_subpackets = ((function() {\n        var _results;\n        _results = [];\n        while (this.slice.i < end) {\n          _results.push(this.parse_subpacket());\n        }\n        return _results;\n      }).call(this));\n      unhashed_subpacket_count = this.slice.read_uint16();\n      end = this.slice.i + unhashed_subpacket_count;\n      o.unhashed_subpackets = ((function() {\n        var _results;\n        _results = [];\n        while (this.slice.i < end) {\n          _results.push(this.parse_subpacket());\n        }\n        return _results;\n      }).call(this));\n      o.signed_hash_value_hash = this.slice.read_uint16();\n      o.sig = o.public_key_class.parse_sig(this.slice);\n      o.version = 4;\n      return new Signature(o);\n    };\n\n    Parser.prototype.parse_subpacket = function() {\n      var critical, end, five_byte_len, klass, len, raw_type, ret, type, _ref3;\n      _ref3 = this.slice.read_v4_length(), len = _ref3[0], five_byte_len = _ref3[1];\n      raw_type = this.slice.read_uint8();\n      type = raw_type & 0x7f;\n      critical = !!(raw_type & 0x80);\n      end = this.slice.clamp(len - 1);\n      klass = (function() {\n        switch (type) {\n          case S.creation_time:\n            return CreationTime;\n          case S.expiration_time:\n            return ExpirationTime;\n          case S.exportable_certificate:\n            return Exportable;\n          case S.trust_signature:\n            return Trust;\n          case S.regular_expression:\n            return RegularExpression;\n          case S.revocable:\n            return Revocable;\n          case S.key_expiration_time:\n            return KeyExpirationTime;\n          case S.preferred_symmetric_algorithms:\n            return PreferredSymmetricAlgorithms;\n          case S.revocation_key:\n            return RevocationKey;\n          case S.issuer:\n            return Issuer;\n          case S.notation_data:\n            return NotationData;\n          case S.preferred_hash_algorithms:\n            return PreferredHashAlgorithms;\n          case S.preferred_compression_algorithms:\n            return PreferredCompressionAlgorithms;\n          case S.key_server_preferences:\n            return KeyServerPreferences;\n          case S.preferred_key_server:\n            return PreferredKeyServer;\n          case S.primary_user_id:\n            return PrimaryUserId;\n          case S.policy_uri:\n            return PolicyURI;\n          case S.key_flags:\n            return KeyFlags;\n          case S.signers_user_id:\n            return SignersUserID;\n          case S.reason_for_revocation:\n            return ReasonForRevocation;\n          case S.features:\n            return Features;\n          case S.signature_target:\n            return SignatureTarget;\n          case S.embedded_signature:\n            return EmbeddedSignature;\n          case S.issuer_fingerprint:\n            return IssuerFingerprint;\n          default:\n            if (type >= S.experimental_low && type <= S.experimental_high) {\n              return Experimental;\n            } else {\n              throw new Error(\"Unknown signature subpacket: \" + type);\n            }\n        }\n      })();\n      ret = klass.parse(this.slice, type);\n      ret.set_opts({\n        critical: critical,\n        five_byte_len: five_byte_len\n      });\n      this.slice.unclamp(end);\n      return ret;\n    };\n\n    Parser.prototype.parse = function() {\n      var version;\n      version = this.slice.read_uint8();\n      switch (version) {\n        case C.versions.signature.V2:\n          return this.parse_v2_or_v3(version, Signature_v2);\n        case C.versions.signature.V3:\n          return this.parse_v2_or_v3(version, Signature_v3);\n        case C.versions.signature.V4:\n          return this.parse_v4();\n        default:\n          throw new Error(\"Unknown signature version: \" + version);\n      }\n    };\n\n    return Parser;\n\n  })();\n\n  exports.CreationTime = CreationTime;\n\n  exports.KeyFlags = KeyFlags;\n\n  exports.KeyExpirationTime = KeyExpirationTime;\n\n  exports.PreferredSymmetricAlgorithms = PreferredSymmetricAlgorithms;\n\n  exports.PreferredHashAlgorithms = PreferredHashAlgorithms;\n\n  exports.PreferredCompressionAlgorithms = PreferredCompressionAlgorithms;\n\n  exports.Features = Features;\n\n  exports.KeyServerPreferences = KeyServerPreferences;\n\n  exports.Issuer = Issuer;\n\n  exports.EmbeddedSignature = EmbeddedSignature;\n\n  exports.PrimaryUserId = PrimaryUserId;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/asymmetric.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, DSA, ECDH, ECDSA, EDDSA, ElGamal, RSA, get_class;\n\n  C = require('./const').openpgp.public_key_algorithms;\n\n  RSA = require('./rsa').RSA;\n\n  DSA = require('./dsa').DSA;\n\n  ElGamal = require('./elgamal').ElGamal;\n\n  ECDSA = require('./ecc/ecdsa').ECDSA;\n\n  ECDH = require('./ecc/ecdh').ECDH;\n\n  EDDSA = require('./ecc/eddsa').EDDSA;\n\n  get_class = function(n) {\n    switch (n) {\n      case C.RSA:\n      case C.RSA_ENCRYPT_ONLY:\n      case C.RSA_SIGN_ONLY:\n        return RSA;\n      case C.ELGAMAL:\n        return ElGamal;\n      case C.DSA:\n        return DSA;\n      case C.ECDSA:\n        return ECDSA;\n      case C.ECDH:\n        return ECDH;\n      case C.EDDSA:\n        return EDDSA;\n      default:\n        throw new Error(\"unknown public key system: \" + n);\n    }\n  };\n\n  module.exports = {\n    get_class: get_class,\n    RSA: RSA,\n    DSA: DSA,\n    ElGamal: ElGamal\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/s2k.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, S2K, SHA256, SecretKeyMaterial, alloc, iterated_s2k, streamers, triplesec, _iterated_s2k_cache, _ref;\n\n  triplesec = require('triplesec');\n\n  C = require('../const').openpgp;\n\n  _ref = require('../hash'), alloc = _ref.alloc, SHA256 = _ref.SHA256, streamers = _ref.streamers;\n\n  S2K = (function() {\n    S2K.prototype._count = function(c, bias) {\n      return (16 + (c & 15)) << ((c >> 4) + bias);\n    };\n\n    function S2K() {\n      this.hash = SHA256;\n      this.streamer = streamers.SHA256();\n    }\n\n    S2K.prototype.set_hash_algorithm = function(which) {\n      if ((this.hash = alloc(which)) != null) {\n        return this.streamer = streamers[this.hash.algname]();\n      } else {\n        console.warn(\"No such hash: \" + which + \"; defaulting to SHA-256\");\n        this.hash = SHA256;\n        return this.streamer = streamers.SHA256();\n      }\n    };\n\n    S2K.prototype.read = function(slice) {\n      var c;\n      this.type = slice.read_uint8();\n      switch (this.type) {\n        case C.s2k.plain:\n          this.set_hash_algorithm(slice.read_uint8());\n          break;\n        case C.s2k.salt:\n          this.set_hash_algorithm(slice.read_uint8());\n          this.salt = slice.read_buffer(8);\n          break;\n        case C.s2k.salt_iter:\n          this.set_hash_algorithm(slice.read_uint8());\n          this.salt = slice.read_buffer(8);\n          this.EXPBIAS = 6;\n          c = slice.read_uint8();\n          this.count = this._count(c, this.EXPBIAS);\n          break;\n        case C.s2k.gnu:\n          this.read_gnu_extensions(slice);\n          break;\n        default:\n          throw new Error(\"unknown s2k type! \" + this.type);\n      }\n      return this;\n    };\n\n    S2K.prototype.read_gnu_extensions = function(slice) {\n      var buf, gnu_ext_type, id, version;\n      version = slice.read_uint8();\n      if ((id = (buf = slice.read_buffer(3)).toString('utf8')) === \"GNU\") {\n        gnu_ext_type = slice.read_uint8() + 1000;\n        switch (gnu_ext_type) {\n          case 1001:\n            return this.type = C.s2k.gnu_dummy;\n          default:\n            throw new Error(\"unknown s2k gnu protection mode: \" + gnu_ext_type);\n        }\n      } else {\n        throw new Error(\"Malformed GNU-extension: \" + ext);\n      }\n    };\n\n    S2K.prototype.write = function(passphrase, salt, c, keysize) {\n      var type;\n      this.type = type = 3;\n      this.salt = salt;\n      this.count = this._count(c, 6);\n      this.s2kLength = 10;\n      return this.produce_key(passphrase, keysize);\n    };\n\n    S2K.prototype.is_dummy = function() {\n      return this.type === C.s2k.gnu_dummy;\n    };\n\n    S2K.prototype.produce_key = function(passphrase, numBytes) {\n      var key, key2, prefix, ret, seed;\n      if (numBytes == null) {\n        numBytes = 16;\n      }\n      ret = (function() {\n        switch (this.type) {\n          case C.s2k.plain:\n            return this.hash(passphrase);\n          case C.s2k.salt:\n            return this.hash(Buffer.concat([this.salt, passphrase]));\n          case C.s2k.salt_iter:\n            seed = Buffer.concat([this.salt, passphrase]);\n            key = iterated_s2k({\n              alg: this.hash.algname,\n              seed: seed,\n              count: this.count\n            });\n            if ((numBytes != null) && (numBytes === 24 || numBytes === 32)) {\n              prefix = new Buffer([0]);\n              key2 = iterated_s2k({\n                alg: this.hash.algname,\n                seed: seed,\n                count: this.count,\n                prefix: prefix\n              });\n              return Buffer.concat([key, key2]);\n            } else {\n              return key;\n            }\n            break;\n          default:\n            return null;\n        }\n      }).call(this);\n      return ret.slice(0, numBytes);\n    };\n\n    return S2K;\n\n  })();\n\n  _iterated_s2k_cache = {};\n\n  iterated_s2k = function(_arg) {\n    var alg, bigbuf, count, i, k, n, prefix, rem, rembuf, ret, seed, streamer, tot, val;\n    alg = _arg.alg, seed = _arg.seed, count = _arg.count, prefix = _arg.prefix;\n    k = \"\" + alg + \"-\" + (seed.toString('base64')) + \"-\" + count;\n    if (prefix != null) {\n      k += \"-\" + (prefix.toString('base64'));\n    }\n    if ((val = _iterated_s2k_cache[k]) != null) {\n      return val;\n    }\n    streamer = streamers[alg]();\n    if (prefix != null) {\n      streamer.update(prefix);\n    }\n    bigbuf = Buffer.concat((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; _i < 4096; i = ++_i) {\n        _results.push(seed);\n      }\n      return _results;\n    })());\n    tot = 0;\n    while (tot + bigbuf.length <= count) {\n      streamer.update(bigbuf);\n      tot += bigbuf.length;\n    }\n    rem = count - tot;\n    n = Math.ceil(rem / seed.length);\n    rembuf = Buffer.concat((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {\n        _results.push(seed);\n      }\n      return _results;\n    })());\n    ret = streamer(rembuf.slice(0, rem));\n    _iterated_s2k_cache[k] = ret;\n    return ret;\n  };\n\n  SecretKeyMaterial = (function() {\n    function SecretKeyMaterial() {\n      this.s2k_convention = null;\n      this.s2k = null;\n      this.iv = null;\n      this.cipher = null;\n      this.payload = null;\n    }\n\n    SecretKeyMaterial.prototype.is_dummy = function() {\n      return (this.s2k != null) && this.s2k.is_dummy();\n    };\n\n    SecretKeyMaterial.prototype.has_private = function() {\n      return !this.is_dummy();\n    };\n\n    SecretKeyMaterial.prototype.is_locked = function() {\n      return (this.s2k_convention !== C.s2k_convention.none) && !(this.is_dummy());\n    };\n\n    return SecretKeyMaterial;\n\n  })();\n\n  exports.S2K = S2K;\n\n  exports.SecretKeyMaterial = SecretKeyMaterial;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/sess.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, C, Decryptor, MDC, MDC_Parser, PKESK, PKESK_Parser, Packet, SEIPD, SEIPD_Parser, SHA1, asymmetric, bufeq_fast, bufeq_secure, encrypt, iced, make_esc, streamers, uint_to_buffer, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  asymmetric = require('../../asymmetric');\n\n  _ref = require('../../hash'), SHA1 = _ref.SHA1, streamers = _ref.streamers;\n\n  _ref1 = require('../../util'), uint_to_buffer = _ref1.uint_to_buffer, bufeq_secure = _ref1.bufeq_secure, bufeq_fast = _ref1.bufeq_fast;\n\n  _ref2 = require('../ocfb'), encrypt = _ref2.encrypt, Decryptor = _ref2.Decryptor;\n\n  ASP = require('pgp-utils').util.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  PKESK = (function(_super) {\n    __extends(PKESK, _super);\n\n    function PKESK(_arg) {\n      this.crypto_type = _arg.crypto_type, this.key_id = _arg.key_id, this.ekey = _arg.ekey;\n    }\n\n    PKESK.parse = function(slice) {\n      return (new PKESK_Parser(slice)).parse();\n    };\n\n    PKESK.prototype.to_esk_packet = function() {\n      return this;\n    };\n\n    PKESK.prototype.get_key_id = function() {\n      return this.key_id;\n    };\n\n    PKESK.prototype.write_unframed = function(cb) {\n      var bufs, err, ret;\n      bufs = [uint_to_buffer(8, C.versions.PKESK), this.key_id, uint_to_buffer(8, this.crypto_type), this.ekey.output()];\n      ret = Buffer.concat(bufs);\n      err = null;\n      return cb(err, ret);\n    };\n\n    PKESK.prototype.write = function(cb) {\n      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n            funcname: \"PKESK.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 36\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            ret = _this.frame_packet(C.packet_tags.PKESK, unframed);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    return PKESK;\n\n  })(Packet);\n\n  SEIPD = (function(_super) {\n    __extends(SEIPD, _super);\n\n    function SEIPD(_arg) {\n      this.ciphertext = _arg.ciphertext;\n    }\n\n    SEIPD.parse = function(slice) {\n      return (new SEIPD_Parser(slice)).parse();\n    };\n\n    SEIPD.prototype.to_enc_data_packet = function() {\n      return this;\n    };\n\n    SEIPD.prototype.check = function() {};\n\n    SEIPD.prototype.decrypt = function(_arg, cb) {\n      var asp, cipher, eng, err, esc, mdc, plaintext, prefix, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      cipher = _arg.cipher, asp = _arg.asp;\n      eng = new Decryptor({\n        cipher: cipher,\n        ciphertext: this.ciphertext,\n        asp: asp\n      });\n      esc = make_esc(cb, \"SEIPD::decrypt\");\n      asp = ASP.make(asp);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n            funcname: \"SEIPD.decrypt\"\n          });\n          eng.check(esc(__iced_deferrals.defer({\n            lineno: 63\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n              funcname: \"SEIPD.decrypt\"\n            });\n            eng.dec(esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return pt = arguments[0];\n                };\n              })(),\n              lineno: 64\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            var _ref3;\n            _ref3 = MDC.parse(pt), mdc = _ref3[0], plaintext = _ref3[1];\n            prefix = eng.get_prefix();\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n                funcname: \"SEIPD.decrypt\"\n              });\n              mdc.compute({\n                prefix: prefix,\n                plaintext: plaintext,\n                asp: asp\n              }, esc(__iced_deferrals.defer({\n                lineno: 70\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              err = mdc.check() ? null : new Error(\"MDC mismatch\");\n              return cb(err, plaintext);\n            });\n          });\n        };\n      })(this));\n    };\n\n    SEIPD.prototype.encrypt = function(_arg, cb) {\n      var asp, cipher, esc, mdc, mdc_buf, plaintext, prefixrandom, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      cipher = _arg.cipher, plaintext = _arg.plaintext, prefixrandom = _arg.prefixrandom, asp = _arg.asp;\n      mdc = new MDC({});\n      esc = make_esc(cb, \"SEIPD::encrypt\");\n      asp = ASP.make(asp);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n            funcname: \"SEIPD.encrypt\"\n          });\n          mdc.compute({\n            plaintext: plaintext,\n            prefix: prefixrandom,\n            asp: asp\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return mdc_buf = arguments[0];\n              };\n            })(),\n            lineno: 81\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          plaintext = Buffer.concat([plaintext, MDC.header, mdc_buf]);\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n              funcname: \"SEIPD.encrypt\"\n            });\n            encrypt({\n              cipher: cipher,\n              plaintext: plaintext,\n              prefixrandom: prefixrandom\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function(__slot_1) {\n                return function() {\n                  return __slot_1.ciphertext = arguments[0];\n                };\n              })(_this),\n              lineno: 83\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            return cb(null);\n          });\n        };\n      })(this));\n    };\n\n    SEIPD.prototype.write_unframed = function(cb) {\n      var err, ret;\n      err = ret = null;\n      ret = Buffer.concat([uint_to_buffer(8, C.versions.SEIPD), this.ciphertext]);\n      return cb(err, ret);\n    };\n\n    SEIPD.prototype.write = function(cb) {\n      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      ret = err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n            funcname: \"SEIPD.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 97\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = _this.frame_packet(C.packet_tags.SEIPD, unframed);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    return SEIPD;\n\n  })(Packet);\n\n  MDC = (function(_super) {\n    __extends(MDC, _super);\n\n    MDC.header = new Buffer([0xc0 | C.packet_tags.MDC, SHA1.output_length]);\n\n    MDC.prototype.header = MDC.header;\n\n    function MDC(_arg) {\n      this.digest = _arg.digest;\n    }\n\n    MDC.parse = function(buf) {\n      return (new MDC_Parser(buf)).parse();\n    };\n\n    MDC.prototype.compute = function(_arg, cb) {\n      var asp, esc, hasher, i, plaintext, prefix, step, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      plaintext = _arg.plaintext, prefix = _arg.prefix, asp = _arg.asp;\n      asp = ASP.make(asp);\n      hasher = streamers.SHA1();\n      hasher.update(Buffer.concat([prefix, prefix.slice(-2)]));\n      esc = make_esc(cb, \"MDC::compute\");\n      step = 0x100000;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _begin, _end, _i, _positive, _results, _step, _while;\n          i = 0;\n          _begin = 0;\n          _end = plaintext.length;\n          _step = step;\n          _positive = _step > 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                i += _step;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!!((_positive === true && i >= plaintext.length) || (_positive === false && i <= plaintext.length))) {\n              return _break();\n            } else {\n\n              hasher.update(plaintext.slice(i, i + step));\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced\",\n                  funcname: \"MDC.compute\"\n                });\n                asp.progress({\n                  what: \"MDC\",\n                  total: plaintext.length,\n                  i: i\n                }, esc(__iced_deferrals.defer({\n                  lineno: 122\n                })));\n                __iced_deferrals._fulfill();\n              })(_next);\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          hasher.update(_this.header);\n          _this.computed = hasher();\n          return cb(null, _this.computed);\n        };\n      })(this));\n    };\n\n    MDC.prototype.check = function() {\n      return bufeq_secure(this.digest, this.computed);\n    };\n\n    return MDC;\n\n  })(Packet);\n\n  MDC_Parser = (function() {\n    function MDC_Parser(buf) {\n      this.buf = buf;\n    }\n\n    MDC_Parser.prototype.parse = function() {\n      var chunk, digest, hl, len, rem;\n      hl = MDC.header.length;\n      len = SHA1.output_length + hl;\n      rem = this.buf.slice(0, -len);\n      chunk = this.buf.slice(-len);\n      if (!bufeq_fast(chunk.slice(0, hl), MDC.header)) {\n        throw new Error('Missing MDC header');\n      }\n      digest = chunk.slice(hl);\n      return [\n        new MDC({\n          digest: digest\n        }), rem\n      ];\n    };\n\n    return MDC_Parser;\n\n  })();\n\n  SEIPD_Parser = (function() {\n    function SEIPD_Parser(slice) {\n      this.slice = slice;\n    }\n\n    SEIPD_Parser.prototype.payload_split = function(raw) {};\n\n    SEIPD_Parser.prototype.parse = function() {\n      var ciphertext, v;\n      if ((v = this.slice.read_uint8()) !== C.versions.SEIPD) {\n        throw new Error(\"Unknown SEIPD version \" + v);\n      }\n      ciphertext = this.slice.consume_rest_to_buffer();\n      return new SEIPD({\n        ciphertext: ciphertext\n      });\n    };\n\n    return SEIPD_Parser;\n\n  })();\n\n  PKESK_Parser = (function() {\n    function PKESK_Parser(slice) {\n      this.slice = slice;\n    }\n\n    PKESK_Parser.prototype.parse = function() {\n      var crypto_type, ekey, key_id, klass, v;\n      if ((v = this.slice.read_uint8()) !== C.versions.PKESK) {\n        throw new Error(\"Unknown PKESK version: \" + v);\n      }\n      key_id = this.slice.read_buffer(8);\n      crypto_type = this.slice.read_uint8();\n      klass = asymmetric.get_class(crypto_type);\n      ekey = klass.parse_output(this.slice.consume_rest_to_buffer());\n      return new PKESK({\n        crypto_type: crypto_type,\n        key_id: key_id,\n        ekey: ekey\n      });\n    };\n\n    return PKESK_Parser;\n\n  })();\n\n  exports.SEIPD = SEIPD;\n\n  exports.PKESK = PKESK;\n\n  exports.MDC = MDC;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/ocfb.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var AES, ASP, Base, Decryptor, Encryptor, SlicerBuffer, WordArray, decrypt, encrypt, iced, make_esc, repeat, rng, test, triplesec, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  WordArray = require('triplesec').WordArray;\n\n  SlicerBuffer = require('./buffer').SlicerBuffer;\n\n  triplesec = require('triplesec');\n\n  AES = triplesec.ciphers.AES;\n\n  ASP = require('pgp-utils').util.ASP;\n\n  make_esc = require('iced-error').make_esc;\n\n  repeat = function(b, n) {\n    return Buffer.concat([b, b.slice(b.length - n)]);\n  };\n\n  Base = (function() {\n    function Base(_arg) {\n      var asp, key;\n      this.block_cipher_class = _arg.block_cipher_class, key = _arg.key, this.cipher = _arg.cipher, this.resync = _arg.resync, asp = _arg.asp;\n      this.block_cipher_class || (this.block_cipher_class = AES);\n      this.cipher || (this.cipher = new this.block_cipher_class(WordArray.from_buffer(key)));\n      this.block_size = this.cipher.blockSize;\n      this.out_bufs = [];\n      this.asp = ASP.make(asp);\n    }\n\n    Base.prototype.compact = function() {\n      var b;\n      b = Buffer.concat(this.out_bufs);\n      this.out_bufs = [b];\n      return b;\n    };\n\n    return Base;\n\n  })();\n\n  Encryptor = (function(_super) {\n    __extends(Encryptor, _super);\n\n    function Encryptor(_arg) {\n      var asp, block_cipher_class, cipher, key, prefixrandom, resync;\n      block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, asp = _arg.asp;\n      Encryptor.__super__.constructor.call(this, {\n        block_cipher_class: block_cipher_class,\n        key: key,\n        cipher: cipher,\n        resync: resync,\n        asp: asp\n      });\n      this._init(prefixrandom);\n    }\n\n    Encryptor.prototype._enc = function() {\n      this.FRE = WordArray.from_buffer(this.FR);\n      return this.cipher.encryptBlock(this.FRE.words, 0);\n    };\n\n    Encryptor.prototype._emit_sb = function(sb) {\n      var buf, deficit, i, pad;\n      buf = (deficit = this.block_size - sb.rem()) > 0 ? (pad = new Buffer((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; 0 <= deficit ? _i < deficit : _i > deficit; i = 0 <= deficit ? ++_i : --_i) {\n          _results.push(0);\n        }\n        return _results;\n      })()), Buffer.concat([sb.consume_rest_to_buffer(), pad])) : sb.read_buffer(this.block_size);\n      return this._emit_buf(buf);\n    };\n\n    Encryptor.prototype._emit_buf = function(buf) {\n      var wa;\n      wa = WordArray.from_buffer(buf.slice(0, this.block_size));\n      wa.xor(this.FRE, {\n        n_words: Math.min(wa.words.length, this.FRE.words.length)\n      });\n      buf = wa.to_buffer();\n      this.out_bufs.push(buf);\n      return this.FR = new Buffer(buf);\n    };\n\n    Encryptor.prototype._init = function(prefixrandom) {\n      var b, canary, ct, i, offset;\n      this.FR = new Buffer((function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = this.block_size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          _results.push(0);\n        }\n        return _results;\n      }).call(this));\n      prefixrandom = repeat(prefixrandom, 2);\n      this._enc();\n      this._emit_buf(prefixrandom);\n      this._enc();\n      b = this.FRE.to_buffer();\n      canary = new Buffer((function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 2; i = ++_i) {\n          _results.push(b.readUInt8(i) ^ prefixrandom.readUInt8(this.block_size + i));\n        }\n        return _results;\n      }).call(this));\n      this.out_bufs.push(canary);\n      offset = this.resync ? 2 : 0;\n      ct = this.compact();\n      ct.copy(this.FR, 0, offset, offset + this.block_size);\n      return this._enc();\n    };\n\n    Encryptor.prototype.enc = function(plaintext, cb) {\n      var buf, ct, esc, j, n_wanted, ret, sb, total, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sb = new SlicerBuffer(plaintext);\n      esc = make_esc(cb, \"Encryptor::enc\");\n      if (this.resync) {\n        this._emit_sb(sb);\n      } else {\n        buf = Buffer.concat([new Buffer([0, 0]), sb.read_buffer(this.block_size - 2)]);\n        wa = WordArray.from_buffer(buf);\n        wa.xor(this.FRE, {});\n        buf = wa.to_buffer().slice(2);\n        this.out_bufs.push(buf);\n        ct = this.compact();\n        ct.copy(this.FR, 0, ct.length - this.block_size, ct.length);\n      }\n      total = sb.rem();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\",\n            funcname: \"Encryptor.enc\"\n          });\n          _this.asp.progress({\n            what: \"ofcb encryption\",\n            i: 0,\n            total: total\n          }, esc(__iced_deferrals.defer({\n            lineno: 168\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _while;\n            _while = function(__iced_k) {\n              var _break, _continue, _i, _next;\n              _break = __iced_k;\n              _continue = function() {\n                return iced.trampoline(function() {\n                  return _while(__iced_k);\n                });\n              };\n              _next = _continue;\n              if (!(j = sb.rem())) {\n                return _break();\n              } else {\n                for (_i = 0; _i < 4096; _i++) {\n                  _this._enc();\n                  _this._emit_sb(sb);\n                  if (!(j = sb.rem())) {\n                    break;\n                  }\n                }\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\",\n                    funcname: \"Encryptor.enc\"\n                  });\n                  _this.asp.progress({\n                    what: \"ofcb encryption\",\n                    i: total - j,\n                    total: total\n                  }, esc(__iced_deferrals.defer({\n                    lineno: 177\n                  })));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            ret = _this.compact();\n            n_wanted = plaintext.length + _this.block_size + 2;\n            ret = ret.slice(0, n_wanted);\n            return cb(null, ret);\n          });\n        };\n      })(this));\n    };\n\n    return Encryptor;\n\n  })(Base);\n\n  Decryptor = (function(_super) {\n    __extends(Decryptor, _super);\n\n    function Decryptor(_arg) {\n      var asp, block_cipher_class, cipher, key, prefixrandom, resync;\n      block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, this.ciphertext = _arg.ciphertext, asp = _arg.asp;\n      Decryptor.__super__.constructor.call(this, {\n        block_cipher_class: block_cipher_class,\n        key: key,\n        cipher: cipher,\n        resync: resync,\n        asp: asp\n      });\n      this._init();\n    }\n\n    Decryptor.prototype._init = function() {\n      return this.reset();\n    };\n\n    Decryptor.prototype.reset = function() {\n      return this.sb = new SlicerBuffer(this.ciphertext);\n    };\n\n    Decryptor.prototype.next_block = function() {\n      return WordArray.from_buffer(this.sb.read_buffer_at_most(this.block_size));\n    };\n\n    Decryptor.prototype.get_prefix = function() {\n      return this._prefix;\n    };\n\n    Decryptor.prototype.check = function(cb) {\n      var ablock, err, i, iblock, lhs, rhs;\n      this.reset();\n      iblock = new WordArray((function() {\n        var _i, _ref, _results;\n        _results = [];\n        for (i = _i = 0, _ref = this.block_size / 4; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          _results.push(0);\n        }\n        return _results;\n      }).call(this));\n      this.cipher.encryptBlock(iblock.words, 0);\n      ablock = this.next_block();\n      iblock.xor(ablock, {});\n      this._prefix = iblock.to_buffer();\n      this.cipher.encryptBlock(ablock.words, 0);\n      lhs = iblock.words.slice(-1)[0] & 0xffff;\n      rhs = (ablock.words[0] >>> 16) ^ (this.sb.peek_uint16());\n      err = lhs === rhs ? null : new Error(\"Canary block mismatch: \" + lhs + \" != \" + rhs);\n      return cb(err);\n    };\n\n    Decryptor.prototype.dec = function(cb) {\n      var ablock, esc, iblock, j, out, total, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this.reset();\n      if (this.resync) {\n        this.sb.advance(2);\n      }\n      iblock = this.next_block();\n      esc = make_esc(cb, \"Decryption::dec\");\n      total = this.sb.rem();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\",\n            funcname: \"Decryptor.dec\"\n          });\n          _this.asp.progress({\n            what: \"ofcb decrypt\",\n            i: 0,\n            total: total\n          }, esc(__iced_deferrals.defer({\n            lineno: 239\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            var _while;\n            _while = function(__iced_k) {\n              var _break, _continue, _i, _next;\n              _break = __iced_k;\n              _continue = function() {\n                return iced.trampoline(function() {\n                  return _while(__iced_k);\n                });\n              };\n              _next = _continue;\n              if (!(j = _this.sb.rem())) {\n                return _break();\n              } else {\n                for (_i = 0; _i < 4096; _i++) {\n                  ablock = iblock;\n                  _this.cipher.encryptBlock(ablock.words, 0);\n                  iblock = _this.next_block();\n                  ablock.xor(iblock, {});\n                  _this.out_bufs.push(ablock.to_buffer().slice(0, iblock.sigBytes));\n                  if (!(j = _this.sb.rem())) {\n                    break;\n                  }\n                }\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\",\n                    funcname: \"Decryptor.dec\"\n                  });\n                  _this.asp.progress({\n                    what: \"ofcb decrypt\",\n                    i: total - j,\n                    total: total\n                  }, esc(__iced_deferrals.defer({\n                    lineno: 251\n                  })));\n                  __iced_deferrals._fulfill();\n                })(_next);\n              }\n            };\n            _while(__iced_k);\n          })(function() {\n            out = _this.compact();\n            if (!_this.resync) {\n              out = out.slice(2);\n            }\n            return cb(null, out);\n          });\n        };\n      })(this));\n    };\n\n    return Decryptor;\n\n  })(Base);\n\n  encrypt = function(_arg, cb) {\n    var asp, block_cipher_class, cipher, eng, key, plaintext, prefixrandom, resync;\n    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, plaintext = _arg.plaintext, asp = _arg.asp;\n    eng = new Encryptor({\n      block_cipher_class: block_cipher_class,\n      key: key,\n      cipher: cipher,\n      prefixrandom: prefixrandom,\n      resync: resync,\n      asp: asp\n    });\n    return eng.enc(plaintext, cb);\n  };\n\n  decrypt = function(_arg, cb) {\n    var asp, block_cipher_class, cipher, ciphertext, eng, err, key, pt, resync, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, resync = _arg.resync, ciphertext = _arg.ciphertext, asp = _arg.asp;\n    eng = new Decryptor({\n      block_cipher_class: block_cipher_class,\n      key: key,\n      cipher: cipher,\n      resync: resync,\n      ciphertext: ciphertext,\n      asp: asp\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\"\n        });\n        eng.check(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return err = arguments[0];\n            };\n          })(),\n          lineno: 267\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        (function(__iced_k) {\n          if (typeof err === \"undefined\" || err === null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced\"\n              });\n              eng.dec(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return pt = arguments[1];\n                  };\n                })(),\n                lineno: 268\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        })(function() {\n          return cb(err, pt);\n        });\n      };\n    })(this));\n  };\n\n  exports.encrypt = encrypt;\n\n  exports.decrypt = decrypt;\n\n  exports.Decryptor = Decryptor;\n\n  rng = require('crypto').rng;\n\n  test = function() {\n    var block_cipher_class, ct, key, plaintext, prefixrandom, pt;\n    plaintext = new Buffer(\"a man a plan a canal panama. and you know the rest\");\n    key = rng(32);\n    prefixrandom = new Buffer([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n    block_cipher_class = AES;\n    ct = encrypt({\n      block_cipher_class: block_cipher_class,\n      key: key,\n      prefixrandom: prefixrandom,\n      plaintext: plaintext\n    });\n    console.log(ct.toString('hex'));\n    pt = decrypt({\n      block_cipher_class: block_cipher_class,\n      key: key,\n      prefixrandom: prefixrandom,\n      ciphertext: ct\n    });\n    return console.log(pt.toString('utf8'));\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/userid.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var AES, C, Packet, SHA1, SHA256, UserID, bufferify, encrypt, native_rng, parse, triplesec, uint_to_buffer, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  C = require('../../const').openpgp;\n\n  triplesec = require('triplesec');\n\n  _ref = triplesec.hash, SHA1 = _ref.SHA1, SHA256 = _ref.SHA256;\n\n  AES = triplesec.ciphers.AES;\n\n  native_rng = triplesec.prng.native_rng;\n\n  _ref1 = require('../../util'), bufferify = _ref1.bufferify, uint_to_buffer = _ref1.uint_to_buffer;\n\n  encrypt = require('../cfb').encrypt;\n\n  Packet = require('./base').Packet;\n\n  parse = require('pgp-utils').userid.parse;\n\n  UserID = (function(_super) {\n    __extends(UserID, _super);\n\n    function UserID(userid, components) {\n      this.components = components != null ? components : null;\n      this.userid = bufferify(userid);\n      if (this.compontents == null) {\n        this._parse();\n      }\n      UserID.__super__.constructor.call(this);\n      this._time_primary_pair = null;\n      this.primary = false;\n      this.most_recent_sig = null;\n    }\n\n    UserID.prototype.utf8 = function() {\n      return this.userid.toString('utf8');\n    };\n\n    UserID.prototype.write = function() {\n      return this.frame_packet(C.packet_tags.userid, this.userid);\n    };\n\n    UserID.parse = function(slice) {\n      return new UserID(slice.consume_rest_to_buffer());\n    };\n\n    UserID.prototype.to_userid = function() {\n      return this;\n    };\n\n    UserID.prototype.cmp = function(b) {\n      var x, y;\n      x = this.utf8();\n      y = b.utf8();\n      if (x < y) {\n        return -1;\n      } else if (x === y) {\n        return 0;\n      } else {\n        return 1;\n      }\n    };\n\n    UserID.prototype.to_signature_payload = function() {\n      return Buffer.concat([new Buffer([C.signatures.userid]), uint_to_buffer(32, this.userid.length), this.userid]);\n    };\n\n    UserID.prototype._parse = function() {\n      var c;\n      if ((c = parse(this.utf8())) != null) {\n        return this.components = c;\n      }\n    };\n\n    UserID.prototype.get_username = function() {\n      var _ref2;\n      return (_ref2 = this.components) != null ? _ref2.username : void 0;\n    };\n\n    UserID.prototype.get_comment = function() {\n      var _ref2;\n      return (_ref2 = this.components) != null ? _ref2.comment : void 0;\n    };\n\n    UserID.prototype.get_email = function() {\n      var _ref2;\n      return (_ref2 = this.components) != null ? _ref2.email : void 0;\n    };\n\n    UserID.prototype.time_primary_pair = function() {\n      var max, p, pairs, ret, s, _i, _len;\n      if (this._time_primary_pair == null) {\n        pairs = (function() {\n          var _i, _len, _ref2, _ref3, _results;\n          _ref2 = this.get_psc().get_self_sigs();\n          _results = [];\n          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n            s = _ref2[_i];\n            _results.push(s != null ? (_ref3 = s.sig) != null ? _ref3.time_primary_pair() : void 0 : void 0);\n          }\n          return _results;\n        }).call(this);\n        max = null;\n        ret = [null, null];\n        for (_i = 0, _len = pairs.length; _i < _len; _i++) {\n          p = pairs[_i];\n          if (!(p != null)) {\n            continue;\n          }\n          if (p[0] && ((ret[0] == null) || (ret[0] < p[0]))) {\n            ret[0] = p[0];\n          }\n          if (p[1] && ((ret[1] == null) || (ret[1] < p[0]))) {\n            ret[1] = p[0];\n          }\n        }\n        this._time_primary_pair = ret;\n        this.most_recent_sig = ret[0];\n      }\n      return this._time_primary_pair;\n    };\n\n    UserID.make = function(components) {\n      var c, comment, userid;\n      comment = (c = components.comment) != null ? \"(\" + c + \") \" : \"\";\n      userid = \"\" + components.username + \" \" + comment + \"<\" + components.email + \">\";\n      return new UserID(userid, components);\n    };\n\n    UserID.prototype.get_framed_signature_output = function() {\n      var _ref2, _ref3, _ref4;\n      return (_ref2 = this.get_psc()) != null ? (_ref3 = _ref2.get_self_sig()) != null ? (_ref4 = _ref3.sig) != null ? _ref4.get_framed_output() : void 0 : void 0 : void 0;\n    };\n\n    return UserID;\n\n  })(Packet);\n\n  exports.UserID = UserID;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/user_attribute.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var AES, C, Packet, SHA1, SHA256, UserAttribute, bufferify, encrypt, native_rng, parse, triplesec, uint_to_buffer, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  C = require('../../const').openpgp;\n\n  triplesec = require('triplesec');\n\n  _ref = triplesec.hash, SHA1 = _ref.SHA1, SHA256 = _ref.SHA256;\n\n  AES = triplesec.ciphers.AES;\n\n  native_rng = triplesec.prng.native_rng;\n\n  _ref1 = require('../../util'), bufferify = _ref1.bufferify, uint_to_buffer = _ref1.uint_to_buffer;\n\n  encrypt = require('../cfb').encrypt;\n\n  Packet = require('./base').Packet;\n\n  parse = require('pgp-utils').userid.parse;\n\n  UserAttribute = (function(_super) {\n    __extends(UserAttribute, _super);\n\n    function UserAttribute(data) {\n      this.data = data;\n      UserAttribute.__super__.constructor.call(this);\n    }\n\n    UserAttribute.prototype.write = function() {\n      return this.frame_packet(C.packet_tags.user_attribute, this.data);\n    };\n\n    UserAttribute.parse = function(slice) {\n      return new UserAttribute(slice.consume_rest_to_buffer());\n    };\n\n    UserAttribute.prototype.to_user_attribute = function() {\n      return this;\n    };\n\n    UserAttribute.prototype.to_signature_payload = function() {\n      return Buffer.concat([new Buffer([C.signatures.user_attribute]), uint_to_buffer(32, this.data.length), this.data]);\n    };\n\n    return UserAttribute;\n\n  })(Packet);\n\n  exports.UserAttribute = UserAttribute;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/compressed.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, Compressed, CompressionParser, Packet, asymmetric, bzipDeflate, bzip_inflate, fake_zip_inflate, fix_zip_deflate, iced, uint_to_buffer, zlib, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  asymmetric = require('../../asymmetric');\n\n  zlib = require('zlib');\n\n  uint_to_buffer = require('../../util').uint_to_buffer;\n\n  bzipDeflate = require('bzip-deflate');\n\n  fake_zip_inflate = function(buf, cb) {\n    var bufs, call_end, err, inflater, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    buf = Buffer.concat([new Buffer([0x78, 0x9c]), buf]);\n    inflater = zlib.createInflate({\n      flush: zlib.Z_FULL_FLUSH\n    });\n    bufs = [];\n    call_end = function(err) {\n      var ret, tmp;\n      if ((tmp = cb) != null) {\n        if ((err != null) && err.code === \"Z_BUF_ERROR\") {\n          err = null;\n        }\n        cb = null;\n        if (err != null) {\n          ret = null;\n        } else {\n          ret = Buffer.concat(bufs);\n        }\n        return tmp(err, ret);\n      }\n    };\n    inflater.on('readable', function() {\n      var read_buf;\n      read_buf = inflater.read();\n      if (read_buf != null) {\n        return bufs.push(read_buf);\n      }\n    });\n    inflater.on('end', function() {\n      return call_end(null);\n    });\n    inflater.on('error', function(e) {\n      return call_end(e);\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\"\n        });\n        inflater.write(buf, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              return err = arguments[0];\n            };\n          })(),\n          lineno: 53\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        (function(__iced_k) {\n          if (typeof err === \"undefined\" || err === null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\"\n              });\n              inflater.end(err);\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        })(function() {\n          if (typeof err !== \"undefined\" && err !== null) {\n            return call_end(err);\n          }\n        });\n      };\n    })(this));\n  };\n\n  fix_zip_deflate = function(buf, cb) {\n    var err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\"\n        });\n        zlib.deflate(buf, __iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return ret = arguments[1];\n            };\n          })(),\n          lineno: 62\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, ret);\n      };\n    })(this));\n  };\n\n  bzip_inflate = function(buf, cb) {\n    var e, err, ret;\n    err = null;\n    try {\n      ret = bzipDeflate(buf);\n    } catch (_error) {\n      e = _error;\n      err = e;\n    }\n    return cb(err, ret);\n  };\n\n  Compressed = (function(_super) {\n    __extends(Compressed, _super);\n\n    function Compressed(_arg) {\n      this.algo = _arg.algo, this.compressed = _arg.compressed, this.inflated = _arg.inflated;\n    }\n\n    Compressed.parse = function(slice) {\n      return (new CompressionParser(slice)).parse();\n    };\n\n    Compressed.prototype.inflate = function(cb) {\n      var err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          switch (_this.algo) {\n            case C.compression.none:\n              return __iced_k(ret = _this.compressed);\n            case C.compression.zlib:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.inflate\"\n                });\n                zlib.inflate(_this.compressed, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 95\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.compression.zip:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.inflate\"\n                });\n                fake_zip_inflate(_this.compressed, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 97\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.compression.bzip:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.inflate\"\n                });\n                bzip_inflate(_this.compressed, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 99\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            default:\n              return __iced_k(err = new Error(\"no known inflation -- algo: \" + _this.algo));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Compressed.prototype.deflate = function(cb) {\n      var err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          switch (_this.algo) {\n            case C.compression.none:\n              return __iced_k(ret = _this.inflated);\n            case C.compression.zlib:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.deflate\"\n                });\n                zlib.deflate(_this.inflated, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 111\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.compression.zip:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n                  funcname: \"Compressed.deflate\"\n                });\n                fake_zip_deflate(_this.inflated, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return ret = arguments[1];\n                    };\n                  })(),\n                  lineno: 113\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            default:\n              return __iced_k(err = new Error(\"no known deflation -- algo: \" + _this.algo));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Compressed.prototype.write_unframed = function(cb) {\n      var bufs, err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n            funcname: \"Compressed.write_unframed\"\n          });\n          _this.deflate(__iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                err = arguments[0];\n                return __slot_1.compressed = arguments[1];\n              };\n            })(_this),\n            lineno: 122\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            bufs = [uint_to_buffer(8, _this.algo), _this.compressed];\n            ret = Buffer.concat(bufs);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Compressed.prototype.write = function(cb) {\n      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/compressed.iced\",\n            funcname: \"Compressed.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 132\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = _this.frame_packet(C.packet_tags.compressed, unframed);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    return Compressed;\n\n  })(Packet);\n\n  CompressionParser = (function() {\n    function CompressionParser(slice) {\n      this.slice = slice;\n    }\n\n    CompressionParser.prototype.parse = function() {\n      var algo, compressed;\n      algo = this.slice.read_uint8();\n      compressed = this.slice.consume_rest_to_buffer();\n      return new Compressed({\n        algo: algo,\n        compressed: compressed\n      });\n    };\n\n    return CompressionParser;\n\n  })();\n\n  exports.Compressed = Compressed;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/generic.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var Generic, Packet,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Packet = require('./base').Packet;\n\n  Generic = (function(_super) {\n    __extends(Generic, _super);\n\n    function Generic(type, body) {\n      this.type = type;\n      this.body = body;\n    }\n\n    return Generic;\n\n  })(Packet);\n\n  exports.Generic = Generic;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/one_pass_sig.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, OPS_Parser, OnePassSignature, Packet, asymmetric, hash, iced, uint_to_buffer, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  asymmetric = require('../../asymmetric');\n\n  hash = require('../../hash');\n\n  uint_to_buffer = require('../../util').uint_to_buffer;\n\n  OnePassSignature = (function(_super) {\n    __extends(OnePassSignature, _super);\n\n    function OnePassSignature(_arg) {\n      this.sig_type = _arg.sig_type, this.hasher = _arg.hasher, this.sig_klass = _arg.sig_klass, this.key_id = _arg.key_id, this.is_final = _arg.is_final;\n    }\n\n    OnePassSignature.parse = function(slice) {\n      return (new OPS_Parser(slice)).parse();\n    };\n\n    OnePassSignature.prototype.write_unframed = function(cb) {\n      var bufs, unframed, vals, x;\n      vals = [C.versions.one_pass_sig, this.sig_type, this.hasher.type, this.sig_klass.type];\n      bufs = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = vals.length; _i < _len; _i++) {\n          x = vals[_i];\n          _results.push(uint_to_buffer(8, x));\n        }\n        return _results;\n      })();\n      bufs.push(this.key_id);\n      bufs.push(uint_to_buffer(8, this.is_final));\n      unframed = Buffer.concat(bufs);\n      return cb(null, unframed);\n    };\n\n    OnePassSignature.prototype.write = function(cb) {\n      var err, framed, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced\",\n            funcname: \"OnePassSignature.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return unframed = arguments[1];\n              };\n            })(),\n            lineno: 38\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          framed = _this.frame_packet(C.packet_tags.one_pass_sig, unframed);\n          return cb(err, framed);\n        };\n      })(this));\n    };\n\n    return OnePassSignature;\n\n  })(Packet);\n\n  OPS_Parser = (function() {\n    function OPS_Parser(slice) {\n      this.slice = slice;\n    }\n\n    OPS_Parser.prototype.parse = function() {\n      var hasher, is_final, key_id, sig_klass, sig_type, v;\n      if ((v = this.slice.read_uint8()) !== C.versions.one_pass_sig) {\n        throw new Error(\"Unknown OnePassSignature version \" + v);\n      }\n      sig_type = this.slice.read_uint8();\n      hasher = hash.alloc_or_throw(this.slice.read_uint8());\n      sig_klass = asymmetric.get_class(this.slice.read_uint8());\n      key_id = this.slice.read_buffer(8);\n      is_final = this.slice.read_uint8();\n      return new OnePassSignature({\n        sig_type: sig_type,\n        hasher: hasher,\n        sig_klass: sig_klass,\n        key_id: key_id,\n        is_final: is_final\n      });\n    };\n\n    return OPS_Parser;\n\n  })();\n\n  exports.OnePassSignature = OnePassSignature;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/literal.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, Literal, LiteralParser, Packet, asymmetric, iced, uint_to_buffer, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  Packet = require('./base').Packet;\n\n  C = require('../../const').openpgp;\n\n  asymmetric = require('../../asymmetric');\n\n  uint_to_buffer = require('../../util').uint_to_buffer;\n\n  Literal = (function(_super) {\n    __extends(Literal, _super);\n\n    function Literal(_arg) {\n      this.format = _arg.format, this.filename = _arg.filename, this.date = _arg.date, this.data = _arg.data;\n      Literal.__super__.constructor.call(this);\n    }\n\n    Literal.parse = function(slice) {\n      return (new LiteralParser(slice)).parse();\n    };\n\n    Literal.prototype.toString = function(encoding) {\n      if (encoding == null) {\n        encoding = null;\n      }\n      return this.data.toString(encoding || this.buffer_format());\n    };\n\n    Literal.prototype.toBuffer = function() {\n      return this.data;\n    };\n\n    Literal.prototype.buffer_format = function() {\n      switch (this.format) {\n        case C.literal_formats.text:\n          return 'ascii';\n        case C.literal_formats.utf8:\n          return 'utf8';\n        default:\n          return 'binary';\n      }\n    };\n\n    Literal.prototype.to_signature_payload = function() {\n      return Buffer.concat([this.data]);\n    };\n\n    Literal.prototype.write_unframed = function(cb) {\n      var bufs, ret;\n      this.filename || (this.filename = new Buffer([]));\n      bufs = [new Buffer([this.format]), uint_to_buffer(8, this.filename.length), this.filename, uint_to_buffer(32, this.date), this.data];\n      ret = Buffer.concat(bufs);\n      return cb(null, ret);\n    };\n\n    Literal.prototype.write = function(cb) {\n      var err, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/packet/literal.iced\",\n            funcname: \"Literal.write\"\n          });\n          _this.write_unframed(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return raw = arguments[1];\n              };\n            })(),\n            lineno: 41\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = _this.frame_packet(C.packet_tags.literal, raw);\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Literal.prototype.to_literal = function() {\n      return this;\n    };\n\n    return Literal;\n\n  })(Packet);\n\n  LiteralParser = (function() {\n    function LiteralParser(slice) {\n      this.slice = slice;\n    }\n\n    LiteralParser.prototype.parse = function() {\n      var data, date, filename, format, k, known_formats, v;\n      known_formats = (function() {\n        var _ref, _results;\n        _ref = C.literal_formats;\n        _results = [];\n        for (k in _ref) {\n          v = _ref[k];\n          _results.push(v);\n        }\n        return _results;\n      })();\n      format = this.slice.read_uint8();\n      if (__indexOf.call(known_formats, format) < 0) {\n        throw new Error(\"unknwon format: \" + format);\n      }\n      filename = this.slice.read_string();\n      date = this.slice.read_uint32();\n      data = this.slice.consume_rest_to_buffer();\n      return new Literal({\n        format: format,\n        filename: filename,\n        date: date,\n        data: data\n      });\n    };\n\n    return LiteralParser;\n\n  })();\n\n  exports.Literal = Literal;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/processor.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, KeyBlock, Message, OPS, Warnings, armor, athrow, bufeq_secure, do_message, hashmod, iced, import_key_pgp, katch, konst, make_esc, parse, unix_time, util, verify_clearsign, verify_detached, __iced_k, __iced_k_noop, _ref;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  OPS = require('../keyfetch').OPS;\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  _ref = require('../util'), katch = _ref.katch, unix_time = _ref.unix_time, athrow = _ref.athrow, Warnings = _ref.Warnings, bufeq_secure = _ref.bufeq_secure;\n\n  parse = require('./parser').parse;\n\n  import_key_pgp = require('../symmetric').import_key_pgp;\n\n  util = require('util');\n\n  armor = require('./armor');\n\n  hashmod = require('../hash');\n\n  verify_clearsign = require('./clearsign').verify;\n\n  verify_detached = require('./detachsign').verify;\n\n  KeyBlock = (function() {\n    function KeyBlock(packets, opts) {\n      this.packets = packets;\n      this.verified_signatures = [];\n      this.subkeys = [];\n      this.primary = null;\n      this.userids = [];\n      this.user_attributes = [];\n      this.warnings = new Warnings();\n      this.opts = opts || {};\n      if (this.opts.strict == null) {\n        this.opts.strict = true;\n      }\n    }\n\n    KeyBlock.prototype.to_obj = function() {\n      return {\n        subkeys: this.subkeys,\n        primary: this.primary,\n        userids: this.userids\n      };\n    };\n\n    KeyBlock.prototype._extract_keys = function() {\n      var err, i, p, _i, _len, _ref1;\n      err = null;\n      if (!this.packets.length) {\n        err = new Error(\"No packets; cannot extract a key\");\n      } else if (!(this.primary = this.packets[0]).is_primary()) {\n        err = new Error(\"First packet must be the primary key\");\n      } else {\n        _ref1 = this.packets.slice(1);\n        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\n          p = _ref1[i];\n          if (p.is_key_material() && (err == null)) {\n            if (p.key.is_toxic()) {\n              this.warnings.push(\"Ignoring toxic subkey (ElGamal Encrypt+Sign)\");\n            } else if (!p.is_primary()) {\n              this.subkeys.push(p);\n            } else if (bufeq_secure(p.get_fingerprint(), this.primary.get_fingerprint())) {\n              p.set_duplicate_primary();\n            } else {\n              err = new Error(\"cannot have 2 primary keys\");\n            }\n          }\n        }\n      }\n      return err;\n    };\n\n    KeyBlock.prototype._check_keys = function() {\n      return this._check_primary() || this._check_subkeys();\n    };\n\n    KeyBlock.prototype._check_primary = function() {\n      var err;\n      return err = !this.primary.is_self_signed() ? new Error(\"no valid primary key self-signature or key(s) have expired\") : (this.userids = this.primary.get_signed_userids()).length === 0 ? new Error(\"no valid Userid signed into key\") : (this.user_attributes = this.primary.get_signed_user_attributes(), null);\n    };\n\n    KeyBlock.prototype._check_subkeys = function() {\n      var err, i, k, msg, subkeys, _i, _len;\n      subkeys = this.subkeys;\n      err = null;\n      this.subkeys = [];\n      for (i = _i = 0, _len = subkeys.length; _i < _len; i = ++_i) {\n        k = subkeys[i];\n        if (err == null) {\n          if (k.is_signed_subkey_of(this.primary, this.opts)) {\n            this.subkeys.push(k);\n          } else {\n            msg = \"Subkey \" + i + \" was invalid; discarding\";\n            this.warnings.push(msg);\n          }\n        }\n      }\n      return err;\n    };\n\n    KeyBlock.prototype.process = function(cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = this._extract_keys();\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"KeyBlock.process\"\n              });\n              _this._verify_sigs(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return err = arguments[0];\n                  };\n                })(),\n                lineno: 87\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref1;\n          if (!((err != null) || ((_ref1 = _this.opts) != null ? _ref1.no_check_keys : void 0))) {\n            err = _this._check_keys();\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    KeyBlock.prototype._check_issuer = function(i, packet, primary) {\n      var fp, iid, pid, wanted;\n      if ((fp = packet.get_issuer_fingerprint()) != null) {\n        if (bufeq_secure(fp, (wanted = this.primary.get_fingerprint()))) {\n          return wanted;\n        } else {\n          this.warnings.push(\"Skipping signature by another issuer: \" + (fp.toString('hex')) + \" != \" + (wanted != null ? wanted.toString('hex') : void 0));\n          return null;\n        }\n      }\n      if ((iid = packet.get_issuer_key_id()) != null) {\n        if (bufeq_secure(iid, (pid = this.primary.get_key_id()))) {\n          return pid;\n        } else {\n          this.warnings.push(\"Skipping signature by another issuer: \" + (iid != null ? iid.toString('hex') : void 0) + \" != \" + (pid != null ? pid.toString('hex') : void 0));\n          return null;\n        }\n      }\n      this.warnings.push(\"Signature is missing an issuer (at packet=\" + i + \")\");\n      return null;\n    };\n\n    KeyBlock.prototype._verify_sigs = function(cb) {\n      var err, i, issuer_id, msg, n_sigs, p, tmp, working_set, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      working_set = [];\n      n_sigs = 0;\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref1, _results, _while;\n          _ref1 = _this.packets.slice(1);\n          _len = _ref1.length;\n          i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(i < _len)) {\n              return _break();\n            } else {\n              p = _ref1[i];\n              if (err == null) {\n                (function(__iced_k) {\n                  if (!p.is_signature()) {\n                    if (n_sigs > 0) {\n                      n_sigs = 0;\n                      working_set = [];\n                    }\n                    if (!p.is_duplicate_primary()) {\n                      working_set.push(p);\n                    }\n                    (function(__iced_k) {\n_continue()\n                    })(__iced_k);\n                  } else {\n                    return __iced_k();\n                  }\n                })(function() {\n                  n_sigs++;\n                  (function(__iced_k) {\n                    if ((issuer_id = _this._check_issuer(i, p, _this.primary)) != null) {\n                      p.key = _this.primary.key;\n                      p.primary = _this.primary;\n                      (function(__iced_k) {\n                        __iced_deferrals = new iced.Deferrals(__iced_k, {\n                          parent: ___iced_passed_deferral,\n                          filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                          funcname: \"KeyBlock._verify_sigs\"\n                        });\n                        p.verify(working_set, __iced_deferrals.defer({\n                          assign_fn: (function() {\n                            return function() {\n                              return tmp = arguments[0];\n                            };\n                          })(),\n                          lineno: 132\n                        }), _this.opts);\n                        __iced_deferrals._fulfill();\n                      })(function() {\n                        return __iced_k(typeof tmp !== \"undefined\" && tmp !== null ? (msg = \"Signature failure in packet \" + i + \": \" + tmp.message + \" (\" + (issuer_id.toString('hex')) + \")\", _this.warnings.push(msg)) : _this.verified_signatures.push(p));\n                      });\n                    } else {\n                      return __iced_k();\n                    }\n                  })(_next);\n                });\n              } else {\n                return _continue();\n              }\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return KeyBlock;\n\n  })();\n\n  Message = (function() {\n    function Message(_arg) {\n      this.keyfetch = _arg.keyfetch, this.data_fn = _arg.data_fn, this.data = _arg.data, this.strict = _arg.strict, this.now = _arg.now;\n      this.literals = [];\n      this.enc_data_packet = null;\n      this.warnings = new Warnings();\n    }\n\n    Message.prototype._get_session_key = function(cb) {\n      var enc, err, esk_packets, fingerprint, index, key_ids, key_material, km, p, packet, pkcs5, privk, sesskey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key_ids = [];\n      esk_packets = [];\n      err = null;\n      pkcs5 = false;\n      key_ids = (function() {\n        var _results;\n        _results = [];\n        while (this.packets.length && (p = this.packets[0].to_esk_packet())) {\n          esk_packets.push(p);\n          this.packets.shift();\n          _results.push(p.get_key_id());\n        }\n        return _results;\n      }).call(this);\n      (function(_this) {\n        return (function(__iced_k) {\n          if (key_ids.length) {\n            enc = true;\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._get_session_key\"\n              });\n              _this.keyfetch.fetch(key_ids, konst.ops.decrypt, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    km = arguments[1];\n                    return index = arguments[2];\n                  };\n                })(),\n                lineno: 173\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                if (err == null) {\n                  packet = esk_packets[index];\n                  key_material = km.find_pgp_key_material(key_ids[index]);\n                  fingerprint = key_material.get_fingerprint();\n                  privk = key_material.key;\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                      funcname: \"Message._get_session_key\"\n                    });\n                    privk.decrypt_and_unpad(packet.ekey, {\n                      fingerprint: fingerprint\n                    }, __iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          err = arguments[0];\n                          sesskey = arguments[1];\n                          return pkcs5 = arguments[2];\n                        };\n                      })(),\n                      lineno: 179\n                    }));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return __iced_k(err == null ? _this.encryption_subkey = key_material : void 0);\n                  });\n                } else {\n                  return __iced_k();\n                }\n              })(__iced_k);\n            });\n          } else {\n            return __iced_k(enc = false);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, enc, sesskey, pkcs5);\n        };\n      })(this));\n    };\n\n    Message.prototype._find_encrypted_data = function(cb) {\n      var err, ret;\n      err = ret = null;\n      if (this.packets.length && (ret = this.packets[0].to_enc_data_packet())) {\n        this.packets.pop();\n      } else {\n        err = new Error(\"Could not find encrypted data packet\");\n      }\n      return cb(err, ret);\n    };\n\n    Message.prototype._decrypt_with_session_key = function(sesskey, edat, pkcs5, cb) {\n      var cipher, err, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      _ref1 = katch(function() {\n        return import_key_pgp(sesskey, pkcs5);\n      }), err = _ref1[0], cipher = _ref1[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._decrypt_with_session_key\"\n              });\n              edat.decrypt({\n                cipher: cipher\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return ret = arguments[1];\n                  };\n                })(),\n                lineno: 201\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Message.prototype._parse = function(raw, cb) {\n      var err, packets, _ref1;\n      _ref1 = parse(raw), err = _ref1[0], packets = _ref1[1];\n      return cb(err, packets);\n    };\n\n    Message.prototype._decrypt = function(cb) {\n      var edat, err, esc, is_enc, packets, pkcs5, plaintext, sesskey, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      esc = make_esc(cb, \"Message::decrypt\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n            funcname: \"Message._decrypt\"\n          });\n          _this._get_session_key(esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                is_enc = arguments[0];\n                sesskey = arguments[1];\n                return pkcs5 = arguments[2];\n              };\n            })(),\n            lineno: 215\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (is_enc) {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._decrypt\"\n                });\n                _this._find_encrypted_data(esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return edat = arguments[0];\n                    };\n                  })(),\n                  lineno: 217\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                    funcname: \"Message._decrypt\"\n                  });\n                  _this._decrypt_with_session_key(sesskey, edat, pkcs5, esc(__iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return plaintext = arguments[0];\n                      };\n                    })(),\n                    lineno: 218\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                      funcname: \"Message._decrypt\"\n                    });\n                    _this._parse(plaintext, esc(__iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          return packets = arguments[0];\n                        };\n                      })(),\n                      lineno: 219\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return __iced_k(_this.packets = packets.concat(_this.packets));\n                  });\n                });\n              });\n            } else {\n              return __iced_k();\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype._inflate = function(cb) {\n      var esc, inflated, p, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      packets = [];\n      esc = make_esc(cb, \"Message::_inflate\");\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref1, _results, _while;\n          _ref1 = _this.packets;\n          _len = _ref1.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              p = _ref1[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._inflate\"\n                });\n                p.inflate(esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return inflated = arguments[0];\n                    };\n                  })(),\n                  lineno: 229\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  if (typeof inflated !== \"undefined\" && inflated !== null) {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                        funcname: \"Message._inflate\"\n                      });\n                      _this._parse(inflated, esc(__iced_deferrals.defer({\n                        assign_fn: (function() {\n                          return function() {\n                            return p = arguments[0];\n                          };\n                        })(),\n                        lineno: 231\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      return __iced_k(packets.push.apply(packets, p));\n                    });\n                  } else {\n                    return __iced_k(packets.push(p));\n                  }\n                })(_next);\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          _this.packets = packets;\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Message.prototype._frame_signatures = function() {\n      var o, p, payload, ret, stack, _i, _j, _len, _len1, _ref1;\n      ret = [];\n      stack = [];\n      payload = [];\n      _ref1 = this.packets;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        p = _ref1[_i];\n        if (p.tag === C.packet_tags.one_pass_sig) {\n          stack.push({\n            open: p\n          });\n        } else if (!stack.length) {\n\n        } else if (p.tag === C.packet_tags.signature) {\n          o = stack.pop();\n          o.close = p;\n          ret.push(o);\n        } else {\n          payload.push(p);\n        }\n      }\n      for (_j = 0, _len1 = ret.length; _j < _len1; _j++) {\n        o = ret[_j];\n        o.payload = payload;\n      }\n      return ret;\n    };\n\n    Message.prototype._verify_sig = function(sig, cb) {\n      var a, b, err, i, key_material, km, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      if (!bufeq_secure((a = sig.open.key_id), (b = sig.close.get_key_id()))) {\n        err = new Error(\"signature mismatch open v close: \" + (a != null ? a.toString('hex') : void 0) + \" != \" + (b != null ? b.toString('hex') : void 0));\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._verify_sig\"\n              });\n              _this.keyfetch.fetch([a], konst.ops.verify, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    km = arguments[1];\n                    return i = arguments[2];\n                  };\n                })(),\n                lineno: 270\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(err != null ? err = new Error(\"Can't find a key for \" + (a.toString('hex')) + \": \" + err.message) : void 0);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            if (err == null) {\n              key_material = km.find_pgp_key_material(a);\n              sig.close.key = key_material.key;\n              sig.close.subkey_material = key_material;\n              sig.close.key_manager = km;\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._verify_sig\"\n                });\n                sig.close.verify(sig.payload, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return err = arguments[0];\n                    };\n                  })(),\n                  lineno: 285\n                }), {\n                  now: _this.now\n                });\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n            } else {\n              return __iced_k(!_this.strict ? (_this.warnings.push(\"Problem fetching key \" + (a.toString('hex')) + \": \" + (err.toString())), err = null) : void 0);\n            }\n          })(function() {\n            return cb(err);\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype._verify = function(cb) {\n      var esc, sig, sigs, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Message::_verify_sigs\");\n      sigs = this._frame_signatures();\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref1, _results, _while;\n          _ref1 = sigs;\n          _len = _ref1.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              sig = _ref1[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._verify\"\n                });\n                _this._verify_sig(sig, esc(__iced_deferrals.defer({\n                  lineno: 299\n                })));\n                __iced_deferrals._fulfill();\n              })(_next);\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Message.prototype.collect_literals = function() {\n      var p, _i, _len, _ref1, _results;\n      _ref1 = this.packets;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        p = _ref1[_i];\n        if (p.tag === C.packet_tags.literal) {\n          _results.push(p);\n        }\n      }\n      return _results;\n    };\n\n    Message.prototype._process_generic = function(_arg, cb) {\n      var esc, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      packets = _arg.packets;\n      this.packets = packets;\n      esc = make_esc(cb, \"Message:process\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n            funcname: \"Message._process_generic\"\n          });\n          _this._decrypt(esc(__iced_deferrals.defer({\n            lineno: 312\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n              funcname: \"Message._process_generic\"\n            });\n            _this._inflate(esc(__iced_deferrals.defer({\n              lineno: 313\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._process_generic\"\n              });\n              _this._verify(esc(__iced_deferrals.defer({\n                lineno: 314\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null, _this.collect_literals());\n            });\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype._verify_clearsign = function(_arg, cb) {\n      var clearsign, err, literal, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      packets = _arg.packets, clearsign = _arg.clearsign;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (clearsign == null) {\n            return __iced_k(err = new Error(\"no clearsign data found\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._verify_clearsign\"\n              });\n              verify_clearsign({\n                packets: packets,\n                clearsign: clearsign,\n                keyfetch: _this.keyfetch\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return literal = arguments[1];\n                  };\n                })(),\n                lineno: 323\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, [literal]);\n        };\n      })(this));\n    };\n\n    Message.prototype.parse_and_inflate = function(body, cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Message::parse_and_inflate\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n            funcname: \"Message.parse_and_inflate\"\n          });\n          _this._parse(body, esc(__iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                return __slot_1.packets = arguments[0];\n              };\n            })(_this),\n            lineno: 330\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n              funcname: \"Message.parse_and_inflate\"\n            });\n            _this._inflate(esc(__iced_deferrals.defer({\n              lineno: 331\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            return cb(null, _this.collect_literals());\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype.parse_and_process = function(msg, cb) {\n      var esc, literals, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Message::parse_and_process\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n            funcname: \"Message.parse_and_process\"\n          });\n          _this._parse(msg.body, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return packets = arguments[0];\n              };\n            })(),\n            lineno: 338\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n              funcname: \"Message.parse_and_process\"\n            });\n            _this._process({\n              msg: msg,\n              packets: packets\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return literals = arguments[0];\n                };\n              })(),\n              lineno: 339\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            return cb(null, literals);\n          });\n        };\n      })(this));\n    };\n\n    Message.prototype._verify_signature = function(_arg, cb) {\n      var err, literals, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      packets = _arg.packets;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (!((_this.data != null) || (_this.data_fn != null))) {\n            return __iced_k(err = new Error(\"Cannot verify detached signature without data input\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                funcname: \"Message._verify_signature\"\n              });\n              verify_detached({\n                packets: packets,\n                data: _this.data,\n                data_fn: _this.data_fn,\n                keyfetch: _this.keyfetch\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return literals = arguments[1];\n                  };\n                })(),\n                lineno: 348\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, literals);\n        };\n      })(this));\n    };\n\n    Message.prototype._process = function(_arg, cb) {\n      var err, literals, msg, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      msg = _arg.msg, packets = _arg.packets;\n      msg.type || (msg.type = C.message_types.generic);\n      (function(_this) {\n        return (function(__iced_k) {\n          switch (msg.type) {\n            case C.message_types.generic:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._process\"\n                });\n                _this._process_generic({\n                  packets: packets\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return literals = arguments[1];\n                    };\n                  })(),\n                  lineno: 357\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.message_types.clearsign:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._process\"\n                });\n                _this._verify_clearsign({\n                  packets: packets,\n                  clearsign: msg.clearsign\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return literals = arguments[1];\n                    };\n                  })(),\n                  lineno: 359\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            case C.message_types.signature:\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\",\n                  funcname: \"Message._process\"\n                });\n                _this._verify_signature({\n                  packets: packets\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return literals = arguments[1];\n                    };\n                  })(),\n                  lineno: 361\n                }));\n                __iced_deferrals._fulfill();\n              })(__iced_k);\n              break;\n            default:\n              return __iced_k(err = new Error(\"Needed a 'generic', 'clearsign', or 'signature' PGP message, got \" + msg.type));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, literals);\n        };\n      })(this));\n    };\n\n    return Message;\n\n  })();\n\n  exports.KeyBlock = KeyBlock;\n\n  exports.Message = Message;\n\n  exports.do_message = do_message = function(_arg, cb) {\n    var armored, data, data_fn, err, esk, keyfetch, literals, msg, msg_type, now, proc, raw, strict, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref1;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    armored = _arg.armored, raw = _arg.raw, msg_type = _arg.msg_type, keyfetch = _arg.keyfetch, data_fn = _arg.data_fn, data = _arg.data, strict = _arg.strict, now = _arg.now;\n    literals = null;\n    err = msg = warnings = esk = null;\n    if (armored != null) {\n      _ref1 = armor.decode(armored), err = _ref1[0], msg = _ref1[1];\n    } else if (raw != null) {\n      msg_type || (msg_type = C.message_types.generic);\n      msg = {\n        body: raw,\n        type: msg_type\n      };\n    } else {\n      err = new Error(\"No input to do_message; need either 'armored' or 'raw' input\");\n    }\n    (function(_this) {\n      return (function(__iced_k) {\n        if (err == null) {\n          if (strict == null) {\n            strict = true;\n          }\n          proc = new Message({\n            keyfetch: keyfetch,\n            data_fn: data_fn,\n            data: data,\n            strict: strict,\n            now: now\n          });\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/home/michal/kbpgp/src/openpgp/processor.iced\"\n            });\n            proc.parse_and_process(msg, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  err = arguments[0];\n                  return literals = arguments[1];\n                };\n              })(),\n              lineno: 409\n            }));\n            __iced_deferrals._fulfill();\n          })(function() {\n            warnings = proc.warnings;\n            return __iced_k(esk = proc.encryption_subkey);\n          });\n        } else {\n          return __iced_k();\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, literals, warnings, esk);\n      };\n    })(this));\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keyfetch.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var KeyFetcher;\n\n  KeyFetcher = (function() {\n    function KeyFetcher() {}\n\n    KeyFetcher.prototype.fetch = function(ids, ops, cb) {\n      return cb(new Error(\"not implemented\"));\n    };\n\n    return KeyFetcher;\n\n  })();\n\n  exports.KeyFetcher = KeyFetcher;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/clearsign.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, Ch, ClearSigner, CreationTime, Issuer, Literal, SHA512, SRF, Signature, Verifier, VerifierBase, WordArray, bufferify, clearsign_header, clearsign_to_sign, dash_escape, dash_unescape_line, dash_unescape_lines, encode, export_key_pgp, get_cipher, hashmod, iced, input_to_cleartext, input_to_cleartext_display, input_to_cleartext_sign, konst, make_esc, scrub_buffer, triplesec, unix_time, whitespace_strip, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;\n\n  _ref1 = require('../util'), bufferify = _ref1.bufferify, unix_time = _ref1.unix_time;\n\n  SRF = require('../rand').SRF;\n\n  triplesec = require('triplesec');\n\n  _ref2 = require('../symmetric'), export_key_pgp = _ref2.export_key_pgp, get_cipher = _ref2.get_cipher;\n\n  scrub_buffer = triplesec.util.scrub_buffer;\n\n  WordArray = triplesec.WordArray;\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  Ch = require('../header');\n\n  hashmod = require('../hash');\n\n  SHA512 = hashmod.SHA512;\n\n  encode = require('./armor').encode;\n\n  clearsign_header = require('pgp-utils').armor.clearsign_header;\n\n  Literal = require(\"./packet/literal\").Literal;\n\n  VerifierBase = require('./verifier').Base;\n\n  exports.input_to_cleartext = input_to_cleartext = function(raw) {\n    var lines, ret;\n    lines = raw.split(/\\n/);\n    ret = {\n      show: bufferify(input_to_cleartext_display(lines)),\n      sign: bufferify(input_to_cleartext_sign(lines))\n    };\n    return ret;\n  };\n\n  exports.dash_escape = dash_escape = function(line) {\n    if (line.length >= 1 && line[0] === '-') {\n      return \"- \" + line;\n    } else {\n      return line;\n    }\n  };\n\n  exports.dash_unescape_line = dash_unescape_line = function(line) {\n    var m, out, warn, _ref3;\n    warn = false;\n    out = (m = line.match(/^-( )?(.*?)$/)) != null ? (((_ref3 = m[1]) != null ? _ref3.length : void 0) !== 1 ? warn = true : void 0, m[2]) : line;\n    return [out, warn];\n  };\n\n  exports.dash_unescape_lines = dash_unescape_lines = function(lines, warnings) {\n    var i, l, line, ret, warn;\n    if (warnings == null) {\n      warnings = null;\n    }\n    ret = (function() {\n      var _i, _len, _ref3, _results;\n      _results = [];\n      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {\n        line = lines[i];\n        _ref3 = dash_unescape_line(line), l = _ref3[0], warn = _ref3[1];\n        if (warn) {\n          if (warnings != null) {\n            warnings.push(\"Bad dash-encoding on line \" + (i + 1));\n          }\n        }\n        _results.push(l);\n      }\n      return _results;\n    })();\n    return ret;\n  };\n\n  exports.input_to_cleartext_display = input_to_cleartext_display = function(lines) {\n    var line, out;\n    out = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        line = lines[_i];\n        _results.push(dash_escape(line));\n      }\n      return _results;\n    })();\n    if (lines.length === 0 || lines.slice(-1)[0] !== '') {\n      out.push('');\n    }\n    return out.join(\"\\n\");\n  };\n\n  exports.clearsign_to_sign = clearsign_to_sign = function(lines, warnings) {\n    lines = dash_unescape_lines(lines, warnings);\n    return input_to_cleartext_sign(lines);\n  };\n\n  exports.input_to_cleartext_sign = input_to_cleartext_sign = function(lines) {\n    var line, num_trailing_newlines, t, tmp, _i;\n    tmp = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        line = lines[_i];\n        _results.push(whitespace_strip(line));\n      }\n      return _results;\n    })();\n    num_trailing_newlines = 0;\n    for (_i = tmp.length - 1; _i >= 0; _i += -1) {\n      t = tmp[_i];\n      if (t === '') {\n        num_trailing_newlines++;\n      } else {\n        break;\n      }\n    }\n    if (num_trailing_newlines > 0) {\n      tmp.pop();\n    }\n    return tmp.join(\"\\r\\n\");\n  };\n\n  exports.whitespace_strip = whitespace_strip = function(line) {\n    var m;\n    line = line.replace(/\\r/g, '');\n    if ((m = line.match(/^(.*?)([ \\t]*)$/))) {\n      return m[1];\n    } else {\n      return line;\n    }\n  };\n\n  ClearSigner = (function() {\n    function ClearSigner(_arg) {\n      this.msg = _arg.msg, this.signing_key = _arg.signing_key;\n    }\n\n    ClearSigner.prototype._fix_msg = function(cb) {\n      this._cleartext = input_to_cleartext(this.msg.toString('utf8'));\n      return cb(null);\n    };\n\n    ClearSigner.prototype._sign_msg = function(cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this.sig = new Signature({\n        sig_type: C.sig_types.canonical_text,\n        key: this.signing_key.key,\n        hashed_subpackets: [new CreationTime(unix_time())],\n        unhashed_subpackets: [new Issuer(this.signing_key.get_key_id())]\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n            funcname: \"ClearSigner._sign_msg\"\n          });\n          _this.sig.write(_this._cleartext.sign, __iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                err = arguments[0];\n                return __slot_1._sig_output = arguments[1];\n              };\n            })(_this),\n            lineno: 117\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, _this._sig_output);\n        };\n      })(this));\n    };\n\n    ClearSigner.prototype.scrub = function() {};\n\n    ClearSigner.prototype.hasher_name = function() {\n      return this.sig.hasher.algname;\n    };\n\n    ClearSigner.prototype._encode = function(cb) {\n      var body, hdr;\n      hdr = clearsign_header(Ch, this._cleartext.show, this.hasher_name());\n      body = encode(C.message_types.signature, this._sig_output);\n      return cb(null, hdr + body);\n    };\n\n    ClearSigner.prototype.run = function(cb) {\n      var encoded, esc, signature, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"ClearSigner::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n            funcname: \"ClearSigner.run\"\n          });\n          _this._fix_msg(esc(__iced_deferrals.defer({\n            lineno: 139\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n              funcname: \"ClearSigner.run\"\n            });\n            _this._sign_msg(esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return signature = arguments[0];\n                };\n              })(),\n              lineno: 140\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                funcname: \"ClearSigner.run\"\n              });\n              _this._encode(esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return encoded = arguments[0];\n                  };\n                })(),\n                lineno: 141\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null, encoded, signature);\n            });\n          });\n        };\n      })(this));\n    };\n\n    return ClearSigner;\n\n  })();\n\n  Verifier = (function(_super) {\n    __extends(Verifier, _super);\n\n    function Verifier(_arg) {\n      var keyfetch, packets;\n      packets = _arg.packets, this.clearsign = _arg.clearsign, keyfetch = _arg.keyfetch;\n      Verifier.__super__.constructor.call(this, {\n        packets: packets,\n        keyfetch: keyfetch\n      });\n    }\n\n    Verifier.prototype._reformat_text = function(cb) {\n      var data;\n      data = bufferify(clearsign_to_sign(this.clearsign.lines));\n      this._literal = new Literal({\n        data: data,\n        format: C.literal_formats.utf8,\n        date: unix_time()\n      });\n      return cb(null);\n    };\n\n    Verifier.prototype._make_hasher = function(cb) {\n      var err, h;\n      err = null;\n      h = (this.clearsign.headers.hash || 'MD5').trim();\n      if ((this._sig.hasher = hashmod[h]) == null) {\n        err = new Error(\"Unknown hash algorithm: \" + h);\n      }\n      return cb(err);\n    };\n\n    Verifier.prototype._verify = function(cb) {\n      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n            funcname: \"Verifier._verify\"\n          });\n          _this._sig.verify([_this._literal], __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 182\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Verifier.prototype._check_headers = function(cb) {\n      var err, k, v, _ref3;\n      err = null;\n      _ref3 = this.clearsign.headers;\n      for (k in _ref3) {\n        v = _ref3[k];\n        if (k !== 'hash') {\n          err = new Error(\"Unallowed header: \" + k);\n          break;\n        }\n      }\n      return cb(err);\n    };\n\n    Verifier.prototype.run = function(cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Verifier::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n            funcname: \"Verifier.run\"\n          });\n          _this._check_headers(esc(__iced_deferrals.defer({\n            lineno: 199\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n              funcname: \"Verifier.run\"\n            });\n            _this._find_signature(esc(__iced_deferrals.defer({\n              lineno: 200\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                funcname: \"Verifier.run\"\n              });\n              _this._reformat_text(esc(__iced_deferrals.defer({\n                lineno: 201\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                  funcname: \"Verifier.run\"\n                });\n                _this._fetch_key(esc(__iced_deferrals.defer({\n                  lineno: 202\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                    funcname: \"Verifier.run\"\n                  });\n                  _this._make_hasher(esc(__iced_deferrals.defer({\n                    lineno: 203\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n                      funcname: \"Verifier.run\"\n                    });\n                    _this._verify(esc(__iced_deferrals.defer({\n                      lineno: 204\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return cb(null, _this._literal);\n                  });\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Verifier;\n\n  })(VerifierBase);\n\n  exports.sign = function(_arg, cb) {\n    var b, encoded, err, msg, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    msg = _arg.msg, signing_key = _arg.signing_key;\n    b = new ClearSigner({\n      msg: msg,\n      signing_key: signing_key\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n          funcname: \"sign\"\n        });\n        b.run(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              encoded = arguments[1];\n              return signature = arguments[2];\n            };\n          })(),\n          lineno: 215\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        b.scrub();\n        return cb(err, encoded, signature);\n      };\n    })(this));\n  };\n\n  exports.verify = function(_arg, cb) {\n    var clearsign, err, keyfetch, literal, packets, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    packets = _arg.packets, clearsign = _arg.clearsign, keyfetch = _arg.keyfetch;\n    v = new Verifier({\n      packets: packets,\n      clearsign: clearsign,\n      keyfetch: keyfetch\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/clearsign.iced\",\n          funcname: \"verify\"\n        });\n        v.run(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return literal = arguments[1];\n            };\n          })(),\n          lineno: 223\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, literal);\n      };\n    })(this));\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/verifier.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var Base, C, iced, konst, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  exports.Base = Base = (function() {\n    function Base(_arg) {\n      this.packets = _arg.packets, this.keyfetch = _arg.keyfetch;\n      this._sig = null;\n    }\n\n    Base.prototype._find_signature = function(cb) {\n      var err, n;\n      err = (n = this.packets.length) !== 1 ? new Error(\"Expected one signature packet; got \" + n) : (this._sig = this.packets[0]).tag !== C.packet_tags.signature ? new Error(\"Expected a signature packet; but got type=\" + this.packets[0].tag) : null;\n      return cb(err);\n    };\n\n    Base.prototype._fetch_key = function(cb) {\n      var err, i, key_id, keymat, km, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key_id = this._sig.get_key_id();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/verifier.iced\",\n            funcname: \"Base._fetch_key\"\n          });\n          _this.keyfetch.fetch([key_id], konst.ops.verify, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                km = arguments[1];\n                return i = arguments[2];\n              };\n            })(),\n            lineno: 28\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            keymat = km.find_pgp_key_material(key_id);\n            _this._sig.key = keymat.key;\n            _this._sig.key_manager = km;\n            _this._sig.subkey_material = keymat;\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    return Base;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/detachsign.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, Ch, CreationTime, Issuer, Literal, Signature, Signer, Verifier, VerifierBase, WordArray, encode, hash_obj_to_fn, iced, konst, make_esc, packetsigs, streamers, unix_time, __iced_k, __iced_k_noop, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;\n\n  unix_time = require('../util').unix_time;\n\n  WordArray = require('triplesec').WordArray;\n\n  konst = require('../const');\n\n  C = konst.openpgp;\n\n  Ch = require('../header');\n\n  streamers = require('../hash').streamers;\n\n  encode = require('./armor').encode;\n\n  Literal = require(\"./packet/literal\").Literal;\n\n  VerifierBase = require('./verifier').Base;\n\n  packetsigs = require('./packet/packetsigs');\n\n  hash_obj_to_fn = function(obj) {\n    var fn;\n    fn = function(buf) {\n      return obj.finalize(WordArray.from_buffer(buf)).to_buffer();\n    };\n    return fn.algname = buf.algname;\n  };\n\n  Signer = (function() {\n    function Signer(_arg) {\n      this.data = _arg.data, this.hash_streamer = _arg.hash_streamer, this.signing_key = _arg.signing_key;\n    }\n\n    Signer.prototype.run = function(cb) {\n      var encoded, esc, signature, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Signer::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n            funcname: \"Signer.run\"\n          });\n          _this._run_hash(esc(__iced_deferrals.defer({\n            lineno: 39\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n              funcname: \"Signer.run\"\n            });\n            _this._sign(esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return signature = arguments[0];\n                };\n              })(),\n              lineno: 40\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                funcname: \"Signer.run\"\n              });\n              _this._encode(esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return encoded = arguments[0];\n                  };\n                })(),\n                lineno: 41\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null, encoded, signature);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Signer.prototype.scrub = function() {};\n\n    Signer.prototype._sign = function(cb) {\n      var emptybuf, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this.sig = new Signature({\n        sig_type: C.sig_types.canonical_text,\n        key: this.signing_key.key,\n        hashed_subpackets: [new CreationTime(unix_time())],\n        unhashed_subpackets: [new Issuer(this.signing_key.get_key_id())],\n        hasher: this.hash_streamer\n      });\n      emptybuf = new Buffer([]);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n            funcname: \"Signer._sign\"\n          });\n          _this.sig.write(emptybuf, __iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                err = arguments[0];\n                return __slot_1._sig_output = arguments[1];\n              };\n            })(_this),\n            lineno: 60\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, _this._sig_output);\n        };\n      })(this));\n    };\n\n    Signer.prototype._encode = function(cb) {\n      var err, ret;\n      err = null;\n      ret = encode(C.message_types.signature, this._sig_output);\n      return cb(err, ret);\n    };\n\n    Signer.prototype._run_hash = function(cb) {\n      var err;\n      err = null;\n      if (this.hash_streamer != null) {\n\n      } else if (this.data != null) {\n        this.hash_streamer = streamers.SHA512();\n        this.hash_streamer.update(this.data);\n      } else {\n        err = new Error(\"Need either a hasher or data\");\n      }\n      return cb(err);\n    };\n\n    return Signer;\n\n  })();\n\n  Verifier = (function(_super) {\n    __extends(Verifier, _super);\n\n    function Verifier(_arg) {\n      var keyfetch, packets;\n      packets = _arg.packets, this.data = _arg.data, this.data_fn = _arg.data_fn, keyfetch = _arg.keyfetch;\n      Verifier.__super__.constructor.call(this, {\n        packets: packets,\n        keyfetch: keyfetch\n      });\n    }\n\n    Verifier.prototype._consume_data = function(cb) {\n      var buf_hasher, done, err, go, klass, streamer, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      err = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (_this.data_fn != null) {\n            err = null;\n            klass = _this._sig.hasher.klass;\n            streamer = streamers[_this._sig.hasher.algname]();\n            buf_hasher = function(buf) {\n              return streamer.update(buf);\n            };\n            go = true;\n            (function(__iced_k) {\n              var _while;\n              _while = function(__iced_k) {\n                var _break, _continue, _next;\n                _break = __iced_k;\n                _continue = function() {\n                  return iced.trampoline(function() {\n                    return _while(__iced_k);\n                  });\n                };\n                _next = _continue;\n                if (!go) {\n                  return _break();\n                } else {\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                      funcname: \"Verifier._consume_data\"\n                    });\n                    _this.data_fn(buf_hasher, __iced_deferrals.defer({\n                      assign_fn: (function() {\n                        return function() {\n                          err = arguments[0];\n                          return done = arguments[1];\n                        };\n                      })(),\n                      lineno: 102\n                    }));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    return _next((err != null) || done ? go = false : void 0);\n                  });\n                }\n              };\n              _while(__iced_k);\n            })(function() {\n              return __iced_k(_this._sig.hasher = streamer);\n            });\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Verifier.prototype._verify = function(cb) {\n      var data, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      data = this.data ? [\n        new Literal({\n          data: this.data\n        })\n      ] : [];\n      this.literals = data;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n            funcname: \"Verifier._verify\"\n          });\n          _this._sig.verify(data, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 113\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    Verifier.prototype._make_literals = function(cb) {\n      if (!this.literals.length) {\n        this.literals.push(new Literal({\n          data: new Buffer([])\n        }));\n      }\n      this.literals[0].push_sig(new packetsigs.Data({\n        sig: this._sig\n      }));\n      return cb(null);\n    };\n\n    Verifier.prototype.run = function(cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Verifier::run\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n            funcname: \"Verifier.run\"\n          });\n          _this._find_signature(esc(__iced_deferrals.defer({\n            lineno: 128\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n              funcname: \"Verifier.run\"\n            });\n            _this._fetch_key(esc(__iced_deferrals.defer({\n              lineno: 129\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                funcname: \"Verifier.run\"\n              });\n              _this._consume_data(esc(__iced_deferrals.defer({\n                lineno: 130\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                  funcname: \"Verifier.run\"\n                });\n                _this._verify(esc(__iced_deferrals.defer({\n                  lineno: 131\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n                    funcname: \"Verifier.run\"\n                  });\n                  _this._make_literals(esc(__iced_deferrals.defer({\n                    lineno: 132\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return cb(null, _this.literals);\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Verifier;\n\n  })(VerifierBase);\n\n  exports.sign = function(_arg, cb) {\n    var data, encoded, err, hash_streamer, s, signature, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    data = _arg.data, hash_streamer = _arg.hash_streamer, signing_key = _arg.signing_key;\n    s = new Signer({\n      data: data,\n      hash_streamer: hash_streamer,\n      signing_key: signing_key\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n          funcname: \"sign\"\n        });\n        s.run(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              encoded = arguments[1];\n              return signature = arguments[2];\n            };\n          })(),\n          lineno: 139\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        s.scrub();\n        return cb(err, encoded, signature);\n      };\n    })(this));\n  };\n\n  exports.verify = function(_arg, cb) {\n    var data, data_fn, err, keyfetch, literals, packets, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    data = _arg.data, data_fn = _arg.data_fn, packets = _arg.packets, keyfetch = _arg.keyfetch;\n    v = new Verifier({\n      data: data,\n      data_fn: data_fn,\n      packets: packets,\n      keyfetch: keyfetch\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/detachsign.iced\",\n          funcname: \"verify\"\n        });\n        v.run(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return literals = arguments[1];\n            };\n          })(),\n          lineno: 147\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, literals);\n      };\n    })(this));\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/packet/all.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  exports.KeyMaterial = require('./keymaterial').KeyMaterial;\n\n  exports.Signature = require('./signature').Signature;\n\n  exports.UserID = require('./userid').UserID;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keybase/encode.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var K, SHA256, alloc, bufeq_secure, katch, null_hash, obj_extract, pack, purepack, read_base64, seal, unpack, unseal, _ref, _ref1;\n\n  K = require('../const').kb;\n\n  _ref = require('../hash'), alloc = _ref.alloc, SHA256 = _ref.SHA256;\n\n  purepack = require('purepack');\n\n  _ref1 = require('../util'), katch = _ref1.katch, obj_extract = _ref1.obj_extract, bufeq_secure = _ref1.bufeq_secure;\n\n  null_hash = new Buffer(0);\n\n  pack = function(x) {\n    return purepack.pack(x, {\n      sort_keys: true\n    });\n  };\n\n  unpack = function(x) {\n    return purepack.unpack(x, {\n      strict: true\n    });\n  };\n\n  seal = function(_arg) {\n    var dohash, hasher, obj, oo, packed;\n    obj = _arg.obj, dohash = _arg.dohash;\n    hasher = SHA256;\n    oo = {\n      version: K.versions.V1,\n      tag: obj.tag,\n      body: obj.body\n    };\n    if (dohash) {\n      oo.hash = {\n        type: hasher.type,\n        value: null_hash\n      };\n      packed = pack(oo);\n      oo.hash.value = hasher(packed);\n    }\n    return pack(oo);\n  };\n\n  read_base64 = function(raw) {\n    var parts;\n    parts = (raw.split(/\\s+/)).join('');\n    return new Buffer(parts, 'base64');\n  };\n\n  unseal = function(buf) {\n    var h, hasher, hv, oo, t, _ref2;\n    oo = unpack(buf);\n    if ((hv = oo != null ? (_ref2 = oo.hash) != null ? _ref2.value : void 0 : void 0) != null) {\n      oo.hash.value = null_hash;\n      hasher = alloc((t = oo.hash.type));\n      if (hasher == null) {\n        throw new Error(\"unknown hash algo: \" + t);\n      }\n      h = hasher(pack(oo));\n      if (!bufeq_secure(h, hv)) {\n        throw new Error(\"hash mismatch\");\n      }\n      if (oo.version !== K.versions.V1) {\n        throw new Error(\"unknown version\");\n      }\n    }\n    return obj_extract(oo, ['tag', 'body']);\n  };\n\n  exports.seal = seal;\n\n  exports.pack = pack;\n\n  exports.unseal = unseal;\n\n  exports.unpack = unpack;\n\n  exports.read_base64 = read_base64;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keybase/packet/p3skb.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var Decryptor, K, P3SKB, Packet, SHA512, box, bufeq_secure, bufferify, iced, make_esc, native_rng, pack, rsa, triplesec, __iced_k, __iced_k_noop, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  K = require('../../const').kb;\n\n  triplesec = require('triplesec');\n\n  SHA512 = require('../../hash').SHA512;\n\n  Decryptor = triplesec.Decryptor;\n\n  native_rng = triplesec.prng.native_rng;\n\n  Packet = require('./base').Packet;\n\n  _ref = require('../encode'), pack = _ref.pack, box = _ref.box;\n\n  make_esc = require('iced-error').make_esc;\n\n  rsa = require('../../rsa');\n\n  _ref1 = require('../../util'), bufeq_secure = _ref1.bufeq_secure, bufferify = _ref1.bufferify;\n\n  P3SKB = (function(_super) {\n    __extends(P3SKB, _super);\n\n    P3SKB.tag = function() {\n      return K.packet_tags.p3skb;\n    };\n\n    P3SKB.prototype.tag = function() {\n      return P3SKB.tag();\n    };\n\n    function P3SKB(_arg) {\n      var priv, priv_clear;\n      this.pub = _arg.pub, priv_clear = _arg.priv_clear, priv = _arg.priv, this.type = _arg.type;\n      P3SKB.__super__.constructor.call(this);\n      this.priv = priv != null ? priv : priv_clear != null ? {\n        data: priv_clear,\n        encryption: K.key_encryption.none\n      } : void 0;\n    }\n\n    P3SKB.prototype.get_packet_body = function() {\n      var ret;\n      ret = {\n        pub: this.pub,\n        priv: this.priv\n      };\n      if (this.type != null) {\n        ret.type = this.type;\n      }\n      return ret;\n    };\n\n    P3SKB.prototype.lock = function(_arg, cb) {\n      var asp, ct, err, passphrase_generation, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, tsenc = _arg.tsenc, passphrase_generation = _arg.passphrase_generation;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/p3skb.iced\",\n            funcname: \"P3SKB.lock\"\n          });\n          tsenc.run({\n            data: _this.priv.data,\n            progress_hook: asp != null ? asp.progress_hook() : void 0\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return ct = arguments[1];\n              };\n            })(),\n            lineno: 30\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err === \"undefined\" || err === null) {\n            _this.priv.data = ct;\n            _this.priv.encryption = K.key_encryption.triplesec_v3;\n            if (passphrase_generation != null) {\n              _this.priv.passphrase_generation = passphrase_generation;\n            }\n          }\n          return cb(err);\n        };\n      })(this));\n    };\n\n    P3SKB.prototype.unlock = function(_arg, cb) {\n      var a, asp, b, dec, err, passphrase_generation, progress_hook, raw, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, tsenc = _arg.tsenc, passphrase_generation = _arg.passphrase_generation;\n      (function(_this) {\n        return (function(__iced_k) {\n          switch (_this.priv.encryption) {\n            case K.key_encryption.triplesec_v3:\n            case K.key_encryption.triplesec_v2:\n            case K.key_encryption.triplesec_v1:\n              dec = new Decryptor({\n                enc: tsenc\n              });\n              progress_hook = asp != null ? asp.progress_hook() : void 0;\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/p3skb.iced\",\n                  funcname: \"P3SKB.unlock\"\n                });\n                dec.run({\n                  data: _this.priv.data,\n                  progress_hook: progress_hook\n                }, __iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      err = arguments[0];\n                      return raw = arguments[1];\n                    };\n                  })(),\n                  lineno: 42\n                }));\n                __iced_deferrals._fulfill();\n              })(function() {\n                dec.scrub();\n                return __iced_k(typeof err === \"undefined\" || err === null ? (_this.priv.data = raw, _this.priv.encryption = K.key_encryption.none) : ((a = passphrase_generation) != null) && ((b = _this.priv.passphrase_generation) != null) && (a !== b) ? err = new Error(\"Decryption failed, likely due to old passphrase (wanted v\" + a + \" but got v\" + b + \") [\" + (err.toString()) + \"]\") : void 0);\n              });\n              break;\n            case K.key_encryption.none:\n              return __iced_k();\n            default:\n              return __iced_k(err = new Error(\"Unknown key encryption type: \" + k.encryption));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err);\n        };\n      })(this));\n    };\n\n    P3SKB.alloc = function(_arg) {\n      var body, tag;\n      tag = _arg.tag, body = _arg.body;\n      if (tag === P3SKB.tag()) {\n        return new P3SKB(body);\n      } else {\n        throw new Error(\"wrong tag found: \" + tag);\n      }\n    };\n\n    P3SKB.prototype.has_private = function() {\n      return this.priv != null;\n    };\n\n    P3SKB.prototype.is_locked = function() {\n      return this.priv.encryption !== K.key_encryption.none;\n    };\n\n    P3SKB.prototype.get_private_data = function() {\n      var _ref2;\n      return (_ref2 = this.priv) != null ? _ref2.data : void 0;\n    };\n\n    P3SKB.prototype.get_public_data = function() {\n      return this.pub;\n    };\n\n    P3SKB.prototype.get_key_type = function() {\n      return this.type;\n    };\n\n    P3SKB.prototype.is_p3skb = function() {\n      return true;\n    };\n\n    return P3SKB;\n\n  })(Packet);\n\n  exports.P3SKB = P3SKB;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keybase/packet/base.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var K, Packet, seal, util;\n\n  util = require('../../util');\n\n  seal = require('../encode').seal;\n\n  K = require('../../const').kb;\n\n  Packet = (function() {\n    function Packet() {}\n\n    Packet.prototype.frame_packet = function() {\n      return {\n        tag: this.tag(),\n        body: this.get_packet_body()\n      };\n    };\n\n    Packet.prototype.frame_packet_armored = function(_arg) {\n      var dohash, obj;\n      dohash = _arg.dohash;\n      obj = this.frame_packet();\n      return seal({\n        obj: obj,\n        dohash: dohash\n      }).toString('base64');\n    };\n\n    Packet.prototype.is_signature = function() {\n      return false;\n    };\n\n    Packet.prototype.is_p3skb = function() {\n      return false;\n    };\n\n    Packet.alloc = function(_arg) {\n      var P3SKB, Signature, body, err, ret, tag;\n      tag = _arg.tag, body = _arg.body;\n      ret = err = null;\n      ret = (function() {\n        switch (tag) {\n          case K.packet_tags.p3skb:\n            P3SKB = require('./p3skb').P3SKB;\n            return P3SKB.alloc({\n              tag: tag,\n              body: body\n            });\n          case K.packet_tags.signature:\n            Signature = require('./signature').Signature;\n            return Signature.alloc({\n              tag: tag,\n              body: body\n            });\n          default:\n            err = new Error(\"unknown packet tag: \" + tag);\n            return null;\n        }\n      })();\n      return [err, ret];\n    };\n\n    Packet.prototype.unbox = function(params, cb) {\n      return cb(new Error(\"unbox() unimplemented for tag=\" + this.tag));\n    };\n\n    return Packet;\n\n  })();\n\n  exports.Packet = Packet;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/sigeng.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, SignatureEngine, SignatureEngineInterface, burn, decode, decode_sig, get_sig_body, iced, make_esc, processor, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  burn = require('./burner').burn;\n\n  processor = require('./processor');\n\n  decode = require('./armor').decode;\n\n  C = require('../const');\n\n  SignatureEngineInterface = require('../kmi').SignatureEngineInterface;\n\n  exports.decode_sig = decode_sig = function(_arg) {\n    var armored, err, msg, mt, _ref;\n    armored = _arg.armored;\n    _ref = decode(armored), err = _ref[0], msg = _ref[1];\n    mt = C.openpgp.message_types;\n    if ((err == null) && (msg.type !== mt.generic)) {\n      err = new Error(\"wrong message type; expected a generic message; got \" + msg.type);\n    }\n    return [err, msg];\n  };\n\n  exports.get_sig_body = get_sig_body = function(_arg) {\n    var armored, err, msg, res, _ref;\n    armored = _arg.armored;\n    res = null;\n    _ref = decode_sig({\n      armored: armored\n    }), err = _ref[0], msg = _ref[1];\n    if (err == null) {\n      res = msg.body;\n    }\n    return [err, res];\n  };\n\n  exports.SignatureEngine = SignatureEngine = (function(_super) {\n    __extends(SignatureEngine, _super);\n\n    function SignatureEngine(_arg) {\n      this.km = _arg.km;\n    }\n\n    SignatureEngine.prototype.get_km = function() {\n      return this.km;\n    };\n\n    SignatureEngine.prototype.box = function(msg, cb) {\n      var err, out, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      out = {\n        type: \"pgp\"\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          if ((signing_key = _this.km.find_signing_pgp_key()) != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n                funcname: \"SignatureEngine.box\"\n              });\n              burn({\n                msg: msg,\n                signing_key: signing_key\n              }, __iced_deferrals.defer({\n                assign_fn: (function(__slot_1, __slot_2) {\n                  return function() {\n                    err = arguments[0];\n                    __slot_1.pgp = arguments[1];\n                    return __slot_2.raw = arguments[2];\n                  };\n                })(out, out),\n                lineno: 37\n              }));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return __iced_k(typeof err === \"undefined\" || err === null ? out.armored = out.pgp : void 0);\n            });\n          } else {\n            return __iced_k(err = new Error(\"No signing key found\"));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, out);\n        };\n      })(this));\n    };\n\n    SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body = function(_arg, cb) {\n      var body, err, esc, l, literals, m, n, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      body = _arg.body;\n      esc = make_esc(cb, \"get_payload_from_raw_sig_body\");\n      payload = null;\n      m = new processor.Message({});\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n            funcname: \"SignatureEngine.get_unverified_payload_from_raw_sig_body\"\n          });\n          m.parse_and_inflate(body, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return literals = arguments[0];\n              };\n            })(),\n            lineno: 48\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if ((n = literals.length) !== 1 || ((l = literals[0]) == null)) {\n            err = new Error(\"Got \" + n + \" literals; only wanted 1\");\n          } else {\n            payload = l.data;\n          }\n          return cb(err, payload);\n        };\n      })(this));\n    };\n\n    SignatureEngine.prototype.get_body = function(args, cb) {\n      var err, res, _ref;\n      _ref = get_sig_body(args), err = _ref[0], res = _ref[1];\n      return cb(err, res);\n    };\n\n    SignatureEngine.prototype.decode = function(armored, cb) {\n      var err, msg, _ref;\n      _ref = decode_sig({\n        armored: armored\n      }), err = _ref[0], msg = _ref[1];\n      return cb(err, msg);\n    };\n\n    SignatureEngine.prototype.unbox = function(msg, cb, opts) {\n      var eng, esc, literals, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      if (opts == null) {\n        opts = {};\n      }\n      esc = make_esc(cb, \"SignatureEngine::unbox\");\n      (function(_this) {\n        return (function(__iced_k) {\n          if (typeof msg === 'string') {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n                funcname: \"SignatureEngine.unbox\"\n              });\n              _this.decode(msg, esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return msg = arguments[0];\n                  };\n                })(),\n                lineno: 72\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          opts.keyfetch = _this.km;\n          opts.strict = true;\n          eng = new processor.Message(opts);\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n              funcname: \"SignatureEngine.unbox\"\n            });\n            eng.parse_and_process({\n              body: msg.body\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return literals = arguments[0];\n                };\n              })(),\n              lineno: 76\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/sigeng.iced\",\n                funcname: \"SignatureEngine.unbox\"\n              });\n              _this._check_result(literals, esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return payload = arguments[0];\n                  };\n                })(),\n                lineno: 77\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null, payload, msg.body);\n            });\n          });\n        };\n      })(this));\n    };\n\n    SignatureEngine.prototype._check_result = function(literals, cb) {\n      var b, err, l, n, payload, sw, _ref;\n      err = payload = null;\n      if ((n = literals.length) !== 1 || ((l = literals[0]) == null)) {\n        err = new Error(\"Expected only one pgp literal; got \" + n);\n      } else if ((sw = (_ref = l.get_data_signer()) != null ? _ref.sig : void 0) == null) {\n        err = new Error(\"Expected a signature on the payload message\");\n      } else if ((this.km.find_pgp_key((b = sw.get_key_id()))) == null) {\n        err = new Error(\"Failed sanity check; didn't have a key for '\" + (b.toString('hex')) + \"'\");\n      } else {\n        payload = l.data;\n      }\n      return cb(err, payload);\n    };\n\n    return SignatureEngine;\n\n  })(SignatureEngineInterface);\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/burner.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BaseBurner, Burner, C, Compressed, CreationTime, Issuer, Literal, OnePassSignature, PKESK, SEIPD, SHA512, SRF, Signature, WordArray, clearsign, detachsign, dummy_key_id, encode, export_key_pgp, get_cipher, iced, make_esc, make_simple_literals, scrub_buffer, triplesec, unix_time, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  OnePassSignature = require('./packet/one_pass_sig').OnePassSignature;\n\n  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;\n\n  Compressed = require('./packet/compressed').Compressed;\n\n  Literal = require('./packet/literal').Literal;\n\n  unix_time = require('../util').unix_time;\n\n  SRF = require('../rand').SRF;\n\n  triplesec = require('triplesec');\n\n  _ref1 = require('../symmetric'), export_key_pgp = _ref1.export_key_pgp, get_cipher = _ref1.get_cipher;\n\n  scrub_buffer = triplesec.util.scrub_buffer;\n\n  WordArray = triplesec.WordArray;\n\n  _ref2 = require('./packet/sess'), SEIPD = _ref2.SEIPD, PKESK = _ref2.PKESK;\n\n  C = require('../const').openpgp;\n\n  SHA512 = require('../hash').SHA512;\n\n  encode = require('./armor').encode;\n\n  clearsign = require('./clearsign');\n\n  detachsign = require('./detachsign');\n\n  BaseBurner = require('./baseburner').BaseBurner;\n\n  dummy_key_id = new Buffer((function() {\n    var _i, _results;\n    _results = [];\n    for (_i = 0; _i < 16; _i++) {\n      _results.push(0);\n    }\n    return _results;\n  })());\n\n  Burner = (function(_super) {\n    __extends(Burner, _super);\n\n    function Burner(_arg) {\n      var asp, encrypt_for, encryption_key, sign_with, signing_key;\n      this.literals = _arg.literals, this.opts = _arg.opts, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp;\n      Burner.__super__.constructor.call(this, {\n        sign_with: sign_with,\n        encrypt_for: encrypt_for,\n        signing_key: signing_key,\n        encryption_key: encryption_key,\n        asp: asp\n      });\n      this.packets = [];\n      this.opts || (this.opts = {});\n      this.signed_payload = null;\n    }\n\n    Burner.prototype._frame_literals = function(cb) {\n      var esc, l, p, sp, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_frame_literals\");\n      sp = [];\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref3, _results, _while;\n          _ref3 = _this.literals;\n          _len = _ref3.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              l = _ref3[_i];\n              sp.push(l.to_signature_payload());\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                  funcname: \"Burner._frame_literals\"\n                });\n                l.write(esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return p = arguments[0];\n                    };\n                  })(),\n                  lineno: 51\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return _next(_this.packets.push(p));\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          _this.signed_payload = Buffer.concat(sp);\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Burner.prototype._sign = function(cb) {\n      var esc, fp, ops, ops_framed, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_sign'\");\n      ops = new OnePassSignature({\n        sig_type: C.sig_types.binary_doc,\n        hasher: SHA512,\n        sig_klass: this.signing_key.get_klass(),\n        key_id: this.signing_key.get_key_id(),\n        is_final: 1\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._sign\"\n          });\n          ops.write(esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return ops_framed = arguments[0];\n              };\n            })(),\n            lineno: 67\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          sig = new Signature({\n            type: C.sig_types.binary_doc,\n            key: _this.signing_key.key,\n            hashed_subpackets: [new CreationTime(unix_time())],\n            unhashed_subpackets: [new Issuer(_this.signing_key.get_key_id())]\n          });\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._sign\"\n            });\n            _this.asp.progress({\n              what: 'sign',\n              i: 0,\n              total: 1\n            }, esc(__iced_deferrals.defer({\n              lineno: 74\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._sign\"\n              });\n              sig.write(_this.signed_payload, esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return fp = arguments[0];\n                  };\n                })(),\n                lineno: 75\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                  funcname: \"Burner._sign\"\n                });\n                _this.asp.progress({\n                  what: 'sign',\n                  i: 1,\n                  total: 1\n                }, esc(__iced_deferrals.defer({\n                  lineno: 76\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                _this.packets.unshift(ops_framed);\n                _this.packets.push(fp);\n                return cb(null);\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype.collect_packets = function() {\n      var ret;\n      ret = Buffer.concat(this.packets);\n      this.packets = [];\n      return ret;\n    };\n\n    Burner.prototype._compress = function(cb) {\n      var esc, inflated, opkt, pkt, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_compress\");\n      inflated = this.collect_packets();\n      pkt = new Compressed({\n        algo: C.compression.zlib,\n        inflated: inflated\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._compress\"\n          });\n          _this.asp.progress({\n            what: 'compress',\n            i: 0,\n            total: 1\n          }, esc(__iced_deferrals.defer({\n            lineno: 94\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._compress\"\n            });\n            pkt.write(esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return opkt = arguments[0];\n                };\n              })(),\n              lineno: 95\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._compress\"\n              });\n              _this.asp.progress({\n                what: 'compress',\n                i: 1,\n                total: 1\n              }, esc(__iced_deferrals.defer({\n                lineno: 96\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              _this.packets.push(opkt);\n              return cb(null);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype._make_session_key = function(cb) {\n      var ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      this._cipher_algo = C.symmetric_key_algorithms.AES256;\n      this._cipher_info = get_cipher(this._cipher_algo);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._make_session_key\"\n          });\n          SRF().random_bytes(_this._cipher_info.key_size, __iced_deferrals.defer({\n            assign_fn: (function(__slot_1) {\n              return function() {\n                return __slot_1._session_key = arguments[0];\n              };\n            })(_this),\n            lineno: 105\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          _this._cipher = new _this._cipher_info.klass(WordArray.from_buffer(_this._session_key));\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Burner.prototype.scrub = function() {\n      if (this._cipher != null) {\n        this._cipher.scrub();\n      }\n      if (this._session_key != null) {\n        return scrub_buffer(this._session_key);\n      }\n    };\n\n    Burner.prototype._encrypt_session_key_once = function(encryption_key, cb) {\n      var ekey, esc, fingerprint, key_id, payload, pkesk, pkt, pub_k, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"_encrypt_session_key_once\");\n      payload = export_key_pgp(this._cipher_algo, this._session_key);\n      pub_k = encryption_key.key;\n      fingerprint = encryption_key.get_fingerprint();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._encrypt_session_key_once\"\n          });\n          _this.asp.progress({\n            what: 'session key encrypt',\n            i: 0,\n            total: 1\n          }, esc(__iced_deferrals.defer({\n            lineno: 122\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._encrypt_session_key_once\"\n            });\n            pub_k.pad_and_encrypt(payload, {\n              fingerprint: fingerprint\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return ekey = arguments[0];\n                };\n              })(),\n              lineno: 123\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._encrypt_session_key_once\"\n              });\n              _this.asp.progress({\n                what: 'session key encrypt',\n                i: 1,\n                total: 1\n              }, esc(__iced_deferrals.defer({\n                lineno: 124\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              (function(__iced_k) {\n                if (_this.opts.hide) {\n                  key_id = dummy_key_id;\n                  (function(__iced_k) {\n                    __iced_deferrals = new iced.Deferrals(__iced_k, {\n                      parent: ___iced_passed_deferral,\n                      filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                      funcname: \"Burner._encrypt_session_key_once\"\n                    });\n                    _this.asp.progress({\n                      what: 'hide encryption',\n                      i: 0,\n                      total: 1\n                    }, esc(__iced_deferrals.defer({\n                      lineno: 127\n                    })));\n                    __iced_deferrals._fulfill();\n                  })(function() {\n                    (function(__iced_k) {\n                      var _ref3, _ref4;\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                        funcname: \"Burner._encrypt_session_key_once\"\n                      });\n                      ekey.hide({\n                        max: (_ref3 = _this.opts.hide) != null ? _ref3.max : void 0,\n                        slosh: (_ref4 = _this.opts.hide) != null ? _ref4.slosh : void 0,\n                        key: pub_k\n                      }, esc(__iced_deferrals.defer({\n                        lineno: 128\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(function() {\n                      (function(__iced_k) {\n                        __iced_deferrals = new iced.Deferrals(__iced_k, {\n                          parent: ___iced_passed_deferral,\n                          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                          funcname: \"Burner._encrypt_session_key_once\"\n                        });\n                        _this.asp.progress({\n                          what: 'hide encryption',\n                          i: 1,\n                          total: 1\n                        }, esc(__iced_deferrals.defer({\n                          lineno: 129\n                        })));\n                        __iced_deferrals._fulfill();\n                      })(__iced_k);\n                    });\n                  });\n                } else {\n                  return __iced_k(key_id = encryption_key.get_key_id());\n                }\n              })(function() {\n                pkt = new PKESK({\n                  crypto_type: pub_k.type,\n                  key_id: key_id,\n                  ekey: ekey\n                });\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                    funcname: \"Burner._encrypt_session_key_once\"\n                  });\n                  pkt.write(esc(__iced_deferrals.defer({\n                    assign_fn: (function() {\n                      return function() {\n                        return pkesk = arguments[0];\n                      };\n                    })(),\n                    lineno: 137\n                  })));\n                  __iced_deferrals._fulfill();\n                })(function() {\n                  return cb(null, pkesk);\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype._encrypt_session_key = function(cb) {\n      var esc, k, pkesk, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"_encrypt_session_key\");\n      this._pkesks = [];\n      (function(_this) {\n        return (function(__iced_k) {\n          var _i, _len, _ref3, _results, _while;\n          _ref3 = _this.encryption_keys;\n          _len = _ref3.length;\n          _i = 0;\n          _while = function(__iced_k) {\n            var _break, _continue, _next;\n            _break = __iced_k;\n            _continue = function() {\n              return iced.trampoline(function() {\n                ++_i;\n                return _while(__iced_k);\n              });\n            };\n            _next = _continue;\n            if (!(_i < _len)) {\n              return _break();\n            } else {\n              k = _ref3[_i];\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                  funcname: \"Burner._encrypt_session_key\"\n                });\n                _this._encrypt_session_key_once(k, esc(__iced_deferrals.defer({\n                  assign_fn: (function() {\n                    return function() {\n                      return pkesk = arguments[0];\n                    };\n                  })(),\n                  lineno: 146\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                return _next(_this._pkesks.push(pkesk));\n              });\n            }\n          };\n          _while(__iced_k);\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(null);\n        };\n      })(this));\n    };\n\n    Burner.prototype._encrypt_payload = function(cb) {\n      var asp, esc, pkt, plaintext, prefixrandom, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_encrypt_payload\");\n      plaintext = this.collect_packets();\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._encrypt_payload\"\n          });\n          SRF().random_bytes(_this._cipher.blockSize, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return prefixrandom = arguments[0];\n              };\n            })(),\n            lineno: 155\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          pkt = new SEIPD({});\n          asp = _this.asp.section('encrypt payload');\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._encrypt_payload\"\n            });\n            pkt.encrypt({\n              cipher: _this._cipher,\n              plaintext: plaintext,\n              prefixrandom: prefixrandom,\n              asp: asp\n            }, esc(__iced_deferrals.defer({\n              lineno: 158\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._encrypt_payload\"\n              });\n              pkt.write(esc(__iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return pkt = arguments[0];\n                  };\n                })(),\n                lineno: 159\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              scrub_buffer(plaintext);\n              _this.packets = _this._pkesks.concat([pkt]);\n              return cb(null);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype._encrypt = function(cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::_encrypt\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner._encrypt\"\n          });\n          _this._make_session_key(esc(__iced_deferrals.defer({\n            lineno: 168\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner._encrypt\"\n            });\n            _this._encrypt_session_key(esc(__iced_deferrals.defer({\n              lineno: 169\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                funcname: \"Burner._encrypt\"\n              });\n              _this._encrypt_payload(esc(__iced_deferrals.defer({\n                lineno: 170\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null);\n            });\n          });\n        };\n      })(this));\n    };\n\n    Burner.prototype.scrub = function() {};\n\n    Burner.prototype.burn = function(cb) {\n      var esc, output, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"Burner::burn\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n            funcname: \"Burner.burn\"\n          });\n          _this._find_keys(esc(__iced_deferrals.defer({\n            lineno: 181\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n              funcname: \"Burner.burn\"\n            });\n            _this._frame_literals(esc(__iced_deferrals.defer({\n              lineno: 182\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              if (_this.signing_key != null) {\n                (function(__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                    funcname: \"Burner.burn\"\n                  });\n                  _this._sign(esc(__iced_deferrals.defer({\n                    lineno: 184\n                  })));\n                  __iced_deferrals._fulfill();\n                })(__iced_k);\n              } else {\n                return __iced_k();\n              }\n            })(function() {\n              (function(__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                  funcname: \"Burner.burn\"\n                });\n                _this._compress(esc(__iced_deferrals.defer({\n                  lineno: 185\n                })));\n                __iced_deferrals._fulfill();\n              })(function() {\n                (function(__iced_k) {\n                  if (_this.encryption_keys != null) {\n                    (function(__iced_k) {\n                      __iced_deferrals = new iced.Deferrals(__iced_k, {\n                        parent: ___iced_passed_deferral,\n                        filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n                        funcname: \"Burner.burn\"\n                      });\n                      _this._encrypt(esc(__iced_deferrals.defer({\n                        lineno: 187\n                      })));\n                      __iced_deferrals._fulfill();\n                    })(__iced_k);\n                  } else {\n                    return __iced_k();\n                  }\n                })(function() {\n                  output = Buffer.concat(_this.packets);\n                  return cb(null, output);\n                });\n              });\n            });\n          });\n        };\n      })(this));\n    };\n\n    return Burner;\n\n  })(BaseBurner);\n\n  exports.Burner = Burner;\n\n  exports.make_simple_literals = make_simple_literals = function(msg) {\n    return [\n      new Literal({\n        data: new Buffer(msg),\n        format: C.literal_formats.utf8,\n        date: unix_time()\n      })\n    ];\n  };\n\n  exports.clearsign = clearsign.sign;\n\n  exports.detachsign = detachsign.sign;\n\n  exports.burn = function(_arg, cb) {\n    var aout, asp, b, encrypt_for, encryption_key, err, literals, msg, opts, raw, sign_with, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    msg = _arg.msg, literals = _arg.literals, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, signing_key = _arg.signing_key, encryption_key = _arg.encryption_key, asp = _arg.asp, opts = _arg.opts;\n    if ((msg != null) && (literals == null)) {\n      literals = make_simple_literals(msg);\n    }\n    b = new Burner({\n      literals: literals,\n      sign_with: sign_with,\n      encrypt_for: encrypt_for,\n      signing_key: signing_key,\n      encryption_key: encryption_key,\n      asp: asp,\n      opts: opts\n    });\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/burner.iced\",\n          funcname: \"burn\"\n        });\n        b.burn(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              err = arguments[0];\n              return raw = arguments[1];\n            };\n          })(),\n          lineno: 247\n        }));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        b.scrub();\n        if ((typeof raw !== \"undefined\" && raw !== null) && (typeof err === \"undefined\" || err === null)) {\n          aout = encode(C.message_types.generic, raw);\n        }\n        return cb(err, aout, raw);\n      };\n    })(this));\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/baseburner.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var ASP, BaseBurner, iced, make_esc, __iced_k, __iced_k_noop,\n    __slice = [].slice;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  make_esc = require('iced-error').make_esc;\n\n  ASP = require('pgp-utils').util.ASP;\n\n  exports.BaseBurner = BaseBurner = (function() {\n    function BaseBurner(_arg) {\n      this.sign_with = _arg.sign_with, this.encrypt_for = _arg.encrypt_for, this.signing_key = _arg.signing_key, this.encryption_key = _arg.encryption_key, this.asp = _arg.asp;\n      this.asp = ASP.make(this.asp);\n    }\n\n    BaseBurner.prototype._find_keys = function(cb) {\n      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"find_keys\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced\",\n            funcname: \"BaseBurner._find_keys\"\n          });\n          _this._find_signing_key(esc(__iced_deferrals.defer({\n            lineno: 17\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced\",\n              funcname: \"BaseBurner._find_keys\"\n            });\n            _this._find_encryption_key(esc(__iced_deferrals.defer({\n              lineno: 18\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced\",\n                funcname: \"BaseBurner._find_keys\"\n              });\n              _this._assert_one(esc(__iced_deferrals.defer({\n                lineno: 19\n              })));\n              __iced_deferrals._fulfill();\n            })(function() {\n              return cb(null);\n            });\n          });\n        };\n      })(this));\n    };\n\n    BaseBurner.prototype._assert_one = function(cb) {\n      var err;\n      err = null;\n      if (!(this.signing_key != null) && !(this.encryption_keys != null)) {\n        err = new Error(\"need either an encryption or signing key, or both\");\n      }\n      return cb(err);\n    };\n\n    BaseBurner.prototype._find_signing_key = function(cb) {\n      var err;\n      err = null;\n      if ((this.sign_with != null) && (this.signing_key != null)) {\n        err = new Error(\"specify either `sign_with` or `signing_key` but not both\");\n      } else if ((this.sign_with != null) && ((this.signing_key = this.sign_with.find_signing_pgp_key()) == null)) {\n        err = new Error(\"cannot sign with the given KeyManager\");\n      }\n      return cb(err);\n    };\n\n    BaseBurner.prototype._find_encryption_key = function(cb) {\n      var arrayize, count_true, err, f, i, k, _i, _len, _ref;\n      err = null;\n      count_true = function() {\n        var e, i, v, _i, _len;\n        v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        i = 0;\n        for (_i = 0, _len = v.length; _i < _len; _i++) {\n          e = v[_i];\n          if (e) {\n            i++;\n          }\n        }\n        return i;\n      };\n      arrayize = function(e) {\n        if (e == null) {\n          return [];\n        } else if (typeof e === 'object' && Array.isArray(e)) {\n          return e;\n        } else {\n          return [e];\n        }\n      };\n      if (count_true(this.encrypt_for != null, this.encryption_key != null, this.encryption_keys != null) > 1) {\n        err = new Error(\"specify only one of `encrypt_for`, `encryption_keys` and `encryption_key`\");\n      } else if (this.encrypt_for != null) {\n        this.encryption_keys = [];\n        _ref = (this.encrypt_for = arrayize(this.encrypt_for));\n        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n          f = _ref[i];\n          if ((k = f.find_crypt_pgp_key()) != null) {\n            this.encryption_keys.push(k);\n          } else {\n            err = new Error(\"cannot encrypt with the given KeyManager (i=\" + i + \")\");\n            break;\n          }\n        }\n      } else if (this.encryption_key != null) {\n        this.encryption_keys = [this.encryption_key];\n      } else if (this.encryption_keys != null) {\n        this.encryption_keys = arrayize(this.encryption_keys);\n      }\n      return cb(err);\n    };\n\n    return BaseBurner;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/kmi.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var EUI, KeyFetcher, KeyManagerInterface, SignatureEngineInterface, iced, make_esc, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  KeyFetcher = require('./keyfetch').KeyFetcher;\n\n  make_esc = require('iced-error').make_esc;\n\n  EUI = new Error(\"not implemented\");\n\n  exports.KeyManagerInterface = KeyManagerInterface = (function(_super) {\n    __extends(KeyManagerInterface, _super);\n\n    function KeyManagerInterface() {}\n\n    KeyManagerInterface.prototype.get_pgp_fingerprint = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_ekid = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_fp2 = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_fp2_formatted = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_type = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.check_public_eq = function(km2) {\n      return this.EUI;\n    };\n\n    KeyManagerInterface.prototype.get_userids = function() {\n      return [];\n    };\n\n    KeyManagerInterface.prototype.get_primary_keypair = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.get_all_pgp_key_materials = function() {\n      return [];\n    };\n\n    KeyManagerInterface.prototype.get_userids_mark_primary = function() {\n      return [];\n    };\n\n    KeyManagerInterface.prototype.make_sig_eng = function() {\n      return null;\n    };\n\n    KeyManagerInterface.prototype.export_pgp_public = function(opts, cb) {\n      return cb(null, null);\n    };\n\n    KeyManagerInterface.prototype.export_pgp_private = function(opts, cb) {\n      return cb(null, null);\n    };\n\n    KeyManagerInterface.prototype.export_public = function(_arg, cb) {\n      var asp, regen;\n      asp = _arg.asp, regen = _arg.regen;\n      return cb(EUI, null);\n    };\n\n    KeyManagerInterface.prototype.export_private = function(_arg, cb) {\n      var asp, p3skb, passphrase;\n      asp = _arg.asp, passphrase = _arg.passphrase, p3skb = _arg.p3skb;\n      return cb(EUI);\n    };\n\n    KeyManagerInterface.prototype.can_verify = function() {\n      return false;\n    };\n\n    KeyManagerInterface.prototype.can_sign = function() {\n      return false;\n    };\n\n    KeyManagerInterface.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    KeyManagerInterface.prototype.can_decrypt = function() {\n      return false;\n    };\n\n    KeyManagerInterface.prototype.get_all_pgp_key_ids = function() {\n      return [];\n    };\n\n    KeyManagerInterface.prototype.pgp_full_hash = function(opts, cb) {\n      return cb(null, null);\n    };\n\n    return KeyManagerInterface;\n\n  })(KeyFetcher);\n\n  exports.SignatureEngineInterface = SignatureEngineInterface = (function() {\n    function SignatureEngineInterface(_arg) {\n      this.km = _arg.km;\n    }\n\n    SignatureEngineInterface.prototype.get_km = function() {\n      return this.km;\n    };\n\n    SignatureEngineInterface.prototype.box = function(msg, cb) {\n      return cb(EUI);\n    };\n\n    SignatureEngineInterface.prototype.unbox = function(msb, cb) {\n      return cb(EUI);\n    };\n\n    SignatureEngineInterface.prototype.get_body = function(_arg, cb) {\n      var armored;\n      armored = _arg.armored;\n      return cb(EUI);\n    };\n\n    SignatureEngineInterface.prototype.get_unverified_payload_from_raw_sig_body = function(_arg, cb) {\n      var body;\n      body = _arg.body;\n      return cb(EUI);\n    };\n\n    SignatureEngineInterface.prototype.get_body_and_unverified_payload = function(_arg, cb) {\n      var armored, body, esc, payload, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      armored = _arg.armored;\n      esc = make_esc(cb, \"get_body_and_unverified_payload\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/kmi.iced\",\n            funcname: \"SignatureEngineInterface.get_body_and_unverified_payload\"\n          });\n          _this.get_body({\n            armored: armored\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return body = arguments[0];\n              };\n            })(),\n            lineno: 96\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/kmi.iced\",\n              funcname: \"SignatureEngineInterface.get_body_and_unverified_payload\"\n            });\n            _this.get_unverified_payload_from_raw_sig_body({\n              body: body\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return payload = arguments[0];\n                };\n              })(),\n              lineno: 97\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            return cb(null, body, payload);\n          });\n        };\n      })(this));\n    };\n\n    return SignatureEngineInterface;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/basex.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BaseX, BigInteger, base32, base58, buffer_to_ui8a, nbi, nbs, nbv, _ref;\n\n  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger;\n\n  nbs = require('./bn').nbs;\n\n  buffer_to_ui8a = require('./util').buffer_to_ui8a;\n\n  BaseX = (function() {\n    function BaseX(alphabet) {\n      var a, i, _i, _len, _ref1;\n      this.alphabet = alphabet;\n      this.base = this.alphabet.length;\n      this.basebn = nbv(this.base);\n      this.lookup = {};\n      _ref1 = this.alphabet;\n      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\n        a = _ref1[i];\n        this.lookup[a] = i;\n      }\n    }\n\n    BaseX.prototype.encode = function(buffer) {\n      var c, chars, num, pad, q, r, _i, _len;\n      num = nbi().fromBuffer(buffer);\n      chars = (function() {\n        var _ref1, _results;\n        _results = [];\n        while (num.compareTo(BigInteger.ZERO) > 0) {\n          _ref1 = num.divideAndRemainder(this.basebn), q = _ref1[0], r = _ref1[1];\n          c = this.alphabet[r.intValue()];\n          num = q;\n          _results.push(c);\n        }\n        return _results;\n      }).call(this);\n      chars.reverse();\n      pad = [];\n      for (_i = 0, _len = buffer.length; _i < _len; _i++) {\n        c = buffer[_i];\n        if (c === 0) {\n          pad.push(this.alphabet[0]);\n        } else {\n          break;\n        }\n      }\n      return (pad.concat(chars)).join('');\n    };\n\n    BaseX.prototype.decode = function(str) {\n      var base, c, char_index, i, num, pad, start, _i, _j, _len, _ref1;\n      num = BigInteger.ZERO;\n      base = BigInteger.ONE;\n      i = 0;\n      for (i = _i = 0, _len = str.length; _i < _len; i = ++_i) {\n        c = str[i];\n        if (c !== this.alphabet[0]) {\n          break;\n        }\n      }\n      start = i;\n      pad = new Buffer((function() {\n        var _j, _results;\n        _results = [];\n        for (i = _j = 0; 0 <= start ? _j < start : _j > start; i = 0 <= start ? ++_j : --_j) {\n          _results.push(0);\n        }\n        return _results;\n      })());\n      _ref1 = str.slice(start);\n      for (i = _j = _ref1.length - 1; _j >= 0; i = _j += -1) {\n        c = _ref1[i];\n        if ((char_index = this.lookup[c]) == null) {\n          throw new Error('Value passed is not a valid BaseX string.');\n        }\n        num = num.add(base.multiply(nbv(char_index)));\n        base = base.multiply(this.basebn);\n      }\n      return Buffer.concat([pad, new Buffer(num.toByteArray())]);\n    };\n\n    return BaseX;\n\n  })();\n\n  exports.base58 = base58 = new BaseX('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n\n  exports.base32 = base32 = new BaseX('abcdefghijkmnpqrstuvwxyz23456789');\n\n  exports.base91 = new BaseX(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`~!@#$%^&*()-_=+{}[]|;:,<>./?\");\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/openpgp/hilev.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var SignatureEngine, burn, processor;\n\n  burn = require('./burner').burn;\n\n  processor = require('./processor');\n\n  SignatureEngine = require('./sigeng').SignatureEngine;\n\n  exports.box = burn;\n\n  exports.unbox = processor.do_message;\n\n  exports.SignatureEngine = SignatureEngine;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keyring.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var KeyFetcher, PgpKeyRing, hexkid,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  KeyFetcher = require('./keyfetch').KeyFetcher;\n\n  hexkid = function(k) {\n    return k.toString('hex');\n  };\n\n  PgpKeyRing = (function(_super) {\n    __extends(PgpKeyRing, _super);\n\n    function PgpKeyRing() {\n      this._keys = {};\n      this._kms = {};\n    }\n\n    PgpKeyRing.prototype.add_key_manager = function(km) {\n      var k, keys, kid, _i, _len, _results;\n      keys = km.export_pgp_keys_to_keyring();\n      _results = [];\n      for (_i = 0, _len = keys.length; _i < _len; _i++) {\n        k = keys[_i];\n        kid = hexkid(k.key_material.get_key_id());\n        this._keys[kid] = k;\n        _results.push(this._kms[kid] = km);\n      }\n      return _results;\n    };\n\n    PgpKeyRing.prototype.fetch = function(key_ids, ops, cb) {\n      var err, hex_key_ids, i, id, k, key_material, km, obj, ret_i, _i, _len, _ref;\n      key_material = err = obj = null;\n      hex_key_ids = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = key_ids.length; _i < _len; _i++) {\n          k = key_ids[_i];\n          _results.push(hexkid(k));\n        }\n        return _results;\n      })();\n      km = null;\n      for (i = _i = 0, _len = hex_key_ids.length; _i < _len; i = ++_i) {\n        id = hex_key_ids[i];\n        k = this._keys[id];\n        if (k != null ? (_ref = k.key) != null ? _ref.can_perform(ops) : void 0 : void 0) {\n          ret_i = i;\n          km = this._kms[id];\n          break;\n        }\n      }\n      if (km == null) {\n        err = new Error(\"key not found: \" + (JSON.stringify(hex_key_ids)));\n      }\n      if (km) {\n        return km.fetch(key_ids, ops, cb);\n      } else {\n        return cb(err, km, ret_i);\n      }\n    };\n\n    PgpKeyRing.prototype.find_best_key = function(_arg, cb) {\n      var err, flags, key, key_id, kid, km;\n      key_id = _arg.key_id, flags = _arg.flags;\n      if ((km = this._kms[(kid = hexkid(key_id))]) == null) {\n        err = new Error(\"Could not find key for fingerprint \" + kid);\n      } else if ((key = km.find_best_pgp_key(flags)) == null) {\n        err = new Error(\"no matching key for flags: \" + flags);\n      }\n      return cb(err, key);\n    };\n\n    PgpKeyRing.prototype.lookup = function(key_id) {\n      return this._keys[hexkid(key_id)];\n    };\n\n    return PgpKeyRing;\n\n  })(KeyFetcher);\n\n  exports.PgpKeyRing = PgpKeyRing;\n\n  exports.KeyRing = PgpKeyRing;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/ecc/main.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  exports.curves = require('./curves');\n\n  exports.ECDSA = require('./ecdsa').ECDSA;\n\n  exports.ECDH = require('./ecdh').ECDH;\n\n  exports.EDDSA = require('./eddsa').EDDSA;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/nacl/main.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  exports.eddsa = require('./eddsa');\n\n  exports.dh = require('./dh');\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/nacl/eddsa.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BaseKey, BaseKeyPair, K, NaclDh, Pair, Priv, Pub, SRF, TYPE, b2u, bufeq_fast, bufeq_secure, genseed, iced, kbnacl, konst, u2b, __iced_k, __iced_k_noop, _ref,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  kbnacl = require('keybase-nacl');\n\n  SRF = require('../rand').SRF;\n\n  konst = require('../const');\n\n  K = konst.kb;\n\n  _ref = require('../util'), genseed = _ref.genseed, bufeq_secure = _ref.bufeq_secure, bufeq_fast = _ref.bufeq_fast;\n\n  BaseKey = require('../basekeypair').BaseKey;\n\n  BaseKeyPair = require('./base').BaseKeyPair;\n\n  NaclDh = require('./dh').Pair;\n\n  TYPE = K.public_key_algorithms.NACL_EDDSA;\n\n  exports.b2u = b2u = function(b) {\n    return new Uint8Array(b);\n  };\n\n  exports.u2b = u2b = function(u) {\n    return new Buffer(u);\n  };\n\n  Pub = (function() {\n    Pub.HEADER = new Buffer([K.kid.version, TYPE]);\n\n    Pub.TRAILER = new Buffer([K.kid.trailer]);\n\n    Pub.LEN = Pub.HEADER.length + Pub.TRAILER.length + kbnacl.sign.publicKeyLength;\n\n    function Pub(key) {\n      this.key = key;\n    }\n\n    Pub.alloc_kb = function(kid) {\n      var err, key;\n      err = key = null;\n      err = kid.length !== Pub.LEN ? new Error(\"bad key length\") : !bufeq_fast(kid.slice(-1), Pub.TRAILER) ? new Error(\"bad trailing byte\") : !bufeq_fast(kid.slice(0, 2), Pub.HEADER) ? new Error(\"bad header\") : (key = new Pub(kid.slice(2, -1)), null);\n      return [err, key];\n    };\n\n    Pub.prototype.serialize = function() {\n      return this.key;\n    };\n\n    Pub.prototype.nbits = function() {\n      return 255;\n    };\n\n    Pub.prototype.read_params = function(sb) {};\n\n    Pub.prototype.verify = function(_arg, cb) {\n      var detached, err, naclw, payload, sig, _ref1;\n      payload = _arg.payload, sig = _arg.sig, detached = _arg.detached;\n      naclw = kbnacl.alloc({\n        publicKey: this.key\n      });\n      _ref1 = naclw.verify({\n        payload: payload,\n        sig: sig,\n        detached: detached\n      }), err = _ref1[0], payload = _ref1[1];\n      return cb(err, payload);\n    };\n\n    return Pub;\n\n  })();\n\n  Priv = (function() {\n    function Priv(key) {\n      this.key = key;\n    }\n\n    Priv.prototype.alloc = function(raw) {\n      var err, key;\n      err = key = null;\n      if (raw.length !== sign.secretKeyLength) {\n        err = new Error(\"Bad secret key length\");\n      } else {\n        key = new Priv(raw);\n      }\n      return [err, key];\n    };\n\n    Priv.prototype.sign = function(_arg, cb) {\n      var detached, naclw, payload, sig;\n      payload = _arg.payload, detached = _arg.detached;\n      naclw = kbnacl.alloc({\n        secretKey: this.key\n      });\n      sig = naclw.sign({\n        payload: payload,\n        detached: detached\n      });\n      return cb(sig);\n    };\n\n    return Priv;\n\n  })();\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    Pair.type = K.public_key_algorithms.NACL_EDDSA;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.klass_name = \"EDDSA\";\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.prototype.can_encrypt = function() {\n      return false;\n    };\n\n    Pair.prototype.hash = function() {\n      return this.serialize();\n    };\n\n    Pair.prototype.sign_kb = function(_arg, cb) {\n      var detached, err, payload, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      payload = _arg.payload, detached = _arg.detached;\n      err = sig = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (_this.priv != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/nacl/eddsa.iced\",\n                funcname: \"Pair.sign_kb\"\n              });\n              _this.priv.sign({\n                payload: payload,\n                detached: detached\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    return sig = arguments[0];\n                  };\n                })(),\n                lineno: 108\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(err = new Error(\"no secret key available\"));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, sig);\n        };\n      })(this));\n    };\n\n    Pair.prototype.verify_kb = function(_arg, cb) {\n      var detached, payload, sig;\n      payload = _arg.payload, sig = _arg.sig, detached = _arg.detached;\n      return this.pub.verify({\n        payload: payload,\n        sig: sig,\n        detached: detached\n      }, cb);\n    };\n\n    Pair.subkey_algo = function(flags) {\n      if (flags & (C.key_flags.certify_keys | C.key_flags.sign_data)) {\n        return Pair;\n      } else {\n        return NaclDh;\n      }\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = C.key_flags.certify_keys | C.key_flags.sign_data;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, hash, hasher, sig;\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      return cb(new Error(\"verify_unpad_and_check_hash unsupported\"));\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var hasher;\n      hasher = _arg.hasher;\n      return cb(new Error(\"pad_and_sign unsupported\"));\n    };\n\n    Pair.parse_kb = function(pub_raw) {\n      return BaseKeyPair.parse_kb(Pair, pub_raw);\n    };\n\n    Pair.parse_sig = function(slice) {\n      var err;\n      err = new Error(\"@parse_sig unsupported\");\n      throw err;\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var err;\n      err = new Error(\"@read_sig_from_buf unsupported\");\n      return [err];\n    };\n\n    Pair.import_private = function(_arg, cb) {\n      var a, b, err, priv, pub, raw, ret;\n      raw = _arg.raw;\n      if ((a = raw.length) !== (b = kbnacl.sign.secretKeyLength)) {\n        err = new Error(\"Bad length: expected \" + b + \"} bytes, but got \" + a);\n      } else {\n        pub = new Pub(raw.slice(-kbnacl.sign.publicKeyLength));\n        priv = new Priv(raw);\n        ret = new Pair({\n          priv: priv,\n          pub: pub\n        });\n      }\n      return cb(err, ret);\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var arg, err, naclw, priv, pub, publicKey, ret, secretKey, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      seed = _arg.seed, split = _arg.split, server_half = _arg.server_half;\n      arg = {\n        seed: seed,\n        split: split,\n        len: kbnacl.sign.seedLength,\n        server_half: server_half\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/nacl/eddsa.iced\",\n            funcname: \"Pair.generate\"\n          });\n          genseed(arg, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                server_half = arguments[1].server_half;\n                return seed = arguments[1].seed;\n              };\n            })(),\n            lineno: 185\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref1;\n          ret = null;\n          if (typeof err === \"undefined\" || err === null) {\n            naclw = kbnacl.alloc({});\n            _ref1 = naclw.genFromSeed({\n              seed: seed\n            }), secretKey = _ref1.secretKey, publicKey = _ref1.publicKey;\n            pub = new Pub(publicKey);\n            priv = new Priv(secretKey);\n            ret = new Pair({\n              pub: pub,\n              priv: priv\n            });\n          }\n          return cb(err, ret, server_half);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.EdDSA = exports.Pair = Pair;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/nacl/base.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BaseKeyPair, Pair,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  BaseKeyPair = require('../basekeypair').BaseKeyPair;\n\n  exports.BaseKeyPair = Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    function Pair() {\n      return Pair.__super__.constructor.apply(this, arguments);\n    }\n\n    Pair.prototype.export_secret_key_kb = function(args, cb) {\n      var err, res, _ref;\n      err = res = null;\n      if ((res = (_ref = this.priv) != null ? _ref.key : void 0) == null) {\n        err = new Error(\"no private key available\");\n      }\n      return cb(err, res);\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/nacl/dh.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var BaseKey, BaseKeyPair, K, NaclEddsa, Pair, Priv, Pub, SRF, TYPE, b2u, box, bufeq_fast, genseed, iced, konst, u2b, __iced_k, __iced_k_noop, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  box = require('tweetnacl').box;\n\n  SRF = require('../rand').SRF;\n\n  konst = require('../const');\n\n  K = konst.kb;\n\n  _ref = require('../util'), genseed = _ref.genseed, bufeq_fast = _ref.bufeq_fast;\n\n  BaseKey = require('../basekeypair').BaseKey;\n\n  BaseKeyPair = require('./base').BaseKeyPair;\n\n  _ref1 = require('./eddsa'), b2u = _ref1.b2u, u2b = _ref1.u2b;\n\n  NaclEddsa = require('./eddsa').Pair;\n\n  TYPE = K.public_key_algorithms.NACL_DH;\n\n  b2u = function(b) {\n    return new Uint8Array(b);\n  };\n\n  u2b = function(u) {\n    return new Buffer(u);\n  };\n\n  Pub = (function() {\n    Pub.HEADER = new Buffer([K.kid.version, TYPE]);\n\n    Pub.TRAILER = new Buffer([K.kid.trailer]);\n\n    Pub.LEN = Pub.HEADER.length + Pub.TRAILER.length + box.publicKeyLength;\n\n    function Pub(key) {\n      this.key = key;\n    }\n\n    Pub.alloc_kb = function(kid) {\n      var err, key;\n      err = key = null;\n      err = kid.length !== Pub.LEN ? new Error(\"bad key length\") : !bufeq_fast(kid.slice(-1), Pub.TRAILER) ? new Error(\"bad trailing byte\") : !bufeq_fast(kid.slice(0, 2), Pub.HEADER) ? new Error(\"bad header\") : (key = new Pub(kid.slice(2, -1)), null);\n      return [err, key];\n    };\n\n    Pub.prototype.serialize = function() {\n      return this.key;\n    };\n\n    Pub.prototype.nbits = function() {\n      return 255;\n    };\n\n    Pub.prototype.read_params = function(sb) {};\n\n    Pub.prototype.encrypt = function(_arg, cb) {\n      var nonce, plaintext, res, sender, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      plaintext = _arg.plaintext, sender = _arg.sender;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/nacl/dh.iced\",\n            funcname: \"Pub.encrypt\"\n          });\n          SRF().random_bytes(box.nonceLength, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return nonce = arguments[0];\n              };\n            })(),\n            lineno: 50\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          res = box(b2u(plaintext), b2u(nonce), b2u(_this.key), b2u(sender.priv.key));\n          return cb(null, {\n            ciphertext: u2b(res),\n            nonce: nonce\n          });\n        };\n      })(this));\n    };\n\n    return Pub;\n\n  })();\n\n  Priv = (function() {\n    function Priv(key) {\n      this.key = key;\n    }\n\n    Priv.prototype.alloc = function(raw) {\n      var err, key;\n      err = key = null;\n      if (raw.length !== box.secretKeyLength) {\n        err = new Error(\"Bad secret key length\");\n      } else {\n        key = new Priv(raw);\n      }\n      return [err, key];\n    };\n\n    Priv.prototype.decrypt = function(_arg, cb) {\n      var ciphertext, err, nonce, res, sender;\n      ciphertext = _arg.ciphertext, nonce = _arg.nonce, sender = _arg.sender;\n      err = res = null;\n      res = box.open(b2u(ciphertext), b2u(nonce), b2u(sender.pub.key), b2u(this.key));\n      if (res === false) {\n        err = new Error(\"decryption failed\");\n        res = null;\n      } else {\n        res = u2b(res);\n      }\n      return cb(err, res);\n    };\n\n    return Priv;\n\n  })();\n\n  Pair = (function(_super) {\n    __extends(Pair, _super);\n\n    Pair.Pub = Pub;\n\n    Pair.prototype.Pub = Pub;\n\n    Pair.Priv = Priv;\n\n    Pair.prototype.Priv = Priv;\n\n    function Pair(_arg) {\n      var priv, pub;\n      pub = _arg.pub, priv = _arg.priv;\n      Pair.__super__.constructor.call(this, {\n        pub: pub,\n        priv: priv\n      });\n    }\n\n    Pair.type = K.public_key_algorithms.NACL_DH;\n\n    Pair.prototype.type = Pair.type;\n\n    Pair.prototype.get_type = function() {\n      return this.type;\n    };\n\n    Pair.klass_name = \"DH\";\n\n    Pair.prototype.can_encrypt = function() {\n      return true;\n    };\n\n    Pair.prototype.can_sign = function() {\n      return false;\n    };\n\n    Pair.prototype.hash = function() {\n      return this.serialize();\n    };\n\n    Pair.prototype.encrypt_kb = function(_arg, cb) {\n      var plaintext, sender;\n      plaintext = _arg.plaintext, sender = _arg.sender;\n      return this.pub.encrypt({\n        plaintext: plaintext,\n        sender: sender\n      }, cb);\n    };\n\n    Pair.prototype.decrypt_kb = function(_arg, cb) {\n      var ciphertext, err, nonce, plaintex, plaintext, sender, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      ciphertext = _arg.ciphertext, nonce = _arg.nonce, sender = _arg.sender;\n      err = plaintex = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (_this.priv != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/nacl/dh.iced\",\n                funcname: \"Pair.decrypt_kb\"\n              });\n              _this.priv.decrypt({\n                ciphertext: ciphertext,\n                nonce: nonce,\n                sender: sender\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return plaintext = arguments[1];\n                  };\n                })(),\n                lineno: 118\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(err = new Error(\"no secret key available\"));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, plaintext);\n        };\n      })(this));\n    };\n\n    Pair.subkey_algo = function(flags) {\n      if (flags & (C.key_flags.encrypt_comm | C.key_flags.encrypt_storage)) {\n        return Pair;\n      } else {\n        return NaclEddsa;\n      }\n    };\n\n    Pair.prototype.fulfills_flags = function(flags) {\n      var good_for;\n      good_for = C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;\n      return (flags & good_for) === flags;\n    };\n\n    Pair.prototype.verify_unpad_and_check_hash = function(_arg, cb) {\n      var data, hash, hasher, sig;\n      sig = _arg.sig, data = _arg.data, hasher = _arg.hasher, hash = _arg.hash;\n      return cb(new Error(\"verify_unpad_and_check_hash unsupported\"));\n    };\n\n    Pair.prototype.pad_and_sign = function(data, _arg, cb) {\n      var hasher;\n      hasher = _arg.hasher;\n      return cb(new Error(\"pad_and_sign unsupported\"));\n    };\n\n    Pair.parse_kb = function(pub_raw) {\n      return BaseKeyPair.parse_kb(Pair, pub_raw);\n    };\n\n    Pair.parse_sig = function(slice) {\n      var err;\n      err = new Error(\"@parse_sig unsupported\");\n      throw err;\n    };\n\n    Pair.read_sig_from_buf = function(buf) {\n      var err;\n      err = new Error(\"@read_sig_from_buf unsupported\");\n      return [err];\n    };\n\n    Pair.generate = function(_arg, cb) {\n      var arg, err, priv, pub, publicKey, ret, secretKey, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      server_half = _arg.server_half, seed = _arg.seed, split = _arg.split;\n      arg = {\n        seed: seed,\n        split: split,\n        len: box.secretKeyLength,\n        server_half: server_half\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/nacl/dh.iced\",\n            funcname: \"Pair.generate\"\n          });\n          genseed(arg, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                server_half = arguments[1].server_half;\n                return seed = arguments[1].seed;\n              };\n            })(),\n            lineno: 179\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          var _ref2;\n          ret = null;\n          if (typeof err === \"undefined\" || err === null) {\n            _ref2 = box.keyPair.fromSecretKey(b2u(seed)), secretKey = _ref2.secretKey, publicKey = _ref2.publicKey;\n            pub = new Pub(u2b(publicKey));\n            priv = new Priv(u2b(secretKey));\n            ret = new Pair({\n              pub: pub,\n              priv: priv\n            });\n          }\n          return cb(err, ret, server_half);\n        };\n      })(this));\n    };\n\n    return Pair;\n\n  })(BaseKeyPair);\n\n  exports.DH = exports.Pair = Pair;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keybase/hilev.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, DH, EdDSA, EncKeyManager, Encryption, K, KeyManager, KeyManagerInterface, Signature, SignatureEngine, SignatureEngineInterface, akatch, alloc, asyncify, athrow, base64u, box, buffer_xor, bufferify, decode_sig, encode, errors, get_sig_body, iced, konst, make_esc, unbox, unbox_decode, __iced_k, __iced_k_noop, _ref, _ref1,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  _ref = require('../kmi'), SignatureEngineInterface = _ref.SignatureEngineInterface, KeyManagerInterface = _ref.KeyManagerInterface;\n\n  make_esc = require('iced-error').make_esc;\n\n  encode = require('./encode');\n\n  _ref1 = require('../util'), athrow = _ref1.athrow, bufferify = _ref1.bufferify, base64u = _ref1.base64u, buffer_xor = _ref1.buffer_xor, asyncify = _ref1.asyncify, akatch = _ref1.akatch;\n\n  konst = require('../const');\n\n  alloc = require('./packet/alloc').alloc;\n\n  Signature = require('./packet/signature').Signature;\n\n  Encryption = require('./packet/encryption').Encryption;\n\n  EdDSA = require('../nacl/eddsa').EdDSA;\n\n  errors = require('../errors').errors;\n\n  DH = require('../nacl/dh').DH;\n\n  K = konst.kb;\n\n  C = konst.openpgp;\n\n  KeyManager = (function(_super) {\n    __extends(KeyManager, _super);\n\n    function KeyManager(_arg) {\n      this.key = _arg.key, this.server_half = _arg.server_half;\n    }\n\n    KeyManager.generate = function(_arg, cb) {\n      var algo, err, key, klass, seed, server_half, split, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      algo = _arg.algo, seed = _arg.seed, split = _arg.split, server_half = _arg.server_half, klass = _arg.klass;\n      algo || (algo = EdDSA);\n      klass || (klass = KeyManager);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"KeyManager.generate\"\n          });\n          algo.generate({\n            split: split,\n            seed: seed,\n            server_half: server_half\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                key = arguments[1];\n                return server_half = arguments[2];\n              };\n            })(),\n            lineno: 30\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, new klass({\n            key: key,\n            server_half: server_half\n          }));\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.get_mask = function() {\n      return C.key_flags.sign_data | C.key_flags.certify_keys | C.key_flags.auth;\n    };\n\n    KeyManager.prototype.fetch = function(key_ids, flags, cb) {\n      var err, key, mask, s;\n      s = this.key.ekid().toString('hex');\n      key = null;\n      mask = this.get_mask();\n      if ((__indexOf.call(key_ids, s) >= 0) && (flags & mask) === flags) {\n        key = this.key;\n      } else {\n        err = new Error(\"Key not found\");\n      }\n      return cb(err, key);\n    };\n\n    KeyManager.prototype.get_keypair = function() {\n      return this.key;\n    };\n\n    KeyManager.prototype.get_primary_keypair = function() {\n      return this.key;\n    };\n\n    KeyManager.prototype.can_verify = function() {\n      return true;\n    };\n\n    KeyManager.prototype.can_sign = function() {\n      var _ref2;\n      return (_ref2 = this.key) != null ? _ref2.can_sign() : void 0;\n    };\n\n    KeyManager.prototype.eq = function(km2) {\n      return this.key.eq(km2.key);\n    };\n\n    KeyManager.import_private = function(_arg, cb) {\n      var err, hex, key, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hex = _arg.hex, raw = _arg.raw;\n      err = ret = null;\n      if (hex != null) {\n        raw = new Buffer(hex, 'hex');\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"KeyManager.import_private\"\n          });\n          EdDSA.import_private({\n            raw: raw\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return key = arguments[1];\n              };\n            })(),\n            lineno: 65\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (err == null) {\n            ret = new KeyManager({\n              key: key\n            });\n          }\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    KeyManager.import_public = function(_arg, cb) {\n      var err, hex, key, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref2;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hex = _arg.hex, raw = _arg.raw;\n      err = ret = null;\n      if (hex != null) {\n        raw = new Buffer(hex, 'hex');\n      }\n      _ref2 = EdDSA.parse_kb(raw), err = _ref2[0], key = _ref2[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err != null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n                funcname: \"KeyManager.import_public\"\n              });\n              EncKeyManager.import_public({\n                raw: raw\n              }, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return ret = arguments[1];\n                  };\n                })(),\n                lineno: 77\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k(ret = new KeyManager({\n              key: key\n            }));\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.check_public_eq = function(km2) {\n      return this.eq(km2);\n    };\n\n    KeyManager.prototype.export_public = function(_arg, cb) {\n      var asp, regen, ret;\n      asp = _arg.asp, regen = _arg.regen;\n      ret = this.key.ekid().toString('hex');\n      return cb(null, ret);\n    };\n\n    KeyManager.prototype.export_private = function(_arg, cb) {\n      var asp, err, p3skb, passphrase, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      asp = _arg.asp, p3skb = _arg.p3skb, passphrase = _arg.passphrase;\n      err = res = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (p3skb) {\n            return __iced_k(err = new Error(\"No support yet for P3SKB encrypted secret key exports\"));\n          } else {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n                funcname: \"KeyManager.export_private\"\n              });\n              _this.key.export_secret_key_kb({}, __iced_deferrals.defer({\n                assign_fn: (function() {\n                  return function() {\n                    err = arguments[0];\n                    return res = arguments[1];\n                  };\n                })(),\n                lineno: 99\n              }));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, res);\n        };\n      })(this));\n    };\n\n    KeyManager.prototype.export_server_half = function() {\n      var _ref2;\n      return (_ref2 = this.server_half) != null ? _ref2.toString('hex') : void 0;\n    };\n\n    KeyManager.prototype.get_ekid = function() {\n      return this.get_keypair().ekid();\n    };\n\n    KeyManager.prototype.get_fp2 = function() {\n      return this.get_ekid();\n    };\n\n    KeyManager.prototype.get_fp2_formatted = function() {\n      return base64u.encode(this.get_fp2());\n    };\n\n    KeyManager.prototype.get_type = function() {\n      return \"kb\";\n    };\n\n    KeyManager.prototype.make_sig_eng = function() {\n      return new SignatureEngine({\n        km: this\n      });\n    };\n\n    return KeyManager;\n\n  })(KeyManagerInterface);\n\n  EncKeyManager = (function(_super) {\n    __extends(EncKeyManager, _super);\n\n    function EncKeyManager() {\n      return EncKeyManager.__super__.constructor.apply(this, arguments);\n    }\n\n    EncKeyManager.generate = function(params, cb) {\n      params.algo = DH;\n      params.klass = EncKeyManager;\n      return KeyManager.generate(params, cb);\n    };\n\n    EncKeyManager.prototype.make_sig_eng = function() {\n      return null;\n    };\n\n    EncKeyManager.prototype.can_sign = function() {\n      return false;\n    };\n\n    EncKeyManager.prototype.can_verify = function() {\n      return false;\n    };\n\n    EncKeyManager.prototype.can_encrypt = function() {\n      return true;\n    };\n\n    EncKeyManager.prototype.can_decrypt = function() {\n      var _ref2;\n      return ((_ref2 = this.key) != null ? _ref2.priv : void 0) != null;\n    };\n\n    EncKeyManager.import_private = function(_arg, cb) {\n      var err, hex, km, raw, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      hex = _arg.hex, raw = _arg.raw;\n      err = ret = null;\n      if (hex != null) {\n        raw = new Buffer(hex, 'hex');\n      }\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"EncKeyManager.import_private\"\n          });\n          EncKeyManager.generate({\n            seed: raw\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return km = arguments[1];\n              };\n            })(),\n            lineno: 141\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, km);\n        };\n      })(this));\n    };\n\n    EncKeyManager.prototype.get_mask = function() {\n      return C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;\n    };\n\n    EncKeyManager.import_public = function(_arg, cb) {\n      var err, hex, key, raw, ret, _ref2;\n      hex = _arg.hex, raw = _arg.raw;\n      err = ret = null;\n      if (hex != null) {\n        raw = new Buffer(hex, 'hex');\n      }\n      _ref2 = DH.parse_kb(raw), err = _ref2[0], key = _ref2[1];\n      if (err == null) {\n        ret = new EncKeyManager({\n          key: key\n        });\n      }\n      return cb(err, ret);\n    };\n\n    return EncKeyManager;\n\n  })(KeyManager);\n\n  unbox_decode = function(_arg) {\n    var armored, binary, e, err, rawobj, ret, _ref2;\n    armored = _arg.armored, binary = _arg.binary, rawobj = _arg.rawobj;\n    err = ret = null;\n    if ((armored == null) && (rawobj == null) && (binary == null)) {\n      err = new Error(\"need either 'armored' or 'binary' or 'rawobj'\");\n      return [err, null];\n    }\n    if (armored != null) {\n      binary = new Buffer(armored, 'base64');\n    }\n    if (binary != null) {\n      try {\n        rawobj = encode.unseal(binary);\n      } catch (_error) {\n        e = _error;\n        return [e, null];\n      }\n    }\n    _ref2 = alloc(rawobj), err = _ref2[0], ret = _ref2[1];\n    return [err, ret, binary];\n  };\n\n  unbox = function(_arg, cb) {\n    var armored, binary, encrypt_for, esc, packet, rawobj, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    armored = _arg.armored, binary = _arg.binary, rawobj = _arg.rawobj, encrypt_for = _arg.encrypt_for;\n    esc = make_esc(cb, \"unbox\");\n    (function(_this) {\n      return (function(__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n        });\n        asyncify(unbox_decode({\n          armored: armored,\n          binary: binary,\n          rawobj: rawobj\n        }), esc(__iced_deferrals.defer({\n          assign_fn: (function() {\n            return function() {\n              packet = arguments[0];\n              return binary = arguments[1];\n            };\n          })(),\n          lineno: 181\n        })));\n        __iced_deferrals._fulfill();\n      });\n    })(this)((function(_this) {\n      return function() {\n        (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n          });\n          packet.unbox({\n            encrypt_for: encrypt_for\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return res = arguments[0];\n              };\n            })(),\n            lineno: 182\n          })));\n          __iced_deferrals._fulfill();\n        })(function() {\n          if (res.keypair != null) {\n            res.km = new KeyManager({\n              key: res.keypair\n            });\n          }\n          if (res.sender_keypair != null) {\n            res.sender_km = new KeyManager({\n              key: res.sender_keypair\n            });\n          }\n          if (res.receiver_keypair != null) {\n            res.receiver_km = new KeyManager({\n              key: res.receiver_keypair\n            });\n          }\n          return cb(null, res, binary);\n        });\n      };\n    })(this));\n  };\n\n  box = function(_arg, cb) {\n    var anonymous, armored, encrypt_for, esc, msg, packed, packet, sealed, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    msg = _arg.msg, sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, anonymous = _arg.anonymous;\n    esc = make_esc(cb, \"box\");\n    msg = bufferify(msg);\n    (function(_this) {\n      return (function(__iced_k) {\n        if (encrypt_for != null) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n            });\n            Encryption.box({\n              sign_with: sign_with,\n              encrypt_for: encrypt_for,\n              plaintext: msg,\n              anonymous: anonymous\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return packet = arguments[0];\n                };\n              })(),\n              lineno: 199\n            })));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        } else {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\"\n            });\n            Signature.box({\n              km: sign_with,\n              payload: msg\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return packet = arguments[0];\n                };\n              })(),\n              lineno: 201\n            })));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        packed = packet.frame_packet();\n        sealed = encode.seal({\n          obj: packed,\n          dohash: false\n        });\n        armored = sealed.toString('base64');\n        return cb(null, armored, sealed);\n      };\n    })(this));\n  };\n\n  get_sig_body = function(_arg) {\n    var armored, decoded, err, _ref2;\n    armored = _arg.armored;\n    _ref2 = decode_sig({\n      armored: armored\n    }), err = _ref2[0], decoded = _ref2[1];\n    return [err, decoded != null ? decoded.body : void 0];\n  };\n\n  decode_sig = function(_arg) {\n    var armored, decoded;\n    armored = _arg.armored;\n    decoded = {\n      body: new Buffer(armored, 'base64'),\n      type: C.message_types.generic,\n      payload: armored\n    };\n    return [null, decoded];\n  };\n\n  SignatureEngine = (function(_super) {\n    __extends(SignatureEngine, _super);\n\n    function SignatureEngine(_arg) {\n      this.km = _arg.km;\n    }\n\n    SignatureEngine.prototype.get_km = function() {\n      return this.km;\n    };\n\n    SignatureEngine.prototype.get_unverified_payload_from_raw_sig_body = function(_arg, cb) {\n      var body, esc, packet, rawobj, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      body = _arg.body;\n      esc = make_esc(cb, \"get_payload_from_raw_sig_body\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"SignatureEngine.get_unverified_payload_from_raw_sig_body\"\n          });\n          akatch((function() {\n            return encode.unseal(body);\n          }), esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return rawobj = arguments[0];\n              };\n            })(),\n            lineno: 236\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n              funcname: \"SignatureEngine.get_unverified_payload_from_raw_sig_body\"\n            });\n            asyncify(alloc(rawobj), esc(__iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  return packet = arguments[0];\n                };\n              })(),\n              lineno: 237\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            return cb(null, packet.payload);\n          });\n        };\n      })(this));\n    };\n\n    SignatureEngine.prototype.get_body = function(args, cb) {\n      var err, res, _ref2;\n      _ref2 = get_sig_body(args, cb), err = _ref2[0], res = _ref2[1];\n      return cb(err, res);\n    };\n\n    SignatureEngine.prototype.box = function(msg, cb) {\n      var armored, esc, out, raw, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"SignatureEngine::box\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"SignatureEngine.box\"\n          });\n          box({\n            msg: msg,\n            sign_with: _this.km\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                armored = arguments[0];\n                return raw = arguments[1];\n              };\n            })(),\n            lineno: 250\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          out = {\n            type: \"kb\",\n            armored: armored,\n            kb: armored,\n            raw: raw\n          };\n          return cb(null, out);\n        };\n      })(this));\n    };\n\n    SignatureEngine.prototype.unbox = function(msg, cb, opts) {\n      var a, arg, b, binary, err, esc, payload, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      if (opts == null) {\n        opts = {};\n      }\n      esc = make_esc(cb, \"SignatureEngine::unbox\");\n      err = payload = null;\n      arg = Buffer.isBuffer(msg) ? {\n        binary: msg\n      } : {\n        armored: msg\n      };\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/hilev.iced\",\n            funcname: \"SignatureEngine.unbox\"\n          });\n          unbox(arg, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                res = arguments[0];\n                return binary = arguments[1];\n              };\n            })(),\n            lineno: 261\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (!res.km.eq(_this.km)) {\n            a = res.km.get_ekid().toString('hex');\n            b = _this.km.get_ekid().toString('hex');\n            err = new errors.WrongSigningKeyError(\"Got wrong signing key\");\n          } else {\n            payload = res.payload;\n          }\n          return cb(err, payload, binary);\n        };\n      })(this));\n    };\n\n    return SignatureEngine;\n\n  })(SignatureEngineInterface);\n\n  module.exports = {\n    box: box,\n    unbox: unbox,\n    unbox_decode: unbox_decode,\n    KeyManager: KeyManager,\n    EncKeyManager: EncKeyManager,\n    decode_sig: decode_sig,\n    get_sig_body: get_sig_body\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keybase/packet/alloc.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var Encryption, K, P3SKB, Signature;\n\n  K = require('../../const').kb;\n\n  P3SKB = require('./p3skb').P3SKB;\n\n  Signature = require('./signature').Signature;\n\n  Encryption = require('./encryption').Encryption;\n\n  exports.alloc = function(_arg) {\n    var body, err, ret, tag;\n    tag = _arg.tag, body = _arg.body;\n    ret = err = null;\n    ret = (function() {\n      switch (tag) {\n        case K.packet_tags.p3skb:\n          return P3SKB.alloc({\n            tag: tag,\n            body: body\n          });\n        case K.packet_tags.signature:\n          return Signature.alloc({\n            tag: tag,\n            body: body\n          });\n        case K.packet_tags.encryption:\n          return Encryption.alloc({\n            tag: tag,\n            body: body\n          });\n        default:\n          err = new Error(\"unknown packet tag: \" + tag);\n          return null;\n      }\n    })();\n    return [err, ret];\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keybase/packet/signature.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, K, Packet, Signature, eddsa, iced, konst, make_esc, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  konst = require('../../const');\n\n  K = konst.kb;\n\n  C = konst.openpgp;\n\n  Packet = require('./base').Packet;\n\n  make_esc = require('iced-error').make_esc;\n\n  eddsa = require('../../nacl/main').eddsa;\n\n  Signature = (function(_super) {\n    __extends(Signature, _super);\n\n    Signature.SIG_TYPE = K.public_key_algorithms.NACL_EDDSA;\n\n    Signature.HASH_TYPE = C.hash_algorithms.SHA512;\n\n    Signature.tag = function() {\n      return K.packet_tags.signature;\n    };\n\n    Signature.prototype.tag = function() {\n      return Signature.tag();\n    };\n\n    function Signature(_arg) {\n      this.key = _arg.key, this.payload = _arg.payload, this.sig = _arg.sig, this.detached = _arg.detached;\n      Signature.__super__.constructor.call(this);\n    }\n\n    Signature.prototype.get_packet_body = function() {\n      var hash_type, sig_type;\n      sig_type = Signature.SIG_TYPE;\n      hash_type = Signature.HASH_TYPE;\n      return {\n        key: this.key,\n        payload: this.payload,\n        sig: this.sig,\n        detached: this.detached,\n        sig_type: sig_type,\n        hash_type: hash_type\n      };\n    };\n\n    Signature.alloc = function(_arg) {\n      var a, b, body, err, ret, tag;\n      tag = _arg.tag, body = _arg.body;\n      ret = null;\n      err = tag !== Signature.tag() ? new Error(\"wrong tag found: \" + tag) : (a = body.hash_type) !== (b = Signature.HASH_TYPE) ? new Error(\"Expected SHA512 (type \" + b + \"); got \" + a) : (a = body.sig_type) !== (b = Signature.SIG_TYPE) ? err = new Error(\"Expected EDDSA (type \" + b + \"); got \" + a) : (ret = new Signature(body), null);\n      if (err != null) {\n        throw err;\n      }\n      return ret;\n    };\n\n    Signature.prototype.is_signature = function() {\n      return true;\n    };\n\n    Signature.prototype.verify = function(cb) {\n      var err, esc, km, pair, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"verify\");\n      err = km = null;\n      _ref = eddsa.Pair.parse_kb(this.key), err = _ref[0], pair = _ref[1];\n      (function(_this) {\n        return (function(__iced_k) {\n          if (err == null) {\n            (function(__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/signature.iced\",\n                funcname: \"Signature.verify\"\n              });\n              pair.verify_kb(_this, esc(__iced_deferrals.defer({\n                lineno: 58\n              })));\n              __iced_deferrals._fulfill();\n            })(__iced_k);\n          } else {\n            return __iced_k();\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, {\n            keypair: pair,\n            payload: _this.payload\n          });\n        };\n      })(this));\n    };\n\n    Signature.prototype.unbox = function(params, cb) {\n      var err, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/signature.iced\",\n            funcname: \"Signature.unbox\"\n          });\n          _this.verify(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return res = arguments[1];\n              };\n            })(),\n            lineno: 64\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, res);\n        };\n      })(this));\n    };\n\n    Signature.box = function(_arg, cb) {\n      var detached, esc, km, packet, pair, payload, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      km = _arg.km, payload = _arg.payload;\n      esc = make_esc(cb, \"@sign\");\n      pair = km.get_keypair();\n      detached = true;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/signature.iced\",\n            funcname: \"Signature.box\"\n          });\n          pair.sign_kb({\n            payload: payload,\n            detached: detached\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sig = arguments[0];\n              };\n            })(),\n            lineno: 73\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          packet = new Signature({\n            key: pair.ekid(),\n            payload: payload,\n            sig: sig,\n            detached: detached\n          });\n          return cb(null, packet);\n        };\n      })(this));\n    };\n\n    return Signature;\n\n  })(Packet);\n\n  exports.Signature = Signature;\n\n  exports.sign = Signature.sign;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/keybase/packet/encryption.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var C, Encryption, K, Packet, dh, iced, konst, make_esc, __iced_k, __iced_k_noop,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  konst = require('../../const');\n\n  K = konst.kb;\n\n  C = konst.openpgp;\n\n  Packet = require('./base').Packet;\n\n  make_esc = require('iced-error').make_esc;\n\n  dh = require('../../nacl/main').dh;\n\n  Encryption = (function(_super) {\n    __extends(Encryption, _super);\n\n    Encryption.ENC_TYPE = K.public_key_algorithms.NACL_DH;\n\n    Encryption.tag = function() {\n      return K.packet_tags.encryption;\n    };\n\n    Encryption.prototype.tag = function() {\n      return Encryption.tag();\n    };\n\n    function Encryption(_arg) {\n      this.encrypt_for = _arg.encrypt_for, this.sign_with = _arg.sign_with, this.plaintext = _arg.plaintext, this.ciphertext = _arg.ciphertext, this.sender_key = _arg.sender_key, this.nonce = _arg.nonce, this.anonymous = _arg.anonymous;\n      Encryption.__super__.constructor.call(this);\n      this.ephemeral = false;\n    }\n\n    Encryption.prototype.get_packet_body = function() {\n      var enc_type;\n      enc_type = Encryption.ENC_TYPE;\n      return {\n        sender_key: this.sender_key,\n        ciphertext: this.ciphertext,\n        nonce: this.nonce,\n        enc_type: enc_type,\n        receiver_key: this.receiver_key\n      };\n    };\n\n    Encryption.alloc = function(_arg) {\n      var a, b, body, err, ret, tag;\n      tag = _arg.tag, body = _arg.body;\n      ret = null;\n      err = tag !== Encryption.tag() ? new Error(\"wrong tag found: \" + tag) : (a = body.enc_type) !== (b = Encryption.ENC_TYPE) ? err = new Error(\"Expected Curve25519 DH (type \" + b + \"); got \" + a) : (ret = new Encryption(body), null);\n      if (err != null) {\n        throw err;\n      }\n      return ret;\n    };\n\n    Encryption.prototype.is_signature = function() {\n      return false;\n    };\n\n    Encryption.prototype.get_sender_keypair = function(_arg, cb) {\n      var encrypt, err, ret, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sign_with = _arg.sign_with, encrypt = _arg.encrypt;\n      err = ret = null;\n      (function(_this) {\n        return (function(__iced_k) {\n          if (sign_with != null) {\n            return __iced_k(ret = sign_with.get_keypair());\n          } else {\n            (function(__iced_k) {\n              if (_this.sign_with != null) {\n                return __iced_k(ret = _this.sign_with.get_keypair());\n              } else {\n                (function(__iced_k) {\n                  if (_this.sender_keypair != null) {\n                    return __iced_k(ret = _this.sender_keypair);\n                  } else {\n                    (function(__iced_k) {\n                      var _ref;\n                      if (encrypt) {\n                        (function(__iced_k) {\n                          __iced_deferrals = new iced.Deferrals(__iced_k, {\n                            parent: ___iced_passed_deferral,\n                            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n                            funcname: \"Encryption.get_sender_keypair\"\n                          });\n                          dh.Pair.generate({}, __iced_deferrals.defer({\n                            assign_fn: (function(__slot_1) {\n                              return function() {\n                                err = arguments[0];\n                                return __slot_1.sender_keypair = arguments[1];\n                              };\n                            })(_this),\n                            lineno: 56\n                          }));\n                          __iced_deferrals._fulfill();\n                        })(function() {\n                          ret = _this.sender_keypair;\n                          return __iced_k(_this.ephemeral = true);\n                        });\n                      } else {\n                        return __iced_k(_this.sender_key != null ? ((_ref = dh.Pair.parse_kb(_this.sender_key), err = _ref[0], _this.sender_keypair = _ref[1], _ref), err == null ? ret = _this.sender_keypair : void 0) : err = new Error(\"Cannot encrypt without a sender keypair\"));\n                      }\n                    })(__iced_k);\n                  }\n                })(__iced_k);\n              }\n            })(__iced_k);\n          }\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, ret);\n        };\n      })(this));\n    };\n\n    Encryption.prototype.encrypt = function(params, cb) {\n      var esc, recvr, sender, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      esc = make_esc(cb, \"encrypt\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n            funcname: \"Encryption.encrypt\"\n          });\n          _this.get_sender_keypair({\n            encrypt: true\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sender = arguments[0];\n              };\n            })(),\n            lineno: 71\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          recvr = _this.encrypt_for.get_keypair();\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n              funcname: \"Encryption.encrypt\"\n            });\n            recvr.encrypt_kb({\n              plaintext: _this.plaintext,\n              sender: sender\n            }, esc(__iced_deferrals.defer({\n              assign_fn: (function(__slot_1, __slot_2) {\n                return function() {\n                  __slot_1.ciphertext = arguments[0].ciphertext;\n                  return __slot_2.nonce = arguments[0].nonce;\n                };\n              })(_this, _this),\n              lineno: 73\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            if (!(_this.anonymous && !_this.ephemeral)) {\n              _this.sender_key = sender.ekid();\n            }\n            if (!_this.anonymous) {\n              _this.receiver_key = recvr.ekid();\n            }\n            return cb(null);\n          });\n        };\n      })(this));\n    };\n\n    Encryption.prototype.decrypt = function(_arg, cb) {\n      var args, encrypt_for, esc, recvr, sender, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for;\n      esc = make_esc(cb, \"decrypt\");\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n            funcname: \"Encryption.decrypt\"\n          });\n          _this.get_sender_keypair({\n            sign_with: sign_with\n          }, esc(__iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return sender = arguments[0];\n              };\n            })(),\n            lineno: 82\n          })));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          args = {\n            ciphertext: _this.ciphertext,\n            nonce: _this.nonce,\n            sender: sender\n          };\n          recvr = encrypt_for.get_keypair();\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n              funcname: \"Encryption.decrypt\"\n            });\n            recvr.decrypt_kb(args, esc(__iced_deferrals.defer({\n              assign_fn: (function(__slot_1) {\n                return function() {\n                  return __slot_1.plaintext = arguments[0];\n                };\n              })(_this),\n              lineno: 85\n            })));\n            __iced_deferrals._fulfill();\n          })(function() {\n            return cb(null, {\n              sender_keypair: sender,\n              plaintext: _this.plaintext,\n              receiver_keypair: recvr\n            });\n          });\n        };\n      })(this));\n    };\n\n    Encryption.prototype.unbox = function(_arg, cb) {\n      var encrypt_for, err, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      encrypt_for = _arg.encrypt_for;\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n            funcname: \"Encryption.unbox\"\n          });\n          _this.decrypt({\n            encrypt_for: encrypt_for\n          }, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                err = arguments[0];\n                return res = arguments[1];\n              };\n            })(),\n            lineno: 91\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          return cb(err, res);\n        };\n      })(this));\n    };\n\n    Encryption.box = function(_arg, cb) {\n      var anonymous, encrypt_for, err, packet, plaintext, sign_with, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      sign_with = _arg.sign_with, encrypt_for = _arg.encrypt_for, plaintext = _arg.plaintext, anonymous = _arg.anonymous;\n      packet = new Encryption({\n        sign_with: sign_with,\n        encrypt_for: encrypt_for,\n        plaintext: plaintext,\n        anonymous: anonymous\n      });\n      (function(_this) {\n        return (function(__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/kbpgp/src/keybase/packet/encryption.iced\",\n            funcname: \"Encryption.box\"\n          });\n          packet.encrypt({}, __iced_deferrals.defer({\n            assign_fn: (function() {\n              return function() {\n                return err = arguments[0];\n              };\n            })(),\n            lineno: 98\n          }));\n          __iced_deferrals._fulfill();\n        });\n      })(this)((function(_this) {\n        return function() {\n          if (typeof err !== \"undefined\" && err !== null) {\n            packet = null;\n          }\n          return cb(err, packet);\n        };\n      })(this));\n    };\n\n    return Encryption;\n\n  })(Packet);\n\n  exports.Encryption = Encryption;\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-kbpgp/node_modules/kbpgp/lib/ukm.js":"// Generated by IcedCoffeeScript 108.0.11\n(function() {\n  var iced, is_pgp_sig, kb, pgp, pgp_sig, __iced_k, __iced_k_noop;\n\n  iced = require('iced-runtime');\n  __iced_k = __iced_k_noop = function() {};\n\n  pgp = require('./openpgp/keymanager');\n\n  pgp_sig = require('./openpgp/sigeng');\n\n  kb = require('./keybase/hilev');\n\n  exports.import_armored_public = function(_arg, cb) {\n    var armored, asp, err, opts, ret, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    armored = _arg.armored, asp = _arg.asp, opts = _arg.opts;\n    warnings = null;\n    (function(_this) {\n      return (function(__iced_k) {\n        if (armored.match(/^-{5}BEGIN PGP PUBLIC KEY BLOCK-{5}/)) {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/ukm.iced\",\n              funcname: \"import_armored_public\"\n            });\n            pgp.KeyManager.import_from_armored_pgp({\n              armored: armored,\n              asp: asp,\n              opts: opts\n            }, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  err = arguments[0];\n                  ret = arguments[1];\n                  return warnings = arguments[2];\n                };\n              })(),\n              lineno: 12\n            }));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        } else {\n          (function(__iced_k) {\n            __iced_deferrals = new iced.Deferrals(__iced_k, {\n              parent: ___iced_passed_deferral,\n              filename: \"/Users/max/src/keybase/kbpgp/src/ukm.iced\",\n              funcname: \"import_armored_public\"\n            });\n            kb.KeyManager.import_public({\n              hex: armored\n            }, __iced_deferrals.defer({\n              assign_fn: (function() {\n                return function() {\n                  err = arguments[0];\n                  return ret = arguments[1];\n                };\n              })(),\n              lineno: 14\n            }));\n            __iced_deferrals._fulfill();\n          })(__iced_k);\n        }\n      });\n    })(this)((function(_this) {\n      return function() {\n        return cb(err, ret, warnings);\n      };\n    })(this));\n  };\n\n  is_pgp_sig = function(x) {\n    return x.match(/^-{5}BEGIN PGP MESSAGE-{5}/);\n  };\n\n  exports.decode_sig = function(_arg) {\n    var armored;\n    armored = _arg.armored;\n    if (is_pgp_sig(armored)) {\n      return pgp_sig.decode_sig({\n        armored: armored\n      });\n    } else {\n      return kb.decode_sig({\n        armored: armored\n      });\n    }\n  };\n\n  exports.get_sig_body = function(_arg) {\n    var armored;\n    armored = _arg.armored;\n    if (is_pgp_sig(armored)) {\n      return pgp_sig.get_sig_body({\n        armored: armored\n      });\n    } else {\n      return kb.get_sig_body({\n        armored: armored\n      });\n    }\n  };\n\n}).call(this);\n"}